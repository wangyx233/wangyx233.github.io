<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangyx233.github.io/"/>
  <updated>2020-06-02T09:13:13.388Z</updated>
  <id>https://wangyx233.github.io/</id>
  
  <author>
    <name>Xuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&lt;算法基础&gt;动态规划</title>
    <link href="https://wangyx233.github.io/2020/06/01/%5B%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%5D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://wangyx233.github.io/2020/06/01/[算法基础]动态规划/</id>
    <published>2020-06-01T06:55:32.693Z</published>
    <updated>2020-06-02T09:13:13.388Z</updated>
    
    <content type="html"><![CDATA[<h5 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h5><ol><li>计数：how many xxx? 多少种方法可以 blabla</li><li>求最大最小值：max，min…</li><li>求存在性：博弈，是否能 blabla，先手能不能赢，存不存在策略。</li></ol><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ol><li>确定状态。属于定海神针，相当于未知量，类似于 x,y,z。需要开一个数组</li></ol><ul><li>最后一步，最后一个。比如：一共有 k 个硬币，不关心 k-1 前的状态。只要保证 k-1 是最少的达到目标的</li><li>子问题。问题一样，规模变小</li></ul><p>递归的问题，会存在大量的重复计算，效率低下。所以如何优化呢？最容易想到的是加缓存，存一下中间计算值</p><ol start="2"><li><p>转移方程。问题解决了一半</p></li><li><p>初始条件，边界情况：注意边界情况处理数组不要越界，初始条件是一开始就能定下来的比如 f[0]一般是最小的，关键是用转移方程算不出来的，手动定义值。</p></li><li><p>计算顺序。一般情况是从小到大。从上到下，从左到右。原则是，算等式左边的时候，等式右边已经能算出来，用到的状态已经算到了</p></li></ol><p>消除冗余，加速计算。递归的另一种优化方式。</p><p><strong>加法原理</strong></p><ul><li>无重复</li><li>无遗漏</li></ul><h6 id="coin-change-最值"><a href="#coin-change-最值" class="headerlink" title="coin change 最值"></a>coin change 最值</h6><h6 id="unique-path-计数"><a href="#unique-path-计数" class="headerlink" title="unique path 计数"></a>unique path 计数</h6><h6 id="jump-game-存在性"><a href="#jump-game-存在性" class="headerlink" title="jump game 存在性"></a>jump game 存在性</h6><h5 id="常见的动态规划的类型"><a href="#常见的动态规划的类型" class="headerlink" title="常见的动态规划的类型"></a>常见的动态规划的类型</h5><ul><li>坐标</li><li>序列</li><li>划分</li><li>区间</li><li>背包</li><li>最长序列，最长上升子序列</li><li>博弈</li><li>综合</li><li>打印路径</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;适用情况&quot;&gt;&lt;a href=&quot;#适用情况&quot; class=&quot;headerlink&quot; title=&quot;适用情况&quot;&gt;&lt;/a&gt;适用情况&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;计数：how many xxx? 多少种方法可以 blabla&lt;/li&gt;
&lt;li&gt;求最大最小值：max，min…
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>时间&amp;空间复杂度</title>
    <link href="https://wangyx233.github.io/2020/05/12/%5B%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%5D%E6%97%B6%E9%97%B4&amp;%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://wangyx233.github.io/2020/05/12/[算法基础]时间&amp;空间复杂度/</id>
    <published>2020-05-12T14:14:17.326Z</published>
    <updated>2020-05-13T03:04:03.772Z</updated>
    
    <content type="html"><![CDATA[<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>用 Big O 表示，用来表示程度运行时间维度上的趋势。所以 O 表示忽略掉不重要的部分，留下的关键关系。<br>常见的时间复杂度有：</p><ul><li>常数 O(1)</li><li>对数 O(logn)</li><li>线性 O(n)</li><li>n 的次方 O(n^2…)</li><li>指数 O(k^n)</li><li>阶乘 O(n!)<br>一般通过看随着 n 的改变，代码要运行多少次。n 比较小的话，其实时间复杂度都差不多，关注时间复杂度的情况一般对数据量较大时，程序的效率问题。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 比如：普通递归计算斐波那契，理解递归总共执行了多少次，善用缓存，避免重复计算。或者循环</span><br><span class="line">const fib = (n) =&gt; &#123;</span><br><span class="line">  if (n &lt; 2) return n;</span><br><span class="line">  return fib(n - 1) + fib(n - 2);</span><br><span class="line">&#125;</span><br><span class="line">// O(2^k)</span><br></pre></td></tr></table></figure><h6 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h6><p>用于进行递归程序的时间复杂度计算，一般常见的算法有：</p><ul><li>二分查找 O(logn)</li><li>二叉树遍历 O(n)</li><li>有序二维数据查找 O(n)</li><li>归并排序 O(nlogn)</li></ul><p>二叉树的前中后序遍历，图遍历，搜索算法 DFS,BFS，时间复杂度都是 O(n)，因为有且只经过了每个节点一次，所以是和节点数成线性相关的。</p><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><p>如果是数组，那就是数组的长度，O(n)。二维数组，O(n^2)。<br>如果是递归的，那就是递归的深度，如果递归里面又开了数组，则是两者的最大值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h5&gt;&lt;p&gt;用 Big O 表示，用来表示程度运行时间维度上的趋势。所以 O 表示忽略掉不重要的部分，留下的关键关系。&lt;br&gt;常
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://wangyx233.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>&lt;CSS&gt;回顾伪类与伪元素</title>
    <link href="https://wangyx233.github.io/2020/05/11/%5BCSS%5D%E5%9B%9E%E9%A1%BE%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    <id>https://wangyx233.github.io/2020/05/11/[CSS]回顾伪类与伪元素/</id>
    <published>2020-05-11T06:35:48.173Z</published>
    <updated>2020-05-11T15:06:43.936Z</updated>
    
    <content type="html"><![CDATA[<p>在重温 CSS 选择的时候，看到伪类与伪元素有一瞬间迷惑之情，所以这次重新加深一番印象。</p><h5 id="伪类-pseudo-classes-？伪元素-pseudo-elements-？"><a href="#伪类-pseudo-classes-？伪元素-pseudo-elements-？" class="headerlink" title="伪类(pseudo-classes)？伪元素(pseudo-elements)？"></a>伪类(pseudo-classes)？伪元素(pseudo-elements)？</h5><p>为什么要引入伪类，伪元素？为了格式化文档树以外的信息。</p><ul><li>伪类：用于描述已经存在的元素的某个状态，添加对应的样式。用:,如：hover,:first-child…</li><li>伪元素：用于创建一些不在文档树中的元素。多用::,如：::before,::after…，虽然用户可以看到这些内容，但事实上并不存在在文档树中。</li></ul><p>补充：CSS 的选择器</p><ol><li>元素选择器</li></ol><ul><li>* 通配符选择器</li><li>div,p,span… 元素选择器</li><li>#id</li><li>.class</li></ul><ol start="2"><li>属性选择器</li></ol><ul><li>[attr]</li><li>[attr=val]</li><li>[attr^=val] 以 val 开头属性值的元素</li><li>[attr$=val] 以 val 结尾</li><li>[attr*=val] 属性值包含这个 val 属性值的元素</li><li>[attr~=val] 属性值为 val，或其中一个值为 val 的元素</li><li>[attr|=val] 属性值为 val，或者 val-xxx 的元素</li><li>i 不区分大小写，s 区分大小写<br>eg. <a href="https://codepen.io/yx233/pen/abvGgad" target="_blank" rel="noopener">https://codepen.io/yx233/pen/abvGgad</a></li></ul><ol start="3"><li>关系选择器</li></ol><ul><li>后代选择器： 空格，所有后代</li><li>子选择器：&gt; 直接后代，不包括隔代元素</li><li>兄弟选择器：~ 所有兄弟结点</li><li>相邻选择气：+ 相邻兄弟结点</li></ul><p>选择指向越准确，优先级越高。尽量减少 CSS 选择器的层数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在重温 CSS 选择的时候，看到伪类与伪元素有一瞬间迷惑之情，所以这次重新加深一番印象。&lt;/p&gt;
&lt;h5 id=&quot;伪类-pseudo-classes-？伪元素-pseudo-elements-？&quot;&gt;&lt;a href=&quot;#伪类-pseudo-classes-？伪元素-pseud
      
    
    </summary>
    
    
      <category term="CSS" scheme="https://wangyx233.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>&lt;重温JS&gt;正则从开始到结束</title>
    <link href="https://wangyx233.github.io/2020/05/08/%5B%E9%87%8D%E6%B8%A9JS%5D%E6%AD%A3%E5%88%99%E4%BB%8E%E5%BC%80%E5%A7%8B%E5%88%B0%E7%BB%93%E6%9D%9F/"/>
    <id>https://wangyx233.github.io/2020/05/08/[重温JS]正则从开始到结束/</id>
    <published>2020-05-08T09:06:15.947Z</published>
    <updated>2020-05-08T09:21:49.692Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式用的元字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() [] &#123;&#125; | \ ^ $ . * + ?</span><br></pre></td></tr></table></figure><p>通过 new RegExp() 前一个要转换成字符串，不能直接用正则字面量。如元字符要进行双重转义。<br>正则表达式的 valueOf(),返回正则表达式本身。</p><p>regexp.test(text)<br>regexp.exec(text)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式用的元字符：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
      
    
    </summary>
    
    
      <category term="RegExp" scheme="https://wangyx233.github.io/tags/RegExp/"/>
    
  </entry>
  
  <entry>
    <title>&lt;重温JS&gt;时间处理二三事</title>
    <link href="https://wangyx233.github.io/2020/05/08/%5B%E9%87%8D%E6%B8%A9JS%5D%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>https://wangyx233.github.io/2020/05/08/[重温JS]时间处理二三事/</id>
    <published>2020-05-08T08:48:01.658Z</published>
    <updated>2020-05-08T09:00:04.521Z</updated>
    
    <content type="html"><![CDATA[<p>const current = new Date();<br>Date.parse(current); //turn to UTC,ms<br>Date.UTC(year, month - 1 )<br>Date.now() // s<br>+new Date();</p><p>.toString(),字符串；.valueOf(),数值 ms</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;const current = new Date();&lt;br&gt;Date.parse(current); //turn to UTC,ms&lt;br&gt;Date.UTC(year, month - 1 )&lt;br&gt;Date.now() // s&lt;br&gt;+new Date();&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="moment.js" scheme="https://wangyx233.github.io/tags/moment-js/"/>
    
      <category term="Date" scheme="https://wangyx233.github.io/tags/Date/"/>
    
  </entry>
  
  <entry>
    <title>&lt;安全&gt;从基本安全概念到HTTPS发生了什么</title>
    <link href="https://wangyx233.github.io/2020/05/08/%5B%E5%AE%89%E5%85%A8%5D%E4%BB%8E%E5%9F%BA%E6%9C%AC%E5%AE%89%E5%85%A8%E6%A6%82%E5%BF%B5%E5%88%B0Https/"/>
    <id>https://wangyx233.github.io/2020/05/08/[安全]从基本安全概念到Https/</id>
    <published>2020-05-08T08:23:25.292Z</published>
    <updated>2020-05-11T15:11:55.481Z</updated>
    
    <content type="html"><![CDATA[<p>A 要给 B 发送信息</p><h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><p>加密和解密用的密钥是相同的。</p><h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><p>公钥加密，私钥解密。传递公钥</p><h5 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h5><h5 id="数字签名，数字证书"><a href="#数字签名，数字证书" class="headerlink" title="数字签名，数字证书"></a>数字签名，数字证书</h5><p>私钥加密，公钥解密。传递公钥<br>数字中心</p><h5 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h5><p>先认证服务端，然后服务端再传递加密内容。<br>再进行秘文交换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A 要给 B 发送信息&lt;/p&gt;
&lt;h5 id=&quot;对称加密&quot;&gt;&lt;a href=&quot;#对称加密&quot; class=&quot;headerlink&quot; title=&quot;对称加密&quot;&gt;&lt;/a&gt;对称加密&lt;/h5&gt;&lt;p&gt;加密和解密用的密钥是相同的。&lt;/p&gt;
&lt;h5 id=&quot;非对称加密&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="HTTPS" scheme="https://wangyx233.github.io/tags/HTTPS/"/>
    
      <category term="对称加密" scheme="https://wangyx233.github.io/tags/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="非对称加密" scheme="https://wangyx233.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="数字签名" scheme="https://wangyx233.github.io/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>&lt;Algorithm&gt;查找</title>
    <link href="https://wangyx233.github.io/2020/04/27/%5B%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%5D%E6%9F%A5%E6%89%BE/"/>
    <id>https://wangyx233.github.io/2020/04/27/[算法基础]查找/</id>
    <published>2020-04-27T08:56:53.445Z</published>
    <updated>2020-04-27T09:07:08.708Z</updated>
    
    <content type="html"><![CDATA[<h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>特点：有序列表的查找，时间复杂度 O(logN)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const binary_search = (list, x) =&gt; &#123;</span><br><span class="line">  const mid = Math.ceil(list.length / 2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回忆一下指数，对数是什么，对数是指数的逆运算，求幂的次数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h5&gt;&lt;p&gt;特点：有序列表的查找，时间复杂度 O(logN)&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://wangyx233.github.io/tags/Algorithm/"/>
    
      <category term="search" scheme="https://wangyx233.github.io/tags/search/"/>
    
  </entry>
  
  <entry>
    <title>&lt;了解&gt;浏览器是如何工作的？</title>
    <link href="https://wangyx233.github.io/2020/04/27/%5B%E6%B5%8F%E8%A7%88%E5%99%A8%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/"/>
    <id>https://wangyx233.github.io/2020/04/27/[浏览器]浏览器是如何工作的？/</id>
    <published>2020-04-27T08:07:25.056Z</published>
    <updated>2020-04-27T08:56:01.130Z</updated>
    
    <content type="html"><![CDATA[<p>在浏览器地址栏输入 URL 发生了什么？</p><ol><li>如果是域名，先进行 DNS 解析，根据 IP 地址去服务端请求页面；</li><li>拿到服务端返回的 HTML，解析构建成 DOM 树；</li><li>计算 DOM🌲 上的 CSS 属性；</li><li>根据 CSS 渲染每个元素，在内存中保存为位图；</li><li>进行渲染合成绘制。</li></ol><p>整个过程是流式过程，网页是逐渐加载出来的。</p><h5 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h5><p>HTTP 协议是基于 TCP 协议的，TCP 协议是一个双向协议，而 HTTP 协议是在此基础上规定了 Requst-Response 模式，并且用来传输文本。可以理解为用 TCP 规定了一种用来传输文本的应用层协议。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在浏览器地址栏输入 URL 发生了什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果是域名，先进行 DNS 解析，根据 IP 地址去服务端请求页面；&lt;/li&gt;
&lt;li&gt;拿到服务端返回的 HTML，解析构建成 DOM 树；&lt;/li&gt;
&lt;li&gt;计算 DOM🌲 上的 CSS 属性；&lt;/li
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>&lt;JS Review&gt;垃圾收集</title>
    <link href="https://wangyx233.github.io/2020/04/24/%5B%E9%87%8D%E6%B8%A9JS%5D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
    <id>https://wangyx233.github.io/2020/04/24/[重温JS]垃圾收集/</id>
    <published>2020-04-24T08:21:39.625Z</published>
    <updated>2020-05-07T11:31:28.988Z</updated>
    
    <content type="html"><![CDATA[<p>JS 中实现了自动垃圾回收机制，自动分配内存和释放内存。原理是：找到那些不再使用的变量，然后释放它所占的内存。然后按照固定的时间间隔执行。<br>垃圾收集器需要跟踪变量有没有用，对没有用的变量打上标记，以便后续的回收。标识变量的策略常用的有，标记清除，引用计数。</p><ul><li>标记清除 Mark and Sweep<br>进入环境标记。或者维护一个进入环境的列表，一个离开环境的列表。把环境中用到的或者被其他环境内引用的变量标记去掉，剩下还有标记的都是需要删除的变量。</li><li>引用计数 Reference Count。可能会导致内存一直得不到释放，比如在函数内，两个对象相互调用</li></ul><p>解除引用 Dereferencing,一旦不再使用，最好将他们的值置位 null。主要是全局变量，全局对象等。因为局部变量都会在离开执行环境后，直接解除引用。解除引用，是让这个值脱离执行环境，而不是立即内存回收。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JS 中实现了自动垃圾回收机制，自动分配内存和释放内存。原理是：找到那些不再使用的变量，然后释放它所占的内存。然后按照固定的时间间隔执行。&lt;br&gt;垃圾收集器需要跟踪变量有没有用，对没有用的变量打上标记，以便后续的回收。标识变量的策略常用的有，标记清除，引用计数。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>&lt;JS Review&gt;类型检测</title>
    <link href="https://wangyx233.github.io/2020/04/22/%5B%E9%87%8D%E6%B8%A9JS%5D%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <id>https://wangyx233.github.io/2020/04/22/[重温JS]类型判断/</id>
    <published>2020-04-22T07:27:30.603Z</published>
    <updated>2020-05-07T11:36:08.324Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>来自 null 的拷问？我是谁，我在哪儿</strong></li><li><strong>[Symbol.toStringTag]</strong></li></ul><p>基本数据类型在内存中占用固定大小的内存空间，因此被保存在栈内存中。引用类型，保存在堆内存中。</p><h5 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h5><p>typeof 是检测基本数据类型的利器，number，string，boolean，undefined。<br>null，object 都只会返回 object；function 返回 function</p><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><p>variable instanceof constructor 判断是什么类型的对象，结果返回 true or false。<br>基础类型判断返回 false</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;来自 null 的拷问？我是谁，我在哪儿&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Symbol.toStringTag]&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本数据类型在内存中占用固定大小的内存空间，因此被保存在栈内存中
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/tags/JavaScript/"/>
    
      <category term="typeof" scheme="https://wangyx233.github.io/tags/typeof/"/>
    
      <category term="instanceof" scheme="https://wangyx233.github.io/tags/instanceof/"/>
    
      <category term="Object.prototype.toString.call()" scheme="https://wangyx233.github.io/tags/Object-prototype-toString-call/"/>
    
  </entry>
  
  <entry>
    <title>&lt;Algorithm&gt;树</title>
    <link href="https://wangyx233.github.io/2020/04/20/%5B%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%5D%E6%A0%91/"/>
    <id>https://wangyx233.github.io/2020/04/20/[算法基础]树/</id>
    <published>2020-04-20T06:05:28.236Z</published>
    <updated>2020-04-27T07:38:22.356Z</updated>
    
    <content type="html"><![CDATA[<h5 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h5><p>何为树？ 想象一下自然界的 🌲 形态，用术语表达即为：没有闭环的无向图。几个特征可以描述为：每个节点之间有且只有一条路径相连通；如果增加一条路径，图就会连通起来；所以边的数量为节点数-1。节点和路径可以理解为 🌲 的叉。<br>所以二叉树，就是每个节点最多有两条边，即最多有左右两个节点的树。<br>满二叉树即为每个节点如果有子节点那左右节点都具备。如果有这个树有 n 层，那总节点数为 2 の n 次方 - 1，第 n 层的节点数为 2(n -1)。<br>完全二叉树，则是除了最后一层其他层的节点都填满，并且如果最后一层叶子节点如果是右节点，那这个叶子节点的左边必有节点。<br>二叉树的遍历方式：遍历的顺序为根节点在遍历中的顺序。</p><ul><li>前序遍历：根-左-右</li><li>中序遍历：左-根-右</li><li>后序遍历：左-右-根</li></ul><h5 id="优先队列-堆"><a href="#优先队列-堆" class="headerlink" title="优先队列-堆"></a>优先队列-堆</h5><p>理论说明：根节点和子节点之间的关系，以及结点数量。</p><ol><li>如何建堆，最大堆，最小堆。</li><li>数据插入</li><li>应用场景，堆排序，第 K 大的数</li></ol><p>时间复杂度</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h5&gt;&lt;p&gt;何为树？ 想象一下自然界的 🌲 形态，用术语表达即为：没有闭环的无向图。几个特征可以描述为：每个节点之间有且只有一条路径相
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://wangyx233.github.io/tags/Algorithm/"/>
    
      <category term="tree" scheme="https://wangyx233.github.io/tags/tree/"/>
    
      <category term="Binary tree" scheme="https://wangyx233.github.io/tags/Binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>&lt;JS Review&gt;对象</title>
    <link href="https://wangyx233.github.io/2020/04/20/%5B%E9%87%8D%E6%B8%A9JS%5D%E5%AF%B9%E8%B1%A1/"/>
    <id>https://wangyx233.github.io/2020/04/20/[重温JS]对象/</id>
    <published>2020-04-20T06:04:50.253Z</published>
    <updated>2020-05-14T09:26:36.975Z</updated>
    
    <content type="html"><![CDATA[<h5 id="对象是什么？"><a href="#对象是什么？" class="headerlink" title="对象是什么？"></a>对象是什么？</h5><ul><li>具有唯一标识，内存地址。</li><li>具有状态，属性。</li><li>具有行为，方法。</li></ul><p>JS 的对象具有高度的动态性，可以在运行时对对象添加状态，修改行为。<br>JS 中 Object 的定义，用 new 构造函数()、对象字面量</p><p>构造类的函数-&gt;类的构造函数，一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。用 this 创建对象，无需重新创建一个对象再返回。<br>创建对象的方法，字面量，构造函数，new Object()，Object.create</p><h5 id="对象的属性类型"><a href="#对象的属性类型" class="headerlink" title="对象的属性类型"></a>对象的属性类型</h5><p>JS 中，属性和方法其实都可以成为对象的属性。属性并不是简单的名称和值，可以用一组特征来描述属性，可分为数据属性和访问器(getter/setter)属性两类。</p><ul><li>数据属性。这个就是常见的对象属性，具有以下特征：</li></ul><ol><li>value</li><li>writable：能否被赋值</li><li>enumerable：被 for in 枚举</li><li>configurable：被删除，或者改变特征值。false 时，writable 可从 true-&gt;false，但无法反向修改。enumerable 则不能修改，会报 TypeError: cannot redefine property。一旦设置为 false，cannot set true</li></ol><ul><li>访问器(getter/setter)属性。属性在读写的时候执行。</li></ul><ol><li>getter：get: () =&gt; {} || undifined</li><li>setter: set: () =&gt; {} || undifined，两者成对出现，若不设置则为 undefined</li><li>enumerable：被 for in 枚举</li><li>configurable：被删除，或者改变特征值<br>ES5 以后：<br>查看属性可用，Object.getOwnPropertyDescripter(object, ‘key’)<br>设置属性的特性可用，Object.defineProperty(object, ‘key’, {})<br>如果通过赋值的方式为属性赋值，则该属性的特征都默认为 true。但如果通过 defineProperty 赋值而不指定特性，则特征都默认为 false</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;a:1&#125;;</span><br><span class="line">o.b = 2;</span><br><span class="line">Object.getOwnPropertyDescripter(o, &apos;b&apos;);</span><br><span class="line"></span><br><span class="line">Object.defineProperty(o, &apos;c&apos;, &#123;value: 3&#125;);</span><br><span class="line">Object.getOwnPropertyDescripter(o, &apos;c&apos;);</span><br><span class="line"></span><br><span class="line">var o = &#123; get a() &#123; return &apos;a&apos; &#125; &#125;;</span><br><span class="line">Object.defineProperty(o, &apos;b&apos;, &#123;get: () =&gt; 2, set: (b) =&gt; console.log(b), configurable:true&#125;)</span><br></pre></td></tr></table></figure><h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><a id="more"></a><p>基于类的面向对象 vs 基于原型的面向对象<br>JS 的原型系统可以描述为：</p><ul><li>每个对象都有一个私有的[[prototype]]，为该对象的原型。</li><li>从对象中获取一个属性，如果自身没有，则会去它的原型上访问，直到原型为空或者找到了该属性为止。</li></ul><p>ES6 以前版本的，面向对象的使用方式，new</p><p><em>new 操作发生了什么</em><br>new fun(x,y,z)</p><ol><li>以构造器的 prototype 属性为原型，创建一个新对象；</li><li>将 this，参数传入构造器进行执行；</li><li>如果构造器返回的是对象，则返回该对象，否则返回(1)创建的对象。</li></ol><p>所以，用 new 的方式进行类的实现，可以在构造函数里面添加属性返回对象，也可以在构造函数的 prototype 里面增加属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">  this.a = 1;</span><br><span class="line">&#125;</span><br><span class="line">var t = new test;</span><br><span class="line"></span><br><span class="line">function test1() &#123;&#125;;</span><br><span class="line">test1.prototype.a = 1;</span><br><span class="line">var t1 = new test1;</span><br></pre></td></tr></table></figure><p>ES6 以后，提供了三个直接操作对象原型的内置方法，因此我们可以通过这些方法直接操作对象的原型，而不需要借助以前基于类的方式来进行。</p><ul><li>Object.create(proto, {…new object}) 根据指定的原型创建新的对象，原型可以为 null</li><li>Object.getPrototypeOf 获取对象的原型</li><li>Object.setPrototypeOf 设置对象的原型</li></ul><p>ES6 提供了 class extends，类中定义的方法和属性则会被写在原型对象之上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class animals &#123;</span><br><span class="line">  constructor(name) &#123; // 数据属性</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  get value() &#123; return this.name; &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(this.name + &apos;is eating!&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class dogs extends animals &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    super(name); // 执行父类的constructor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dog = new dogs(&apos;shishi&apos;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arguments，类数组，可以取值，也可以得到length</span><br><span class="line">arguments[0] 和 传入的第一个参数的值保持一致，js都是通过值传参的，改变arguments[0],第一个参数的值也会变。但如果没有传入参数，则对应的值也不会改变。</span><br><span class="line">在严格模式里，不允许这样的操作。</span><br><span class="line">函数的参数传递都是按值传递的，并不是按引用传递的。值的复制，分基本类型和引用类型。值和内存地址。所以函数的参数可以当做局部变量。</span><br><span class="line">function setName(obj) &#123;</span><br><span class="line">  obj.name = &apos;hoho&apos;;</span><br><span class="line">  obj = new Object();</span><br><span class="line">  obj.name = &apos;hehe&apos;;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Object();</span><br><span class="line">setName(person);</span><br><span class="line">console.log(person.name)</span><br></pre></td></tr></table></figure><h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><p>提供的内置 API，pop(),push(),shift(),unshift(),向数组插入元素的返回数组的 length，从数组中取元素的返回取的元素。<br>sort(),按字符串排序会调用 toString(),所以会借用 sort((a,b) =&gt; {return a - b;}) 返回负数，a 在 b 前面，正数 a 在 b 后面</p><p>concat(),slice()原数组都不会变，都是复制原来的数组生成新的返回。slice()负数，加上数组长度即可。<br>splice 修改原数组，返回操作的数组，只有一项。</p><p>indexOf,lastIndexOf 比较是通过===比较的,所以对象数组的 indexOf 会比较引用在不在，然后返回。</p><p>every [] -&gt; true<br>some [] -&gt; false<br>filter -&gt; []<br>forEach 返回 undefined，一般不需要返回值，或者说如果要用 return，则推荐用 map。若要修改原来数组，需要 return 配合原数组的索引修改。直接同 map 一样 return 值并不会改变。主要功能是对数据进行遍历，进行操作。<br>map 需要 return 返回值，若没有则返回 undefined，结果为修改后生成的新的数组，不会修改原来的数组。速度能更快一些<br>比如食材，cook 的实例。<br>共同点：没有 break 和 continue<br>通过 return 结束本次循环。<br>for…of(break,continue 正常) return 会报错。<br>why？<br>for…in 都不太行<br>reduce,reduceRight 处理 obj 便利</p><h6 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h6><p>函数是对象，函数名是指针<br>函数声明 vs 函数表达式<br>函数声明的函数，解析器会率先读取函数声明，并且在函数执行前可用；函数表达式必须等到函数解析器执行到它所在的代码行，才会被真正的解析执行。<br>函数声明提升。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">function wa() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 函数表达式</span><br><span class="line">var wa = function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数内部有两个特殊的对象，arguments，this。arguments 是一个类数组，它有一个特殊的属性 callee，是一个指向拥有 arguments 函数的指针。<br>比如递归中，如果外部函数被重写了用 arguments.callee()调用自身，递归还会正常执行。<br>this 是函数执行的环境对象。调用者的环境。<br>caller，保存这调用当前函数的函数的引用，即调用当前函数的函数是什么。可以用 arguments.callee.caller 表示。解除耦合。<br>严格模式下，callee，caller 都 🙅‍♂️<br>函数都有两个非继承而来的方法，apply()和 call()，用于改变函数内 this 的指向，即在特定的作用域内调用函数。<br>sum.apply(object, arguments)<br>sum.call(object, arg1, arg2)<br>只是传参的方式不一样而已。能方便的更改函数调用的作用域，减少耦合程度。<br>bind(),更改 this 指向。如：sum.bind(object)<br>fun.toString() / fun.valueOf() 返回函数代码</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;对象是什么？&quot;&gt;&lt;a href=&quot;#对象是什么？&quot; class=&quot;headerlink&quot; title=&quot;对象是什么？&quot;&gt;&lt;/a&gt;对象是什么？&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;具有唯一标识，内存地址。&lt;/li&gt;
&lt;li&gt;具有状态，属性。&lt;/li&gt;
&lt;li&gt;具有行为，方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JS 的对象具有高度的动态性，可以在运行时对对象添加状态，修改行为。&lt;br&gt;JS 中 Object 的定义，用 new 构造函数()、对象字面量&lt;/p&gt;
&lt;p&gt;构造类的函数-&amp;gt;类的构造函数，一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。用 this 创建对象，无需重新创建一个对象再返回。&lt;br&gt;创建对象的方法，字面量，构造函数，new Object()，Object.create&lt;/p&gt;
&lt;h5 id=&quot;对象的属性类型&quot;&gt;&lt;a href=&quot;#对象的属性类型&quot; class=&quot;headerlink&quot; title=&quot;对象的属性类型&quot;&gt;&lt;/a&gt;对象的属性类型&lt;/h5&gt;&lt;p&gt;JS 中，属性和方法其实都可以成为对象的属性。属性并不是简单的名称和值，可以用一组特征来描述属性，可分为数据属性和访问器(getter/setter)属性两类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据属性。这个就是常见的对象属性，具有以下特征：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;value&lt;/li&gt;
&lt;li&gt;writable：能否被赋值&lt;/li&gt;
&lt;li&gt;enumerable：被 for in 枚举&lt;/li&gt;
&lt;li&gt;configurable：被删除，或者改变特征值。false 时，writable 可从 true-&amp;gt;false，但无法反向修改。enumerable 则不能修改，会报 TypeError: cannot redefine property。一旦设置为 false，cannot set true&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;访问器(getter/setter)属性。属性在读写的时候执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;getter：get: () =&amp;gt; {} || undifined&lt;/li&gt;
&lt;li&gt;setter: set: () =&amp;gt; {} || undifined，两者成对出现，若不设置则为 undefined&lt;/li&gt;
&lt;li&gt;enumerable：被 for in 枚举&lt;/li&gt;
&lt;li&gt;configurable：被删除，或者改变特征值&lt;br&gt;ES5 以后：&lt;br&gt;查看属性可用，Object.getOwnPropertyDescripter(object, ‘key’)&lt;br&gt;设置属性的特性可用，Object.defineProperty(object, ‘key’, {})&lt;br&gt;如果通过赋值的方式为属性赋值，则该属性的特征都默认为 true。但如果通过 defineProperty 赋值而不指定特性，则特征都默认为 false&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var o = &amp;#123;a:1&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;o.b = 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.getOwnPropertyDescripter(o, &amp;apos;b&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(o, &amp;apos;c&amp;apos;, &amp;#123;value: 3&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.getOwnPropertyDescripter(o, &amp;apos;c&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var o = &amp;#123; get a() &amp;#123; return &amp;apos;a&amp;apos; &amp;#125; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(o, &amp;apos;b&amp;apos;, &amp;#123;get: () =&amp;gt; 2, set: (b) =&amp;gt; console.log(b), configurable:true&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h5 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h5&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/tags/JavaScript/"/>
    
      <category term="Object" scheme="https://wangyx233.github.io/tags/Object/"/>
    
      <category term="prototype" scheme="https://wangyx233.github.io/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>Hover&amp;Focus Effects 简单动画示例</title>
    <link href="https://wangyx233.github.io/2020/04/16/%5BCSS%5DInput%20Bottom%20Animation/"/>
    <id>https://wangyx233.github.io/2020/04/16/[CSS]Input Bottom Animation/</id>
    <published>2020-04-16T03:36:09.777Z</published>
    <updated>2020-05-11T06:31:00.723Z</updated>
    
    <content type="html"><![CDATA[<p>登录页进行账号输入时，为了让焦点聚集在当前输入框上可能会需要配合一些动画效果，或者是某个内容的重点提醒也会在 hover 时增加醒目动画。这些设计虽然很古老，也有用到的场合。<br>主要是借助 CSS3 的 transition 来做效果变换，示例如下：<a href="https://codepen.io/yx233/pen/YzywdJQ" target="_blank" rel="noopener">https://codepen.io/yx233/pen/YzywdJQ</a></p><h5 id="普通元素-hover-effects"><a href="#普通元素-hover-effects" class="headerlink" title="普通元素 hover effects"></a>普通元素 hover effects</h5><ul><li>简单的 border-color 变换。</li><li>借助伪元素实现从左-&gt;右，或从中间向两边延伸的效果。</li></ul><h5 id="input-的-focus"><a href="#input-的-focus" class="headerlink" title="input 的 focus"></a>input 的 focus</h5><p>::after ::before 是指元素文档树内渲染前、后的内容，input 不支持。所以需要借助额外的兄弟元素进行效果实现。</p><p>注：[:focus-within]是当一个元素或者元素的后代有[:focus]伪类时生效的一个选择器。对输入框获得焦点时，其前后左右的小图标，下滑动画等变换都有非常实用的效果。</p><p>注意：登录框前有时会配合放一些小图标，如果用把 icon 当做 input 的 background-image，同时通过定位的方式定位，需要格外注意 Chrome 记住密码情况下的展示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">input[name=&apos;user&apos;] &#123;</span><br><span class="line">  background-image: url(/login/user.svg);</span><br><span class="line">  background-position: 12px;</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">&#125;</span><br><span class="line">// 注意</span><br><span class="line">input:-webkit-autofill,</span><br><span class="line">input:-webkit-autofill:hover,</span><br><span class="line">input:-webkit-autofill:focus,</span><br><span class="line">input:-webkit-autofill:active &#123;</span><br><span class="line">  -webkit-transition: color 9999s linear, background-color 9999s linear;</span><br><span class="line">  -webkit-transition-delay: 9999s;</span><br><span class="line">  background-color: XXX;</span><br><span class="line">  color: XXX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;登录页进行账号输入时，为了让焦点聚集在当前输入框上可能会需要配合一些动画效果，或者是某个内容的重点提醒也会在 hover 时增加醒目动画。这些设计虽然很古老，也有用到的场合。&lt;br&gt;主要是借助 CSS3 的 transition 来做效果变换，示例如下：&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="css" scheme="https://wangyx233.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>重温</title>
    <link href="https://wangyx233.github.io/2020/03/12/%E9%87%8D%E6%B8%A9%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wangyx233.github.io/2020/03/12/重温学习/</id>
    <published>2020-03-12T07:52:56.250Z</published>
    <updated>2020-05-08T11:46:24.299Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>7 种语言类型<br>undefined 是一个变量，而并非是一个关键字。老的浏览器中会是，ES5 以后就不是了。函数内部，对象的属性现在也是可以赋值的。<br>if(typeof str === ‘undefined’){<br>// 如果直接用 str === undefined, str 未声明的话可能会报错 not defined<br>}<br>String 用于表示文本数据。String 有最大长度是 2^53 - 1，字符串的 UTF16 编码，charAt、charCodeAt、length 等方法针对的都是 UTF16 编码<br>Number 2^64-2^53+3<br>NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字；Infinity，无穷大；-Infinity，负无穷大。<br>还有 +0 -0，1/x 是 Infinity 还是 -Infinity<br>Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON</p><p>Symbol 可以用于迭代器，Symbol.iterator 需要有 next 和 done，next 返回一个对象包括 value 和 done</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o = new Object</span><br><span class="line"></span><br><span class="line">o[Symbol.iterator] = function() &#123;</span><br><span class="line">    var v = 0</span><br><span class="line">    return &#123;</span><br><span class="line">        next: function() &#123;</span><br><span class="line">            return &#123; value: v++, done: v &gt; 10 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for(var v of o)</span><br><span class="line">    console.log(v); // 0 1 2 3 ... 9</span><br></pre></td></tr></table></figure><p>Object.prototype.toString.call() 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。<br>装箱，是指讲基本数据类型转化为对象。拆箱是把对象转换成基本数据类型。valueOf()，toString(),或者用 Symbol.toPrimitive 自定义转换覆盖以前的。<br>众所周知的 Symbol</p><p>数组的 toString(),会返回一个字符串的拼接；valueOf 还是返回数组。</p><p>通过 new Number()声明的类型和直接用 Number()声明的类型不同，object 与 number 的区别。<br>toString()还可以传入进制进行计算。valueOf 返回数字</p><p>toFixed(), toPrecision(num)向上取整, toExponential()科学计数法</p><p>String,chartAt(index),chartCodeAt(index)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;7 种语言类型&lt;br&gt;undefined 是一个变量，而并非是一个关键字。老的浏览器中会是，ES5 以后就不是了。函数内部，对象的属性现在也是可以赋值的。&lt;br&gt;if(typeof str === ‘undefined’){&lt;br&gt;// 如果直接用 str
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS Secrets</title>
    <link href="https://wangyx233.github.io/2019/08/29/css_secret/"/>
    <id>https://wangyx233.github.io/2019/08/29/css_secret/</id>
    <published>2019-08-29T03:23:05.438Z</published>
    <updated>2020-04-15T11:12:07.616Z</updated>
    
    <content type="html"><![CDATA[<p>回顾元素获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function $$(selector, context) &#123;</span><br><span class="line">  context = context || document;</span><br><span class="line">  var elements = context.querySelectorAll(selector);</span><br><span class="line">  return Array.prototype.slice.call(elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11.20 总结：</p><p>浏览器新特性总么办，加前缀是个失败的尝试。<br>可以通过工具加前缀。不过新特性的使用任重而道远。<br>web 标准是浏览器相关厂商，以及委员会的人共同探讨维护的。</p><p>一、CSS 编写注意技巧：</p><ol><li>减少重复的代码，<br>注意 style 之间的依赖关系，如 em，rem，字体和行高等。具体如何计算相互依赖关系，需要根据实际情况。<br>代码量少，和代码容易维护不是一个概念。<br>currentcolor<br>inherit</li><li>相信眼睛而不紧紧关注数字。<br>比如 垂直居中看着并不居中，圆形看着小，padding 上下左右不一致。</li><li>响应式布局 rwd。一直说响应式布局，但是 media query 不能是最好的解决方法，只能是最后的解决方法。<br>每个媒体查询都会增加成本。每次修改 css 的时候都可能改一遍，复杂性高，经不起折腾。表现的是断点式的表现<br>可以先从减少代码重复来入手。<br>写相对大小 依赖关系。宽度不写具体的 px，用百分比的形式，或者和视口相关的表示如 vh。善用 max-width，min-width。替换元素 img，iframe，vedio 等也要设置 max-width： 100%；<br>推荐弹性布局，或者 inine-block。<br>背景图片要完整地平铺，background-size:cover</li><li>合理使用简写。对于可展开的属性。如，border，background，要贯彻减少代码重复的原则，合理使用简写或者展开。</li></ol><p>例子： background: url(tr.png) no-repeat top right / 2em 2em, url(br.png) no-repeat bottom right / 2em 2em,<br>url(bl.png) no-repeat bottom left / 2em 2em;<br>其中， / 是为了避免歧义。</p><ol start="5"><li><p>是否使用预处理器，如 less，sass 等。<br>建议在项目开始用 css，无法维护时用预处理器。因为要编译就需要时间，文件体积也会变大，还会有自身的 bug，学习成本。<br>如： 原生高级的例子。<br>ul { –accent-color: purple; }<br>ol { –accent-color: rebeccapurple; } li { background: var(–accent-color); }</p><p>11.21 总结：<br>背景与边框<br>rgba，hsla 0 红 120 绿 240 蓝 h 色调 s 饱和度 l 亮度 a 透明度</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;回顾元素获取&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>原型回顾</title>
    <link href="https://wangyx233.github.io/2019/08/21/%E5%8E%9F%E5%9E%8B%E5%9B%9E%E9%A1%BE/"/>
    <id>https://wangyx233.github.io/2019/08/21/原型回顾/</id>
    <published>2019-08-21T11:43:55.178Z</published>
    <updated>2019-08-21T11:46:51.709Z</updated>
    
    <content type="html"><![CDATA[<p>快来快来看一看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    Foo.a = function() &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;</span><br><span class="line">    this.a = function() &#123;</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.a = function() &#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;</span><br><span class="line">Foo.a = function() &#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">&#125;</span><br><span class="line">Foo.a();</span><br><span class="line">let obj = new Foo();</span><br><span class="line">obj.a();</span><br><span class="line">Foo.a();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;快来快来看一看&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS基础回顾</title>
    <link href="https://wangyx233.github.io/2019/08/13/%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/"/>
    <id>https://wangyx233.github.io/2019/08/13/基础回顾/</id>
    <published>2019-08-13T02:10:39.589Z</published>
    <updated>2019-08-15T06:26:50.474Z</updated>
    
    <content type="html"><![CDATA[<h5 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h5><p>加上ES6新加的Symbol，共7种，分别为 String， Number， Boolean， Object， Undefined， Null。<br>分为基本数据类型(6)和Object。<br>对于基本数据类型，通过字面量的方式声明，类型依旧是字面量，只有在使用的时候才会转换为对应的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typeof()</span><br><span class="line">  特别：</span><br><span class="line">  函数-&gt;function,</span><br><span class="line">  null-&gt;object。历史原因对象以000开头，而null恰好为全零</span><br><span class="line">通过Object.prototype.toString.call()可判断准确的类型[object Type]</span><br></pre></td></tr></table></figure><p>PS: Symbol类型(唯一的值)<br>通过 Symbol()定义，定义后的值不相等，System.prototype.description 为定义时Symbol(‘xxx’)的标识。<br>使用场景：作为对象的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let sym = Symbol();</span><br><span class="line">let a = &#123;&#125;;</span><br><span class="line">a[sym] = &apos;symbol&apos;;</span><br><span class="line">a = &#123;</span><br><span class="line">  [sym]: &apos;symbol&apos;</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(a, sym, &#123;value: &apos;symbol&apos;&#125;)</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>不能用.运算符，.运算符会直接作为字符串取值。</li><li>Symbol作为属性名，不会出现在for…in, for…of中，也不会出现在Object.keys(), Object.getOwnPropertyNames()、JSON.stringify()里。</li><li>但也不是私有属性，Object.getOwnPropertySymbols，可以获取指定对象的所有 Symbol 属性名。</li><li>新的API:Reflect.ownKeys可以返回所有类型的键名，包括常规键名和 Symbol 键名。</li><li>Symbol.for(description)若没有则会创建一个，若存在则共用一个symbol值。 Symbol.keyFor(sym)返回一个已登记即Symbol.for的 Symbol类型值的key</li><li>其他方法可在需要是再查找。</li></ol><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>转Boolean类型。在条件判断时，除了 undefined， null， false， NaN， ‘’， 0， -0，其他所有值都转为 true，包括所有对象<br>对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。<br>注：<br>‘a’ + + ‘b’ – ‘aNaN’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x==y 比较</span><br><span class="line">undefined == null  // true</span><br><span class="line">[] == true // false</span><br><span class="line">[] == ![] // true [].toString() -&gt; &apos;&apos;，!取反运算符的优先级会高于==， ![] -》 false</span><br></pre></td></tr></table></figure><ol><li>undefined == null，结果是true。且它俩与所有其他值比较的结果都是false。</li><li>String == Boolean，需要两个操作数同时转为Number。</li><li>String/Boolean == Number，需要String/Boolean转为Number。</li><li>Object == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法)。</li></ol><h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;内置类型&quot;&gt;&lt;a href=&quot;#内置类型&quot; class=&quot;headerlink&quot; title=&quot;内置类型&quot;&gt;&lt;/a&gt;内置类型&lt;/h5&gt;&lt;p&gt;加上ES6新加的Symbol，共7种，分别为 String， Number， Boolean， Object， Undefi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://wangyx233.github.io/2019/07/22/%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97/"/>
    <id>https://wangyx233.github.io/2019/07/22/链表队列/</id>
    <published>2019-07-22T08:05:17.090Z</published>
    <updated>2020-05-15T07:09:51.492Z</updated>
    
    <content type="html"><![CDATA[<p>what?<br>链表是一种递归的数据结构，它或者为空，或者为一个指向结点的引用。该结点含有一个泛型元素和一个指向另一个链表的引用(next)。<br>其中，结点是一种含有任何类型数据的抽象实体。<br>链表表示的是一列元素。<br>在追踪链表或其他链式结构代码的时候，可用可视化的方式表示：</p><ol><li>用长方形表示对象</li><li>将实例变量的值写在长方形中</li><li>用指向被引用对象的箭头表示引用关系，链接<br>实现任意插入和删除操作的标准解决方案是双向链表，其中每个结点都含有两个链接(pervious, next)，分别指向不同的方向。</li></ol><p>特点：</p><ol><li>可以处理任意类型的数据</li><li>所需的空间和集合的大小成正比</li><li>操作的所需要的时间总是和集合的大小无关</li></ol><p>补充：</p><ol><li>背包(Bag)是一种不支持从中删除元素的集合数据类型，目的就是收集元素并且迭代遍历收集到的元素，迭代的顺序不确定且元素的处理顺序不重要，可以用栈也可以用队列。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Bag() &#123;&#125;</span><br><span class="line">  add(item)</span><br><span class="line">  isEmpty()</span><br><span class="line">  size()</span><br></pre></td></tr></table></figure><ol start="2"><li>先进先出队列 FIFO</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Queue() &#123;&#125;</span><br><span class="line">  enqueue(item) // 添加一个元素</span><br><span class="line">  dequeue() // 删除最近添加的元素</span><br><span class="line">  isEmpty()</span><br><span class="line">  size()</span><br></pre></td></tr></table></figure><ol start="3"><li>下压栈 LIFO</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Stack() &#123;&#125;</span><br><span class="line">  push(item)</span><br><span class="line">  pop()</span><br><span class="line">  isEmpty()</span><br><span class="line">  size()</span><br><span class="line">例如表达式的求值：遇到左括号忽略，操作数押入操作数的栈里，运算符押入运算符的栈里，遇到右括号运算符栈和操作数栈pop计算得到值，再押入栈中。</span><br><span class="line">如：(1 + ((2 + 3) * (4 * 5)))</span><br></pre></td></tr></table></figure><ol start="4"><li>在一些语言中，数组的长度一经定义就不可改变，并且数组的删除和添加操作需要对元素进行平移会很繁琐。JS 中数组和其他的不同，它是通过对象实现的，操作方便，但是效率可能较其他语言有所不足。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Node(elem) &#123;</span><br><span class="line">  this.elem = elem;</span><br><span class="line">  this.next = null;</span><br><span class="line">  // this.prvious = null;</span><br><span class="line">&#125;</span><br><span class="line">// 查找，插入，删除结点</span><br></pre></td></tr></table></figure><h6 id="跳表-Skip-List"><a href="#跳表-Skip-List" class="headerlink" title="跳表 Skip List"></a>跳表 Skip List</h6><p>1989 前后出现的，适用于有序元素的情况。对标的是二分查找和平衡树(二叉搜索树中的平衡树 AVL Tree)。跳表是一种插入，删除，搜索复杂度都是 logn 的数据结构。如：redis，levelDB<br>一维的数据结构要加速，一般可以升维变成二维的数据结构。空间换时间<br>LRU 缓存</p><p>自己想个 5-10min 看有没有思路，有思路就写了，没思路就直接看题解，学会了。再自己写呦</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;what?&lt;br&gt;链表是一种递归的数据结构，它或者为空，或者为一个指向结点的引用。该结点含有一个泛型元素和一个指向另一个链表的引用(next)。&lt;br&gt;其中，结点是一种含有任何类型数据的抽象实体。&lt;br&gt;链表表示的是一列元素。&lt;br&gt;在追踪链表或其他链式结构代码的时候，可用
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解promise</title>
    <link href="https://wangyx233.github.io/2019/01/16/%E7%90%86%E8%A7%A3promise/"/>
    <id>https://wangyx233.github.io/2019/01/16/理解promise/</id>
    <published>2019-01-15T16:41:34.498Z</published>
    <updated>2019-07-18T11:44:56.858Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么"><a href="#为什么" class="headerlink" title="为什么?"></a>为什么?</h4><p>避免回调地狱<br>有什么问题呢？<br>代码臃肿，可读性差，耦合性差，容易产生bug，不容易维护。不容易复用。在回调里面处理问题。<br>js特点-&gt;异步，主要是靠回调函数实现的。<br>比如，nodejs的特点是高并发和非阻塞，主要靠异步来实现。<br>js是事件注册机制的。<br>函数的执行是进栈和出栈这样的，所以普通的回调函数，try catch是没有作用的。</p><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><p>用于异步计算，用于即将发生的事情，或者不会发生的事情。<br>一个Promise的状态有resolved/rejected/pending/settled<br>new Promise 返回一个promise对象，参数是一个执行函数。执行函数有两个参数，resolve，reject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  // 异步处理</span><br><span class="line">  处理结束后执行resolve , reject</span><br><span class="line">&#125;)</span><br><span class="line">.then() //成功失败的回调，注意：then方法是异步执行的</span><br><span class="line">.catch() //在最外层捕获异常。</span><br><span class="line"></span><br><span class="line">promise.catch(onRejected)</span><br><span class="line">相当于</span><br><span class="line">promise.then(null, onRrejected);</span><br></pre></td></tr></table></figure><p>promise的三种状态:<br>pending 初始化<br>fulfilled 执行成功，调用resolve<br>rejected 失败，调用reject<br>注意promsie状态 只能由 pending =&gt; fulfilled/rejected, 一旦修改就不能再变</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么&quot;&gt;&lt;a href=&quot;#为什么&quot; class=&quot;headerlink&quot; title=&quot;为什么?&quot;&gt;&lt;/a&gt;为什么?&lt;/h4&gt;&lt;p&gt;避免回调地狱&lt;br&gt;有什么问题呢？&lt;br&gt;代码臃肿，可读性差，耦合性差，容易产生bug，不容易维护。不容易复用。在回调里面处理问
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack学习</title>
    <link href="https://wangyx233.github.io/2018/06/15/webpack%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wangyx233.github.io/2018/06/15/webpack学习/</id>
    <published>2018-06-15T08:34:01.696Z</published>
    <updated>2019-02-14T02:49:53.691Z</updated>
    
    <content type="html"><![CDATA[<ol><li>postcss 配置，post.config.js，同时webpack.config.js</li><li>mini-css-extract-plugin 与style-loader不共存</li><li>注意路径和文件名，仔细，认真</li><li>ico图片引入，没什么区别？</li><li>可自动设置dist文件夹下的文件，生成文件的目录你来掌握。</li><li>注意图片引入的路径,使用file-loader，url-loader引入的图片需要配合require使用，才能打包。url可以指定图片大小转换成base64等。<br>若不用require，直接src，需要把图片copy到打包后的文件。</li><li>react-hot-loader 与webpack 自带的hot不相互兼容。只能用一个。</li><li>webpack 的publicpath 定义的是服务在哪个文件下启动的，content可以定义文件的目录。</li><li>静态文件可生成hash模式，避免缓存。</li><li>babel也需要相应的配置。配合babel-import-plugin可以进行ui库的部分引入。还要注意选择babel的stage</li><li>react route4 webpack 服务器，用BrowserRouter,historyApiFallback: true</li></ol><p>gulp 与 webpack的区别<br>gulp 是任务流的，和task有关。<br>webpack 的核心是根据模块构建项目。<br>Webpack 的核心就是模块化地组织，模块化地依赖，然后模块化地打包。相对来上，场景局限在前端模块化打包上；虽然用 gulp + 插件的方式也能实现，但目前看 Webpack 在依赖的模块化构建上是无人能够替代的。<br>gulp 版本号。<br>可以在打包的时候，打入不同的文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;postcss 配置，post.config.js，同时webpack.config.js&lt;/li&gt;
&lt;li&gt;mini-css-extract-plugin 与style-loader不共存&lt;/li&gt;
&lt;li&gt;注意路径和文件名，仔细，认真&lt;/li&gt;
&lt;li&gt;ic
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Echarts3.5.0以上世界地图nameMap变更</title>
    <link href="https://wangyx233.github.io/2017/06/27/Echarts3.5.0%E4%BB%A5%E4%B8%8A%E4%B8%96%E7%95%8C%E5%9C%B0%E5%9B%BEnameMap%E4%BF%AE%E6%94%B9/"/>
    <id>https://wangyx233.github.io/2017/06/27/Echarts3.5.0以上世界地图nameMap修改/</id>
    <published>2017-06-27T09:23:11.000Z</published>
    <updated>2017-06-27T09:29:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天发现使用Echarts，nameMap渲染的世界地图，没有显示美国的数据，美国的区域显示的为United States。经过查找发现，Echarts应该是在3.5.0版本的时候，对world.js的一些国家名称进行了变更，从而导致用官网实例提供的nameMap,无法匹配到国家，进而无法显示。<br>大致看了一下地图，修改后对应的国家信息为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var nameMap =&#123;</span><br><span class="line">  &apos;Central African Rep.&apos;:&apos;中非共和国&apos;,</span><br><span class="line">  &apos;Dem. Rep. Congo&apos;:&apos;刚果民主共和国&apos;,</span><br><span class="line">  &apos;Lao PDR&apos;:&apos;老挝&apos;,</span><br><span class="line">  &apos;W. Sahara&apos;:&apos;西撒哈拉&apos;,</span><br><span class="line">  &apos;Tanzania&apos;:&apos;坦桑尼亚联合共和国&apos;,</span><br><span class="line">  &apos;United States&apos;:&apos;美国&apos;,</span><br><span class="line">  &apos;Korea&apos;: &apos;韩国&apos;,</span><br><span class="line">  &apos;Dem. Rep. Korea&apos;: &apos;朝鲜&apos;,</span><br><span class="line">  &apos;Congo&apos;: &apos;刚果共和国&apos;,</span><br><span class="line">  &apos;Solomon Is.&apos;: &apos;所罗门群岛&apos;,</span><br><span class="line">  &apos;Dominican Rep.&apos;:&apos;多明尼加共和国&apos;,</span><br><span class="line">  &apos;S. Sudan&apos;: &apos;南苏丹&apos; ,</span><br><span class="line">  &quot;Côte d&apos;Ivoire&quot;: &apos;科特迪瓦&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天发现使用Echarts，nameMap渲染的世界地图，没有显示美国的数据，美国的区域显示的为United States。经过查找发现，Echarts应该是在3.5.0版本的时候，对world.js的一些国家名称进行了变更，从而导致用官网实例提供的nameMap,无法匹配
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一些设计知识~</title>
    <link href="https://wangyx233.github.io/2017/06/21/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6/"/>
    <id>https://wangyx233.github.io/2017/06/21/写给大家看的设计书/</id>
    <published>2017-06-21T03:37:56.000Z</published>
    <updated>2017-06-26T10:56:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近要看的书好多，全都在排排坐，先挑了一本设计类的书籍《写给大家看的设计书》</p><h3 id="设计的四大原则"><a href="#设计的四大原则" class="headerlink" title="设计的四大原则"></a>设计的四大原则</h3><h6 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h6><p>对比是为页面增加视觉效果的最有效的途径,也是在不同元素之间建立一种有组织的层次结构最有效方法。要记住一个重要规则:要想实现有效的对比,对比就必须 强烈。千万不要畏畏缩缩。<br>字体的对比，颜色的对比，一定要保持强烈，差别不大的对比没有效果。<br>对比的根本目的有两个,这两个目的相辅相成,无法分开。一个目的是增强页面的效果,如果一个页面看起来很有意思,往往更有可读性。另一个目的是有助于信息的组织。读者应当能立即了解信息以何种方式组织,以及从一项到另一项的逻辑流程。对比元素不能让读者混淆,也不能错误地强调重点(即本不该是重点的元素)。</p><h6 id="重复-一致性"><a href="#重复-一致性" class="headerlink" title="重复-一致性"></a>重复-一致性</h6><p>设计的某些方面需要在整个作品中重复。控制读者视线，设计中视觉元素的重复可以将作品中的各部分连在一起,从而统一并增强整个作品。<br>重复的目的就是统一,并增强视觉效果。不要低估页面视觉效果的威力,如果一个作品看起来很有趣,它往往也更易于阅读。<br>要避免太多地重复一个元素,重复太多会让人讨厌。要注意对比的价值<br>可以通过字体选择、线宽、颜色、形状、大小、空间等来增加对比。 增加对比很容易,途径有很多,这可能是增加视觉效果最有意思也最让人满意的方 法了。重要的是:对比一定要强烈!</p><a id="more"></a><h6 id="对齐-统一性"><a href="#对齐-统一性" class="headerlink" title="对齐-统一性"></a>对齐-统一性</h6><p>任何元素都不能在页面上随意安放。每一项都应当与页面上的 某个内容存在某种视觉联系。<br>对齐方式的选择，左右对齐比居中对齐多了一条无形的对齐基准，效果更好。<br>不是不推荐居中，而是注意居中对齐的应用场景，让居中的效果明显一些，生动一些，比如调整位置，改变字体等。<br>在设计的最初，最好坚持，只使用一种对齐方式！<br>页面的元素不要所以摆放，确保互相有一种对齐方式，人的视觉喜欢有序的东西，并且利于信息的表达。</p><blockquote><p>绝对不要在左对齐的正文或缩进的文本上方将标题居中。如果文本没有明确的左边界和右边界,就无法区分标题是否确实居中,看起来它只是悬挂着而已。</p></blockquote><p>找到一条明确的对齐线，并且以此为标准；如果有照片或图片,让它们和一边或基线对齐，在打破规 则之前必须清楚规则是什么。<br>对齐的根本目的是使页面统一而且有条理。<br>注意：<br>要避免在页面上混合使用多种文本对齐方式(也就是说,不要将某些文本居中,而 另外一些文本右对齐)。<br>另外,要着力避免居中对齐,除非你有意识地想要创建一种比较正式、稳重(通常也更乏味)的表示。并不是完全杜绝使用居中对齐,有时可以有意地选择这种对齐方式,但是不要把它作为默认选择。</p><h6 id="亲密性–有组织性"><a href="#亲密性–有组织性" class="headerlink" title="亲密性–有组织性"></a>亲密性–有组织性</h6><p>将相关的项组织在一起，在一个页面上,物理位置的接近就意味着存在关联。如果多个项相互之间有很近的亲密性,它们就会成为一个视觉单元,而不是多个孤<br>立的元素。<br>布局的时候一定要注意明确元素与其所属元素是否在一起，留意无关元素。<br>善用空白，注意各个元素之间的关系，关注空间。<br>注意：<br>1、避免一个页面上有太多孤立的元素。 不要在元素之间留出同样大小的空白,除非各组同属于一个子集。<br>2、标题、子标题、图表标题、图片能否归入其相关材料?在这个问题上一定要非常清 楚(哪怕只有一点含糊都要尽量避免)。在有很近亲密性的元素之间建立关系。<br>3、不同属一组的元素之间不要建立关系!如果元素彼此无关,要把它们分开。 不要仅仅因为有空白就把元素放在角落或中央。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要看的书好多，全都在排排坐，先挑了一本设计类的书籍《写给大家看的设计书》&lt;/p&gt;
&lt;h3 id=&quot;设计的四大原则&quot;&gt;&lt;a href=&quot;#设计的四大原则&quot; class=&quot;headerlink&quot; title=&quot;设计的四大原则&quot;&gt;&lt;/a&gt;设计的四大原则&lt;/h3&gt;&lt;h6 id=&quot;对比&quot;&gt;&lt;a href=&quot;#对比&quot; class=&quot;headerlink&quot; title=&quot;对比&quot;&gt;&lt;/a&gt;对比&lt;/h6&gt;&lt;p&gt;对比是为页面增加视觉效果的最有效的途径,也是在不同元素之间建立一种有组织的层次结构最有效方法。要记住一个重要规则:要想实现有效的对比,对比就必须 强烈。千万不要畏畏缩缩。&lt;br&gt;字体的对比，颜色的对比，一定要保持强烈，差别不大的对比没有效果。&lt;br&gt;对比的根本目的有两个,这两个目的相辅相成,无法分开。一个目的是增强页面的效果,如果一个页面看起来很有意思,往往更有可读性。另一个目的是有助于信息的组织。读者应当能立即了解信息以何种方式组织,以及从一项到另一项的逻辑流程。对比元素不能让读者混淆,也不能错误地强调重点(即本不该是重点的元素)。&lt;/p&gt;
&lt;h6 id=&quot;重复-一致性&quot;&gt;&lt;a href=&quot;#重复-一致性&quot; class=&quot;headerlink&quot; title=&quot;重复-一致性&quot;&gt;&lt;/a&gt;重复-一致性&lt;/h6&gt;&lt;p&gt;设计的某些方面需要在整个作品中重复。控制读者视线，设计中视觉元素的重复可以将作品中的各部分连在一起,从而统一并增强整个作品。&lt;br&gt;重复的目的就是统一,并增强视觉效果。不要低估页面视觉效果的威力,如果一个作品看起来很有趣,它往往也更易于阅读。&lt;br&gt;要避免太多地重复一个元素,重复太多会让人讨厌。要注意对比的价值&lt;br&gt;可以通过字体选择、线宽、颜色、形状、大小、空间等来增加对比。 增加对比很容易,途径有很多,这可能是增加视觉效果最有意思也最让人满意的方 法了。重要的是:对比一定要强烈!&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>D3.js学习</title>
    <link href="https://wangyx233.github.io/2017/06/21/D3.js%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wangyx233.github.io/2017/06/21/D3.js学习/</id>
    <published>2017-06-21T02:47:53.000Z</published>
    <updated>2017-06-21T03:37:59.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>D3.js实现数据和元素的绑定<br>对于DOM结点的选择，d3.select(‘tag’)选择第一个元素,d3.selectAll(‘tag’)选择所有的元素。<br>对于数据的绑定，tag.datum()将一个数据绑定到元素上，tag.data()将数组内元素分别绑定各元素。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var body = d3.select(&apos;body&apos;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;D3.js实现数据和元素的绑定&lt;br&gt;对于DOM结点的选择，d3.select(‘tag’)选择第一个元素,d3.selectAll(‘tag’)选择所有的元素。&lt;br&gt;对于数据的绑定，tag.datum()将一个数据绑定到元素上，tag.data()将数组内元
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Canvas学习</title>
    <link href="https://wangyx233.github.io/2017/06/12/Canvas%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wangyx233.github.io/2017/06/12/Canvas学习/</id>
    <published>2017-06-12T05:55:20.000Z</published>
    <updated>2018-05-21T12:26:01.640Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;canvas&gt;标签定义一个矩形框画布，默认没有边框和内容,默认大小为300像素×150像素(wxh)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;</span><br><span class="line">style=&quot;border:1px solid #000000;&quot;&gt;</span><br><span class="line">若浏览器不支持canvas标签，将显示这些文字</span><br><span class="line">&lt;/canvas&gt;</span><br></pre></td></tr></table></figure><p>在Js文件中绘制Canvas元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var c=document.getElementById(&quot;myCanvas&quot;);</span><br><span class="line">if(c.getContext(&apos;2d&apos;))&#123; //支持性检查</span><br><span class="line">  var ctx=c.getContext(&quot;2d&quot;);//获取渲染上下文，参数为上下文的格式</span><br><span class="line">  ctx.fillStyle=&quot;#FF0000&quot;; //填充样式，可为颜色、图案、渐变等。</span><br><span class="line">  ctx.fillRect(0,0,150,75);//矩形的填充方法fillRect(x,y,width,height)，矩形左上角坐标为(0,0)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">  // canvas-unsupported code here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h6><p>canvas支持一种原生的图形绘制-矩形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fillRect(x, y, width, height) //绘制一个填充的矩形</span><br><span class="line">strokeRect(x, y, width, height) //绘制一个矩形的边框</span><br><span class="line">clearRect(x, y, width, height) //清除指定矩形区域，让清除部分完全透明</span><br><span class="line">rect(x, y, width, height) //绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。</span><br></pre></td></tr></table></figure><a id="more"></a><h6 id="画路径"><a href="#画路径" class="headerlink" title="画路径"></a>画路径</h6><p>定义开始坐标 moveTo(x,y)<br>定义结束坐标 lineTo(x,y)<br>绘制路径轮廓 stroke()<br>beginPath() 新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。<br>closePath() 闭合路径之后图形绘制命令又重新指向到上下文中。<br>.fill() 进行图形的填充，会进行路径的自动闭合<br>.stroke() 绘制轮廓，需要配合closePath进行路径的闭合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(75,50);</span><br><span class="line">ctx.lineTo(100,75);</span><br><span class="line">ctx.lineTo(100,25);</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure><h6 id="画圆弧"><a href="#画圆弧" class="headerlink" title="画圆弧"></a>画圆弧</h6><p>用arc()方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arc(x, y, radius, startAngle, endAngle, anticlockwise)</span><br><span class="line">画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。</span><br><span class="line">注意：arc()函数中的角度单位是弧度，不是度数。角度与弧度的js表达式:radians=(Math.PI/180)*degrees</span><br></pre></td></tr></table></figure><h6 id="画贝塞尔曲线"><a href="#画贝塞尔曲线" class="headerlink" title="画贝塞尔曲线"></a>画贝塞尔曲线</h6><p>quadraticCurveTo(cp1x, cp1y, x, y)<br>绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。<br>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)<br>绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 一颗心</span><br><span class="line">var heart = document.getElementById(&apos;heart&apos;);</span><br><span class="line">var heartx = heart.getContext(&apos;2d&apos;);</span><br><span class="line">heartx.beginPath();</span><br><span class="line">heartx.moveTo(75,40);</span><br><span class="line">heartx.bezierCurveTo(75,37,70,25,50,25);</span><br><span class="line">heartx.bezierCurveTo(20,25,20,62.5,20,62.5);</span><br><span class="line">heartx.bezierCurveTo(20,80,40,102,75,120);</span><br><span class="line">heartx.bezierCurveTo(110,102,130,80,130,62.5);</span><br><span class="line">heartx.bezierCurveTo(130,62.5,130,25,100,25);</span><br><span class="line">heartx.bezierCurveTo(85,25,75,37,75,40);</span><br><span class="line">heartx.fill();</span><br></pre></td></tr></table></figure><p>save()<br>restore()<br>rotate() 中心在圆点，<br>translate重新映射画布上(0,0)的位置</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;lt;canvas&amp;gt;标签定义一个矩形框画布，默认没有边框和内容,默认大小为300像素×150像素(wxh)。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;canvas id=&amp;quot;myCanvas&amp;quot; width=&amp;quot;200&amp;quot; height=&amp;quot;100&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;style=&amp;quot;border:1px solid #000000;&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;若浏览器不支持canvas标签，将显示这些文字&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/canvas&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在Js文件中绘制Canvas元素。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var c=document.getElementById(&amp;quot;myCanvas&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if(c.getContext(&amp;apos;2d&amp;apos;))&amp;#123; //支持性检查&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var ctx=c.getContext(&amp;quot;2d&amp;quot;);//获取渲染上下文，参数为上下文的格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ctx.fillStyle=&amp;quot;#FF0000&amp;quot;; //填充样式，可为颜色、图案、渐变等。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ctx.fillRect(0,0,150,75);//矩形的填充方法fillRect(x,y,width,height)，矩形左上角坐标为(0,0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  // canvas-unsupported code here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h6 id=&quot;画矩形&quot;&gt;&lt;a href=&quot;#画矩形&quot; class=&quot;headerlink&quot; title=&quot;画矩形&quot;&gt;&lt;/a&gt;画矩形&lt;/h6&gt;&lt;p&gt;canvas支持一种原生的图形绘制-矩形&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fillRect(x, y, width, height) //绘制一个填充的矩形&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;strokeRect(x, y, width, height) //绘制一个矩形的边框&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;clearRect(x, y, width, height) //清除指定矩形区域，让清除部分完全透明&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rect(x, y, width, height) //绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Three.js学习笔记</title>
    <link href="https://wangyx233.github.io/2017/06/05/three.js%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <id>https://wangyx233.github.io/2017/06/05/three.js学习指南/</id>
    <published>2017-06-05T05:59:18.000Z</published>
    <updated>2017-06-20T07:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>一切都建立在引入Three.js后，得到的全局变量THREE。<br>对于页面中，存放渲染效果的元素，可以是普通的div，也可以是canvas。<br>对于div，渲染时添加节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var renderer = new THREE.WebGLRenderer();</span><br><span class="line">renderer.setSize(400, 300);</span><br><span class="line">document.getElementById(&apos;test&apos;).appendChild(renderer.domElement);</span><br><span class="line">renderer.setClearColor(0x000000);//清除原本所在页面颜色，并设置</span><br></pre></td></tr></table></figure><p>而对于定义的canvas标签，其定义及渲染：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=&quot;mainCanvas&quot; width=&quot;400px&quot; height=&quot;300px&quot; &gt;&lt;/canvas&gt;</span><br><span class="line">var renderer = new THREE.WebGLRenderer(&#123;</span><br><span class="line">                    canvas: document.getElementById(&apos;mainCanvas&apos;)&#125;);</span><br></pre></td></tr></table></figure><p>基本概念</p><ol><li>主要分为三大部分，场景（scene）、照相机（camera）、渲染器（renderer）</li><li>首先定义容器渲染所在的DOM包括宽高、颜色等，利用照相机(投影方式)把作为容器的场景渲染到页面上。</li><li>声明渲染器对象renderer，canvas对象的获取方法为renderer.domElement，相机也需要加到场景中去</li></ol><a id="more"></a><h5 id="3D世界"><a href="#3D世界" class="headerlink" title="3D世界"></a>3D世界</h5><p>帧数：图形处理器每秒钟能够刷新几次，通常用fps（Frames Per Second）来表示。</p><h6 id="最开始可以选择引入stat-js记录帧数"><a href="#最开始可以选择引入stat-js记录帧数" class="headerlink" title="最开始可以选择引入stat.js记录帧数"></a>最开始可以选择引入stat.js记录帧数</h6><p>1、new 一个stats对象，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stats = new Stats();</span><br></pre></td></tr></table></figure><p>2、将这个对象加入到html网页中去，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stats.domElement.style.position = &apos;absolute&apos;;</span><br><span class="line">stats.domElement.style.left = &apos;0px&apos;;</span><br><span class="line">stats.domElement.style.top = &apos;0px&apos;;</span><br><span class="line">document.body.appendChild(stat.domElement);</span><br></pre></td></tr></table></figure><p>3、调用函数来统计时间和帧数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stats.update();</span><br><span class="line">或者</span><br><span class="line">stats.begin();</span><br><span class="line">funtion()&#123;&#125;;</span><br><span class="line">stats.end();</span><br></pre></td></tr></table></figure><p>tween.js？</p><h6 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h6><p>相机两种，正交投影相机和透视投影相机，前者是远近的比例相同，而后者具有近大远小的特点。<br>正交投影相机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">THREE.OrthographicCamera(left, right, top, bottom, near, far)</span><br><span class="line">其中，near，far代表相机的深度，为正值。在视景体（Frustum）中的物体才会渲染到页面，相机截取的是对称的</span><br></pre></td></tr></table></figure><p>透视投影相机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">THREE.PerspectiveCamera( fov, aspect, near, far )</span><br><span class="line">fov 视角：视野范围的角度；aspect：横纵比 Width/Height; near:近平面的距离； far远平面的距离</span><br></pre></td></tr></table></figure><p>相机有两个重要的参数</p><blockquote><p>camera.position：控制相机在整个3D环境中的位置（取值为3维坐标对象-THREE.Vector3(x,y,z)）<br>camera.lookAt：控制相机的焦点位置，决定相机的朝向（取值为3维坐标对象-THREE.Vector3(x,y,z)）</p></blockquote><p>应用:<br>设置相机的焦点为原点或者物体的位置坐标，camera.lookAt(new THREE.Vector3(0,0,0))，改变相机的位置camera.position，可以实现围绕物体360度观看物体的效果。<br>相机lookAt与position的设置可以实现以不同视角观察物体的效果。</p><h6 id="要有光！"><a href="#要有光！" class="headerlink" title="要有光！"></a>要有光！</h6><p>光用THREE.Light(hex)，hex16进制的颜色表示；材质在很大程度上，是由光决定的。</p><ul><li>环境光<br>环境光没有明确的光源位置，在各处的亮度也是一致的，设定是只需指定光的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.AmbientLight(hex)</span><br></pre></td></tr></table></figure><p>环境光并不影响物体的color属性，而是ambient属性，默认值为0xffffff。所以，环境光一般设为白色或者灰色</p><ul><li>点光源<br>光源大小可以看做是一个点，照到不同物体上亮度是线性递减的。离光源越远，物体越暗。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">THREE.PointLight(hex, intensity, distance)</span><br><span class="line">其中，intensity是亮度，缺省值为1，表示100%亮度；distance是光源最远照射到的距离，缺省值为0。</span><br><span class="line">var light = new THREE.PointLight(0xffffff, 2, 100);</span><br><span class="line">light.position.set(0, 1.5, 2);</span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure><ul><li>平行光<br>对于任意平行的平面，平行光照射的亮度都是相同的，而与平面所在位置无关。而光源位置的设置异常关键。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">THREE.DirectionalLight(hex, intensity)</span><br><span class="line">light.position.set(2, 5, 3);</span><br></pre></td></tr></table></figure><p>光源的位置并不意味着光从(2, 5, 3)点发出，而是以矢量(-2, -5, -3)的方向照射到所有平面。因此，平面亮度与平面的位置无关，而只与平面的法向量相关。</p><ul><li>聚光灯<br>类似圆锥形的光线，类似现实中的聚光灯模型。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">THREE.SpotLight(hex, intensity, distance, angle, exponent)</span><br><span class="line">angle是聚光灯的张角，缺省值是Math.PI / 3，最大值是Math.PI / 2；exponent是光强在偏离target的衰减指数（target需要定义，缺省值为(0, 0, 0)），缺省值是10。</span><br><span class="line">light.position.set(x1, y1, z1);</span><br><span class="line">light.target.position.set(x2, y2, z2);</span><br></pre></td></tr></table></figure><p>target还可以指定为物体，实现真正的聚光灯效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1),</span><br><span class="line">                    new THREE.MeshLambertMaterial(&#123;color: 0x00ff00&#125;));</span><br><span class="line">var light = new THREE.SpotLight(0xffff00, 1, 100, Math.PI / 6, 25);</span><br><span class="line">light.target = cube;</span><br></pre></td></tr></table></figure><ul><li>阴影<br>Three.js中，能形成阴影的光源只有THREE.DirectionalLight与THREE.SpotLight；能表现阴影效果的材质只有THREE.LambertMaterial与THREE.PhongMaterial。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 初始化，渲染器渲染阴影</span><br><span class="line">renderer.shadowMapEnabled = true;</span><br><span class="line">2. 对于要产生阴影的物体调用</span><br><span class="line">xxx.castShadow = true;</span><br><span class="line">3. 接收阴影的物体</span><br><span class="line">xxx.receiveShadow = true;</span><br></pre></td></tr></table></figure><p>同时，需要设置光源的阴影属性<br>1、 聚光灯，需要设置shadowCameraNear、shadowCameraFar、shadowCameraFov<br>2、 平行光，需要设置shadowCameraNear、shadowCameraFar、shadowCameraLeft、shadowCameraRight、shadowCameraTop以及shadowCameraBottom六个值，相当于正交投影照相机的六个面。只有在这六个面围成的长方体内的物体才能产生阴影效果。<br>在调试阴影效果时，可以开启相机位置：light.shadowCameraVisible = true。<br>阴影的深浅可以通过shadowDarkness设置(0,1)，值越小，阴影颜色越小。<br>另一种实现阴影的方法是Shadow Mapping，即阴影通过贴图的方式贴上来。贴图大小可通过shadowMapWidth与shadowMapHeight来设置。</p><h6 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h6><p>场景中的物体，由几何形状(Geometry)和材质(Material)组成，设置其name属性可以通过scene.getObjectByName(name)获取该物体对象;</p><ul><li>几何形状<br>1、立方体</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">THREE.CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)</span><br><span class="line">其中，后三个参数为宽，高，深度的分段</span><br></pre></td></tr></table></figure><p>2、平面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.PlaneGeometry(width, height, widthSegments, heightSegments)</span><br></pre></td></tr></table></figure><p>3、球体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">THREE.SphereGeometry(radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength)</span><br><span class="line">其中，各参数分别为，半径，经度分割数，纬度分割数，经度开始弧度，经度跨越弧度，纬度开始弧度，纬度跨越弧度</span><br></pre></td></tr></table></figure><p>4、圆形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.CircleGeometry(radius, segments, thetaStart, thetaLength)</span><br></pre></td></tr></table></figure><p>5、圆柱体，圆台等参考<a href="http://www.ituring.com.cn/book/miniarticle/50172" target="_blank" rel="noopener">http://www.ituring.com.cn/book/miniarticle/50172</a></p><ul><li>材质<br>1、 BasicMaterial基本材质不受光照阴影等的影响。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">THREE.MeshBasicMaterial(&#123;</span><br><span class="line">  visible：是否可见，默认为true</span><br><span class="line">  side：渲染面片正面或是反面，默认为正面THREE.FrontSide，可设置为反面THREE.BackSide，或双面THREE.DoubleSide</span><br><span class="line">  wireframe：是否渲染线而非面，默认为false</span><br><span class="line">  color：十六进制RGB颜色，如红色表示为0xff0000</span><br><span class="line">  map：使用纹理贴图</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>2、 Lambert材质（MeshLambertMaterial）是符合Lambert光照模型的材质。只考虑漫反射而不考虑镜面反射的效果，因而对于金属、镜子等需要镜面反射效果的物体就不适应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: //散射光反射能力</span><br><span class="line">    ambient: //环境光反射</span><br><span class="line">    emissive: 0xff0000 //自发光</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3、 Phong材质（MeshPhongMaterial）是符合Phong光照模型的材质。和Lambert不同的是，Phong模型考虑了镜面反射的效果，因此对于金属、镜面的表现尤为适合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshPhongMaterial(&#123;</span><br><span class="line">    color:</span><br><span class="line">    ambient: //环境光反射</span><br><span class="line">    emissive: 0xff0000 //自发光</span><br><span class="line">    specular: 0xff0000 //镜面反射系数</span><br><span class="line">    shininess: 1000 //当shininess值越大时，高光的光斑越小，默认值为30。</span><br></pre></td></tr></table></figure><p>4、 法向材质可以将材质的颜色设置为其法向量的方向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshNormalMaterial()</span><br></pre></td></tr></table></figure><p>材质的颜色与照相机与该物体的角度相关<br>5、 材质纹理贴图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var texture = THREE.ImageUtils.loadTexture(&apos;../img/0.png&apos;);</span><br><span class="line">其中，THREE.ImageUtils.loadTexture现在由THREE.TextureLoader()代替</span><br><span class="line">var loader = new THREE.TextureLoader();</span><br><span class="line">var texture = loader.load(&apos;url&apos;, function() &#123;</span><br><span class="line">    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;</span><br><span class="line">    texture.repeat.set(8, 8);</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="场景中常见的物体"><a href="#场景中常见的物体" class="headerlink" title="场景中常见的物体"></a>场景中常见的物体</h6><p>点是基础，两个点组成一条线，不在一条直线上的三个点组成一个三角形面，这种模型成为Mesh模型.<br>一条线由点，材质，和颜色组成。<br>普通的点用THREE.Vector3定义放在THREE.Geometry对象vertices数组中，<br>材质由THREE.LineBasicMaterial定义，<br>线的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var line = new THREE.Line( geometry, material, THREE.LinePieces );</span><br></pre></td></tr></table></figure><p>最常见的物体–网格，除此之外还有线段（Line）、骨骼（Bone）、粒子系统（ParticleSystem）等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mesh(geometry, material)</span><br><span class="line">通过属性进行访问mesh.material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: 0xff0000</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>具有位置，缩放，和旋转三个属性。position、scale、rotation。它们都是THREE.Vector3实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mesh.position = new THREE.Vector3(1.5, -0.5, 0);</span><br><span class="line">mesh.position.set(1.5, -0.5, 0);</span><br><span class="line">mesh.position.z = 1;</span><br></pre></td></tr></table></figure><h6 id="当当当-动画"><a href="#当当当-动画" class="headerlink" title="当当当 动画"></a>当当当 动画</h6><p>场景动起来的方式，一是物体在坐标轴里移动，摄像机不动；一种是物体不动，camera移动，用requestAnimationFrame(render)进行渲染循环<br>1、用定时器setInterval方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id = setInterval(fun, time);</span><br><span class="line">clearInterval(id);</span><br><span class="line">帧数可以通过time控制，time = 1000ms/frame</span><br></pre></td></tr></table></figure><p>2、用requestAnimationFrame方法，h5的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var requestAnimationFrame = window.requestAnimationFrame</span><br><span class="line">        || window.mozRequestAnimationFrame</span><br><span class="line">        || window.webkitRequestAnimationFrame</span><br><span class="line">        || window.msRequestAnimationFrame;</span><br><span class="line">window.requestAnimationFrame = requestAnimationFrame;</span><br><span class="line">id = requestAnimationFrame(draw);</span><br></pre></td></tr></table></figure><h6 id="支持引入外部模型"><a href="#支持引入外部模型" class="headerlink" title="支持引入外部模型"></a>支持引入外部模型</h6><p>需要加载额外的辅助函数，地址参考：<a href="https://github.com/mrdoob/three.js/tree/master/examples/js/loaders" target="_blank" rel="noopener">https://github.com/mrdoob/three.js/tree/master/examples/js/loaders</a><br>1、 例如，导入.obj格式的模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var loader = new THREE.OBJLoader();</span><br><span class="line">loader.load(&apos;../lib/port.obj&apos;, function(obj) &#123;</span><br><span class="line">  //默认情况只有正面绘制，双面绘制</span><br><span class="line">    obj.traverse(function(child) &#123;</span><br><span class="line">        if (child instanceof THREE.Mesh) &#123;</span><br><span class="line">            child.material.side = THREE.DoubleSide;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    mesh = obj;</span><br><span class="line">    scene.add(obj);//添加到场景</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2、 对于引入模型的材质设置，有两种方式：</p><ul><li>在引入模型的回调函数中设置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj.traverse(function(child) &#123;</span><br><span class="line">        if (child instanceof THREE.Mesh) &#123;</span><br><span class="line">            child.material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">                color: 0xffff00,</span><br><span class="line">                side: THREE.DoubleSide</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>在模型软件中设置，并引用。例如，.obj的模型与.mtl的材质</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//引入js</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;MTLLoader.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;OBJMTLLoader.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">var loader = new THREE.OBJMTLLoader();</span><br><span class="line">loader.addEventListener(&apos;load&apos;, function(event) &#123;</span><br><span class="line">    var obj = event.content;</span><br><span class="line">    mesh = obj;</span><br><span class="line">    scene.add(obj);</span><br><span class="line">&#125;);</span><br><span class="line">loader.load(&apos;../lib/port.obj&apos;, &apos;../lib/port.mtl&apos;);</span><br></pre></td></tr></table></figure><h6 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h6><blockquote><p>FlyControls:飞行控制，用键盘和鼠标控制相机的移动和转动<br>OrbitControls::轨道控制器，模拟轨道中的卫星，绕某个对象旋转平移，用键盘和鼠标控制相机位置<br>PointerLockControls:指针锁定，鼠标离开画布依然能被捕捉到鼠标交互，主要用于游戏<br>TrackballControls：轨迹球控制器，通过键盘和鼠标控制前后左右平移和缩放场景<br>TransformControls:变换物体控制器，可以通过鼠标对物体的进行拖放等操作</p></blockquote><h6 id="不明觉厉着色器"><a href="#不明觉厉着色器" class="headerlink" title="不明觉厉着色器"></a>不明觉厉着色器</h6><p>WebGL基于OpenGL ES 2.0，着色器支持顶点着色器和片元着色器。<br>再战！<br>最常发生的错误就是忘记float类型和int类型不会自动转换</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一切都建立在引入Three.js后，得到的全局变量THREE。&lt;br&gt;对于页面中，存放渲染效果的元素，可以是普通的div，也可以是canvas。&lt;br&gt;对于div，渲染时添加节点：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var renderer = new THREE.WebGLRenderer();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;renderer.setSize(400, 300);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;document.getElementById(&amp;apos;test&amp;apos;).appendChild(renderer.domElement);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;renderer.setClearColor(0x000000);//清除原本所在页面颜色，并设置&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;而对于定义的canvas标签，其定义及渲染：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;canvas id=&amp;quot;mainCanvas&amp;quot; width=&amp;quot;400px&amp;quot; height=&amp;quot;300px&amp;quot; &amp;gt;&amp;lt;/canvas&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var renderer = new THREE.WebGLRenderer(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    canvas: document.getElementById(&amp;apos;mainCanvas&amp;apos;)&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;基本概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主要分为三大部分，场景（scene）、照相机（camera）、渲染器（renderer）&lt;/li&gt;
&lt;li&gt;首先定义容器渲染所在的DOM包括宽高、颜色等，利用照相机(投影方式)把作为容器的场景渲染到页面上。&lt;/li&gt;
&lt;li&gt;声明渲染器对象renderer，canvas对象的获取方法为renderer.domElement，相机也需要加到场景中去&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Three.js" scheme="https://wangyx233.github.io/tags/Three-js/"/>
    
  </entry>
  
  <entry>
    <title>hexo部署github的问题</title>
    <link href="https://wangyx233.github.io/2017/04/11/hexo%E9%83%A8%E7%BD%B2github%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://wangyx233.github.io/2017/04/11/hexo部署github的问题/</id>
    <published>2017-04-11T12:03:27.000Z</published>
    <updated>2017-06-05T12:21:43.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="用hexo搭建博客，配置直接部署到github的方法："><a href="#用hexo搭建博客，配置直接部署到github的方法：" class="headerlink" title="用hexo搭建博客，配置直接部署到github的方法："></a>用hexo搭建博客，配置直接部署到github的方法：</h5><p>1.安装 hexo-deployer-git插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>2.在hexo根目录的_config.yml中进行deploy的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: [github repository url] //eg:git@github.com:xxx.git or https://github.com/xxx.git</span><br><span class="line">    branch: master //branch name</span><br><span class="line">    message: &quot;Blog updated: &#123;&#123; now（&apos;YYYY-MM-DD&apos;）&#125;&#125;&quot; //commit message</span><br><span class="line">Ps:注意缩进和空格</span><br></pre></td></tr></table></figure><p>3.通过hexo deploy（即hexo d）命令进行部署，在此之前需要进行hexo generate（即hexo g）编译。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo-deployer-git插件的作用是生成.deploy_git文件，</span><br><span class="line">并且把hexo g编译后的public中的文件复制到.deploy_git文件夹下，</span><br><span class="line">然后进行git操作，推到远端github仓库。</span><br></pre></td></tr></table></figure><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><a id="more"></a><p>1.在用hexo d进行第一次部署时，需要将从public拷贝到.deploy_git文件夹下的所有文件进行commit操作（hexo d部署只会更新静态的html文件）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd .deploy_git</span><br><span class="line">git add --all -f</span><br><span class="line">git commit -m &quot;message&quot;</span><br><span class="line">git push origin branch</span><br></pre></td></tr></table></figure><p>2.说道部署至github，那前提是配置好github的username和password啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;用hexo搭建博客，配置直接部署到github的方法：&quot;&gt;&lt;a href=&quot;#用hexo搭建博客，配置直接部署到github的方法：&quot; class=&quot;headerlink&quot; title=&quot;用hexo搭建博客，配置直接部署到github的方法：&quot;&gt;&lt;/a&gt;用hexo搭建博客，配置直接部署到github的方法：&lt;/h5&gt;&lt;p&gt;1.安装 hexo-deployer-git插件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-deployer-git --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;2.在hexo根目录的_config.yml中进行deploy的配置&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    type: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    repo: [github repository url] //eg:git@github.com:xxx.git or https://github.com/xxx.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    branch: master //branch name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    message: &amp;quot;Blog updated: &amp;#123;&amp;#123; now（&amp;apos;YYYY-MM-DD&amp;apos;）&amp;#125;&amp;#125;&amp;quot; //commit message&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ps:注意缩进和空格&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;3.通过hexo deploy（即hexo d）命令进行部署，在此之前需要进行hexo generate（即hexo g）编译。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo-deployer-git插件的作用是生成.deploy_git文件，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;并且把hexo g编译后的public中的文件复制到.deploy_git文件夹下，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;然后进行git操作，推到远端github仓库。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;注意：&quot;&gt;&lt;a href=&quot;#注意：&quot; class=&quot;headerlink&quot; title=&quot;注意：&quot;&gt;&lt;/a&gt;注意：&lt;/h3&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://wangyx233.github.io/tags/hexo/"/>
    
      <category term="github" scheme="https://wangyx233.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wangyx233.github.io/2017/04/11/hello-world/"/>
    <id>https://wangyx233.github.io/2017/04/11/hello-world/</id>
    <published>2017-04-11T06:06:25.000Z</published>
    <updated>2017-06-05T12:13:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><a id="more"></a><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
