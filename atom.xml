<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangyx233.github.io/"/>
  <updated>2022-04-07T01:58:48.814Z</updated>
  <id>https://wangyx233.github.io/</id>
  
  <author>
    <name>Yx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【React】React 18来辣</title>
    <link href="https://wangyx233.github.io/2022/04/07/%5BReact%5DReact18%E6%9D%A5%E5%95%A6/"/>
    <id>https://wangyx233.github.io/2022/04/07/[React]React18来啦/</id>
    <published>2022-04-07T01:58:48.813Z</published>
    <updated>2022-04-07T01:58:48.814Z</updated>
    
    <content type="html"><![CDATA[<p>铛铛铛，React18正式发布辣</p><blockquote><p>前置知识： Concurrent(并发)</p></blockquote><h3 id="Concurrent"><a href="#Concurrent" class="headerlink" title="Concurrent"></a>Concurrent</h3><blockquote><p>渲染是可中断的。（以前React中update是同步渲染，一旦update开启，在任务完成前都是不可中断的。</p></blockquote><p>在Concurrent模式下，update开始了可以中断，结果是可以继续，也可以选择遗弃。</p><ul><li>可中断。任务是有优先级，优先级高的比如用户交互，输入，点击…fiber的链表结构，指向改变。</li><li>可被遗弃。比如，一个操作过程，中间的可能切走，不重要或者过期了，所以可以被遗弃，只关注最后的展示。</li><li>状态复用。OffScreen，比如页面回退了，又重新进入了；或者即将要渲染的UI进行缓存准备。</li></ul><blockquote><p>总结: 并不是API之类的新特性，而是新特性的基础，包括Suspense、transitions等。 </p></blockquote><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><h4 id="createRoot"><a href="#createRoot" class="headerlink" title="createRoot"></a>createRoot</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const root = createRoot(document.getElementById(&apos;root&apos;))</span><br><span class="line">root.render(&lt;App /&gt;)</span><br><span class="line">root.render(&lt;App2 /&gt;)</span><br></pre></td></tr></table></figure><h4 id="自动批量处理-Automatic-Batching"><a href="#自动批量处理-Automatic-Batching" class="headerlink" title="自动批量处理 Automatic Batching"></a>自动批量处理 Automatic Batching</h4><blockquote><p>setState是同步还是异步呀，可以实现同步嘛，怎么实现，异步的原理是什么？</p></blockquote><p>18之前：都可以，同步：setTimeout，或者原生事件里同步。异步：批量处理，合成事件里，把多次的render合并起来，关键是依赖合成事件。<br>18之后，同步可用flushSync。就不要用setTimeout，也是异步了，why？不是依靠合成事件，而是自动批量处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flushSync(() =&gt; &#123;</span><br><span class="line">  // state 变化  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h4><p>加载等待，类似loading</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Suspense fallback=&#123;&lt;Spin /&gt;&#125;&gt;</span><br><span class="line">  &lt;Component /&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br></pre></td></tr></table></figure><p>…_(¦3」∠)_下回再战…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;铛铛铛，React18正式发布辣&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前置知识： Concurrent(并发)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Concurrent&quot;&gt;&lt;a href=&quot;#Concurrent&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="React" scheme="https://wangyx233.github.io/categories/React/"/>
    
    
  </entry>
  
  <entry>
    <title>【业务】下载导出那些事</title>
    <link href="https://wangyx233.github.io/2022/04/06/%5B%E4%B8%9A%E5%8A%A1%5D%E5%AF%BC%E5%87%BA%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://wangyx233.github.io/2022/04/06/[业务]导出那些事/</id>
    <published>2022-04-06T08:56:48.263Z</published>
    <updated>2022-04-06T08:56:48.267Z</updated>
    
    <content type="html"><![CDATA[<p>平时业务开发中，经常会遇到数据导出的需求，说到导出可以大体概括为两大种类：</p><ul><li>纯前端导出</li><li>有后端参与导出</li></ul><h3 id="纯前端导出"><a href="#纯前端导出" class="headerlink" title="纯前端导出"></a>纯前端导出</h3><p>这个需求的情况主要是，根据页面上展示的列表数据进行导出，简单的实现方式是将数据拼接，生成一个 url 地址，借助 a 标签下载，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// data的格式 [[&apos;tr1&apos;, &apos;tr2&apos;, &apos;tr3&apos;], [&apos;td1&apos;, &apos;td2&apos;, &apos;td3&apos;]]</span><br><span class="line">function getDownloadUrl(data, type) &#123;</span><br><span class="line">  const _utf = &quot;\uFEFF&quot;; // 防止Excel中文乱码</span><br><span class="line">  let csvData = &apos;&apos;</span><br><span class="line">  data.forEach(function (elem) &#123;</span><br><span class="line">    csvData += &quot;\&quot;&quot; + elem.join(&apos;&quot;,&quot;&apos;) + &quot;\&quot;\r\n&quot;;</span><br><span class="line">  &#125;)</span><br><span class="line">  let option = &#123;&#125;; // &#123; type: &apos;text/csv&apos;&#125;</span><br><span class="line">  if (type === &apos;xls&apos;) option = &#123;</span><br><span class="line">    type: &quot;application/vnd.ms-excel;charset=utf-8&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  const csvBlob = new Blob([_utf + csvData], option)</span><br><span class="line">  return URL.createObjectURL(csvBlob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以借用 xlsx 和 file-saver 两个插件来实现。</p><h3 id="后端参与导出"><a href="#后端参与导出" class="headerlink" title="后端参与导出"></a>后端参与导出</h3><p>有接口层参与的导出，接口层返回的数据可能分为两种，一种是直接返回下载资源的地址，另一种是返回二进制数据。</p><ol><li><p>返回一个资源地址<br>返回地址的话，可以借用<code>window.open(url)</code> 或者 <code>window.location.href = url</code> 进行下载。</p></li><li><p>返回二进制数据<br>这种方式是借助<code>Blob</code>将文件流转换为 Blob 二进制对象，利用<code>URL.createObjectUrl</code>生成 url 地址，利用<code>a</code>标签的<code>href, download</code>配合下载，示例如下：👇🏻</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">api.get(url, &#123;</span><br><span class="line">  responseType: &apos;blob&apos;,</span><br><span class="line">&#125;)</span><br><span class="line">.then((res) =&gt; &#123;</span><br><span class="line">  const &#123; data, headers &#125; = res</span><br><span class="line">  const blob = new Blob([data])</span><br><span class="line">  const url = URL.createObjectURL(blob)</span><br><span class="line">  const fileName = decodeURIComponent(</span><br><span class="line">    `$&#123;headers[&apos;content-disposition&apos;]&#125;`.split(&apos;;&apos;)[1].split(&apos;filename=&apos;)[1] // $&#123;headers[&apos;content-disposition&apos;]&#125;`.match(/filename=(.*);/)[1]</span><br><span class="line">  )</span><br><span class="line">  const a = document.createElement(&apos;a&apos;)</span><br><span class="line">  a.style.display = &apos;none&apos;</span><br><span class="line">  a.href = url</span><br><span class="line">  a.download = fileName</span><br><span class="line">  document.body.appendChild(a)</span><br><span class="line">  a.click()</span><br><span class="line">  document.body.removeChild(a)</span><br><span class="line">  URL.revokeObjectURL(url)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><ol><li>如果要获取 <code>Content-Disposition</code>，跨域的情况下需要接口层配合 <code>Access-Control-Expose-Headers: Content-Disposition</code>（前端获取到的 header 只有默认的 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。）</li><li>请求返回的 <code>Content-type: application/octet-stream</code></li><li><code>responseType: &#39;blob&#39;</code> 设置返回数据的类型，默认是 json 类型</li></ol></blockquote></li></ol><p>除了这两种方式以外，还可以通过导出接口进行参数拼接直接下载，如<code>window.location.href = &#39;导出接口地址&#39;?date=&#39;2022-04&#39;</code><br>问题：</p><ul><li>参数太多，可能会超过 url 长度限制，编码问题也需要注意(get 请求的)<br>HTTP 协议不对 URI 的长度作事先的限制，服务器必须能够处理任何他们提供资源的 URI，并且应该能够处理无限长度的 URIs，这种无效长度的 URL 可能会在客户端以基于 GET 方式的请求时产生。如果服务器不能处理太长的 URI 的时候，服务器应该返回 414 状态码（此状态码代表 Request-URI 太长）<br>不同的游览器对 URL 的长度限制是有所差异的。</li><li>鉴权问题。如果 url 是需要拼接的话，需要在 querystring 中拼接 token 信息</li><li>无法知道下载进度，下载用时</li><li>浏览器可直接浏览的文件类型是不提供下载的，如 txt、png、jpg、gif 等</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>在开发中，我们的导出方式经历了从 window.open 到 blob 方式的替换，可以在当前页面下载，无需新开页面的过度，并且下载的过程可控。<br>当然导出方式可以根据实际开发需求自行选择~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时业务开发中，经常会遇到数据导出的需求，说到导出可以大体概括为两大种类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;纯前端导出&lt;/li&gt;
&lt;li&gt;有后端参与导出&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;纯前端导出&quot;&gt;&lt;a href=&quot;#纯前端导出&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="业务" scheme="https://wangyx233.github.io/categories/%E4%B8%9A%E5%8A%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>【网络】CDN</title>
    <link href="https://wangyx233.github.io/2022/04/02/%5B%E7%BD%91%E7%BB%9C%5Dcdn/"/>
    <id>https://wangyx233.github.io/2022/04/02/[网络]cdn/</id>
    <published>2022-04-02T01:50:00.208Z</published>
    <updated>2022-04-02T02:02:38.394Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前置知识：正向代理 &amp; 反向代理</p></blockquote><ol><li>正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源。正向代理一般是客户端架设的，反向代理一般是服务器架设的。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。</li><li>正向代理中，服务器不知道真正的客户端到底是谁，以为访问自己的是真实的客户端。而在反向代理中，客户端不知道真正的服务器是谁，以为自己访问的是真实的客户端。</li><li>正向代理和反向代理的作用和目的不同。正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。</li></ol><blockquote><p>CDN(Content Delivery Network) 是一种内容分发网络，部署在应用层，利用智能分配技术，根据用户访问的地点，按照就近访问的原则分配到多个节点，来实现多点负载均衡。简单来说，用户就近访问，访问速度更快，CDN 的常见实现是有一台源站服务器，多个 CDN 节点定时从源站同步。</p></blockquote><p>CDN 的<code>缓存</code>和<code>回源</code><br>“缓存”是说我们把资源推送一份到 CDN 服务器上这个过程，“回源”是说 CDN 发现自己没有这个资源或者资源过期了，从而去原站或者或者它的上层服务器请求这个资源的过程。</p><ul><li>没有 CDN：用户访问域名 -&gt; 域名解析成对应的 IP(DNS 解析) -&gt; 根据 IP + 请求端口去服务器请求资源</li><li>用 CDN：用户访问域名 -&gt; DNS 解析返回配置的 CNAME -&gt; 智能调度 DNS 查询域名(CNAME)的 IP 地址(最适合的 CDN 节点) -&gt; 根据 IP 访问 CDN 节点服务器 -&gt; 有缓存返回，无则回源</li></ul><p>Q &amp; A</p><ul><li>所以，CDN 是正向代理还是反向代理呢？</li><li>服务端有新的更新，如何清除 CDN 的缓存呢？</li></ul><a id="more"></a><ul><li>当当当当然是反向代理啦，客户端不知道真正的服务端是谁咯。</li><li>常见的有两种方式：一是服务端把更新推送到 CDN 节点，二是通过不同的版本号进行区分。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前置知识：正向代理 &amp;amp; 反向代理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源。正向代理一般是客户端架设的，反向代理一般是服务器架设的。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。&lt;/li&gt;
&lt;li&gt;正向代理中，服务器不知道真正的客户端到底是谁，以为访问自己的是真实的客户端。而在反向代理中，客户端不知道真正的服务器是谁，以为自己访问的是真实的客户端。&lt;/li&gt;
&lt;li&gt;正向代理和反向代理的作用和目的不同。正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;CDN(Content Delivery Network) 是一种内容分发网络，部署在应用层，利用智能分配技术，根据用户访问的地点，按照就近访问的原则分配到多个节点，来实现多点负载均衡。简单来说，用户就近访问，访问速度更快，CDN 的常见实现是有一台源站服务器，多个 CDN 节点定时从源站同步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CDN 的&lt;code&gt;缓存&lt;/code&gt;和&lt;code&gt;回源&lt;/code&gt;&lt;br&gt;“缓存”是说我们把资源推送一份到 CDN 服务器上这个过程，“回源”是说 CDN 发现自己没有这个资源或者资源过期了，从而去原站或者或者它的上层服务器请求这个资源的过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有 CDN：用户访问域名 -&amp;gt; 域名解析成对应的 IP(DNS 解析) -&amp;gt; 根据 IP + 请求端口去服务器请求资源&lt;/li&gt;
&lt;li&gt;用 CDN：用户访问域名 -&amp;gt; DNS 解析返回配置的 CNAME -&amp;gt; 智能调度 DNS 查询域名(CNAME)的 IP 地址(最适合的 CDN 节点) -&amp;gt; 根据 IP 访问 CDN 节点服务器 -&amp;gt; 有缓存返回，无则回源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Q &amp;amp; A&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所以，CDN 是正向代理还是反向代理呢？&lt;/li&gt;
&lt;li&gt;服务端有新的更新，如何清除 CDN 的缓存呢？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="网络" scheme="https://wangyx233.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>【网络】传输层我来了</title>
    <link href="https://wangyx233.github.io/2022/03/21/%5B%E7%BD%91%E7%BB%9C%5D%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>https://wangyx233.github.io/2022/03/21/[网络]传输层/</id>
    <published>2022-03-21T06:34:01.187Z</published>
    <updated>2022-03-21T06:34:01.198Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>UDP（User Datagram Protocol，用户数据包协议）</p></blockquote><blockquote><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p></blockquote><ul><li>对于数据包丢失的情况，TCP 提供重传机制（Acknowledgement Number）；</li><li>TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件（Sequence Number）。</li></ul><p>一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。</p><ol><li>建立连接。通过“三次握手”来建立客户端和服务器之间的连接。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   客户端            服务端</span><br><span class="line">   SYN_SENT -&gt; SYN = 1 seq = x SYN_RCVD</span><br><span class="line">            &lt;- SYN = 1 ACK = 1 seq = y ack = x + 1</span><br><span class="line">ESTABLISHED -&gt; ACK = 1 seq = x + 1 ack = y + 1 ESTABLISHED</span><br></pre></td></tr></table></figure><blockquote><p>两次握手可以吗？</p></blockquote><p>(1) 确认双方的收发能力<br>TCP 建立连接之前，需要确认客户端与服务器双方的收包和发包的能力。</p><ul><li>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li><li>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li><li>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。<br>所以，只有三次握手才能确认双方的接收与发送能力是否正常。</li></ul><p>(2) 序列号可靠同步<br>如果是两次握手，服务端无法确定客户端是否已经接收到了自己发送的初始序列号，如果第二次握手报文丢失，那么客户端就无法知道服务端的初始序列号，那 TCP 的可靠性就无从谈起。</p><p>(3) 阻止重复历史连接的初始化<br>三次握手才有足够的上下文信息来判断当前连接是否是历史连接</p><p>(4) 安全问题<br>如果采用两次握手，就建立连接，那会放大 DDOS 攻击的。</p><p>TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而三次握手恰好可以满足以上两方面的需求！</p><blockquote><p>ISN 代表什么？意义何在？ISN 是固定不变的吗？ISN 为何要动态随机？</p></blockquote><p>ISN 全称是 Initial Sequence Number，是 TCP 发送方的字节数据编号的原点，告诉对方我要开始发送数据的初始化序列号</p><p>ISN 如果是固定的，攻击者很容易猜出后续的确认序号，为了安全起见，避免被第三方猜到从而发送伪造的 RST 报文，因此 ISN 是动态生成的</p><blockquote><p>什么是半连接队列？</p></blockquote><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立连接。服务器会把这种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。<br>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><blockquote><p>三次握手可以携带数据吗？</p></blockquote><p>第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。<br>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，疯狂着重复发 SYN 报文，这会让服务器花费大量的内存空间来缓存这些报文，这样服务器就更容易被攻击了。</p><ol start="2"><li><p>传输数据<br>接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。<br>同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。</p></li><li><p>断开连接。“四次挥手”来保证双方都能断开连接</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">客户端               服务端</span><br><span class="line">FIN_WAIT_1  -&gt; FIN = 1 seq = u</span><br><span class="line">FIN_WAIT_2  &lt;- ACK = 1 seq = v ack = u + 1 CLOSE_WAIT</span><br><span class="line">            &lt;- FIN = 1 seq = w ack = u + 1 LAST_ACK</span><br><span class="line">  TIME_WAIT -&gt; ACK = 1 seq = u + 1 ack = w + 1 CLOSE</span><br><span class="line">  CLOSE 2 MSL</span><br></pre></td></tr></table></figure><blockquote><p>为什么建立连接握手三次，关闭连接时需要是四次呢？</p></blockquote><p>其实在 TCP 握手的时候，接收端发送 SYN+ACK 的包是将一个 ACK 和一个 SYN 合并到一个包中，所以减少了一次包的发送，三次完成握手。<br>在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 FIN 包与对客户端的 ACK 包合并发送，只能先确认 ACK，然后服务器待无需发送数据时再发送 FIN 包，所以四次挥手时必须是四次数据包的交互。</p><blockquote><p>为什么 TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？</p></blockquote><p>(1) MSL 指的是报文在网络中最大生存时间。在客户端发送对服务器端的 FIN 的确认包 ACK 后，这个 ACK 包是有可能不可达的，服务器端如果收不到 ACK 的话需要重新发送 FIN 包。<br>所以客户端发送 ACK 后需要留出 2MSL 时间（ACK 到达服务器 + 服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。<br>客户端如果等待 2MSL 时间也没有收到服务器端的重传包 FIN，说明可以确认服务器已经收到客户端发送的 ACK。<br>(2) 在客户端发送完最后一个 ACK 报文段后，在经过 2MSL 时间，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文。避免新旧连接混淆。</p><p>总结：</p><ul><li>IP 负责把数据包送达目的主机。 网络层</li><li>UDP 负责把数据包送达具体应用。端口号</li><li>而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;UDP（User Datagram Protocol，用户数据包协议）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、
      
    
    </summary>
    
      <category term="TCP" scheme="https://wangyx233.github.io/categories/TCP/"/>
    
    
  </entry>
  
  <entry>
    <title>碎碎念</title>
    <link href="https://wangyx233.github.io/2022/03/16/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>https://wangyx233.github.io/2022/03/16/碎碎念/</id>
    <published>2022-03-16T03:28:05.125Z</published>
    <updated>2022-03-16T03:28:05.132Z</updated>
    
    <content type="html"><![CDATA[<p>害，还是加分号吧，减少 debug 的成本<br>来自解构赋值的怒吼。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;害，还是加分号吧，减少 debug 的成本&lt;br&gt;来自解构赋值的怒吼。。。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【JS基础】数组乱序</title>
    <link href="https://wangyx233.github.io/2022/03/10/%5BJS%E5%9F%BA%E7%A1%80%5D%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F/"/>
    <id>https://wangyx233.github.io/2022/03/10/[JS基础]数组乱序/</id>
    <published>2022-03-10T08:50:45.924Z</published>
    <updated>2022-03-10T08:50:45.927Z</updated>
    
    <content type="html"><![CDATA[<p>最近在解决一个分布式高可用的问题，如何能够让多机的定时任务能够不重复执行，引入了 redis 的分布式锁。但一个任务列表如果都顺序遍历那每个任务的抢占可能不会那么随机，所以想让任务列表打乱顺序，就稍微了解了一下数组乱序的实现。</p><blockquote><p>（其实最后用的还是 lodash 的_.shuffle() 😯</p></blockquote><p>一、随机数？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[12,4,16,3].sort(function() &#123;</span><br><span class="line">    return .5 - Math.random();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>v8 在处理 sort 方法时，使用了插入排序和快排两种方案。当目标数组长度小于 10（不同版本有差别）时，使用插入排序；反之，使用快排。</p><p>二、Fisher–Yates shuffle 洗牌算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.shuffle = function() &#123;</span><br><span class="line">    let array = this;</span><br><span class="line">    let len = array.length,</span><br><span class="line">        temp, i;</span><br><span class="line">    while (len) &#123;</span><br><span class="line">        i = Math.floor(Math.random() * len--);</span><br><span class="line">        temp = array[len];</span><br><span class="line">        array[len] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在解决一个分布式高可用的问题，如何能够让多机的定时任务能够不重复执行，引入了 redis 的分布式锁。但一个任务列表如果都顺序遍历那每个任务的抢占可能不会那么随机，所以想让任务列表打乱顺序，就稍微了解了一下数组乱序的实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（其实
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>【JS基础】复盘</title>
    <link href="https://wangyx233.github.io/2022/03/04/%5B%E5%A4%8D%E7%9B%98%5D%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80/"/>
    <id>https://wangyx233.github.io/2022/03/04/[复盘]基础中的基础/</id>
    <published>2022-03-04T07:12:21.369Z</published>
    <updated>2022-03-04T07:12:21.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基础知识要深刻，扎实，不要模棱两可，懂个大概</p></blockquote><h1 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h1><p>函数的默认返回值是 undefined 呀~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sayHi () &#123;</span><br><span class="line">  return (() =&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof sayHi())</span><br></pre></td></tr></table></figure><h1 id="作用域-与-变量提升"><a href="#作用域-与-变量提升" class="headerlink" title="作用域 与 变量提升"></a>作用域 与 变量提升</h1><blockquote><p>var 声明的变量会进行变量提升</p></blockquote><ul><li>js 代码自上而下执行之前，浏览器首先会把当前上下文中所有带“var / function”关键字进行提前的声明和定义，解析到它们对应作用域开始的位置，这种预先处理的机制叫做变量提升，变量提升的意义在于创建变量前使用这个变量不报错。</li><li>变量提升也可以称之为预解析。可以理解为这是词法解析的一个环节，语法解析发生在代码执行前</li><li>JavaScript 仅提升声明，而不提升初始化</li><li>函数和变量相比，会被优先提升。（函数声明式，函数提升是整个代码块（相当于申明和初始化都提升了）提升到它所在的作用域的最开始执行，函数字面量式，这种情况和变量提升是一样的）<blockquote><h1 id="所以看一个变量的值，要结合作用域来判断"><a href="#所以看一个变量的值，要结合作用域来判断" class="headerlink" title="所以看一个变量的值，要结合作用域来判断"></a>所以看一个变量的值，要结合作用域来判断</h1></blockquote></li></ul><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">function sayHi() &#123;</span><br><span class="line">  console.log(name)</span><br><span class="line">  console.log(age)</span><br><span class="line">  var name = &apos;xxx&apos;</span><br><span class="line">  let age = 18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var name = &apos;outer&apos;</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">  console.log(name)</span><br><span class="line">  var name = &apos;eric&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sayHi(name) &#123;</span><br><span class="line">  console.log(name)</span><br><span class="line">  var name = &apos;eric&apos;</span><br><span class="line">&#125;</span><br><span class="line">sayHi(&apos;param&apos;)</span><br><span class="line"></span><br><span class="line">var name = &quot;world&quot;;</span><br><span class="line">(function()&#123;</span><br><span class="line">  if(typeof name === &quot;undefined&quot;) &#123;</span><br><span class="line">    var name = &quot;Jack&quot;;</span><br><span class="line">      console.log(&quot;Hello &quot; + name);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&quot;Hello &quot; + name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function sayHi() &#123;</span><br><span class="line">  console.log(name)</span><br><span class="line">  name = &apos;hi&apos;</span><br><span class="line">&#125;</span><br><span class="line">sayHi()</span><br><span class="line"></span><br><span class="line">// var a = 1</span><br><span class="line">function b() &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">  a = 2</span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">console.log(a)</span><br><span class="line"></span><br><span class="line">var foo=&#123;n:1&#125;;</span><br><span class="line">(function (foo) &#123;</span><br><span class="line">    console.log(foo.n);</span><br><span class="line">    foo.n = 3;</span><br><span class="line">    var foo = &#123;n:2&#125;;</span><br><span class="line">    console.log(foo.n);</span><br><span class="line">&#125;)(foo);</span><br><span class="line">console.log(foo.n);</span><br><span class="line"></span><br><span class="line">function f1(a)&#123; // a = 111，有默认值</span><br><span class="line">    console.log(a);</span><br><span class="line">    function a()&#123;&#125;</span><br><span class="line">    console.log(a);</span><br><span class="line">    var a = 1;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">f1(2)</span><br></pre></td></tr></table></figure><blockquote><p>函数的参数名是按值传递的，参数类型是引用类型的话，传递的是引用的地址。</p></blockquote><p>函数参数和变量的问题：</p><ul><li>函数有形参，形参会被添加到函数的作用域中，并且形参不会被重新定义。var 声明与形参同名的变量会被忽略，即参数的优先级高于变量的提升。</li><li>ES6 的 let 和 const 会因为作用域内重复声明而报错。</li><li>如果函数内声明一个和形参同名的函数，装载顺序为 函数参数 &gt; 函数声明，而在函数声明装载时，如果函数体内有个和参数名相同的函数声明，那么这个函数就会覆盖形参。</li><li>有默认参数的，再传实参，参数值 会覆盖 函数声明。</li></ul><p>let：</p><ul><li>let 声明的变量的作用域是块级的；</li><li>let 不能重复声明已存在的变量；</li><li>let 有暂时性死区，不会被提升。</li></ul><h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const shape = &#123;</span><br><span class="line">  radius: 10,</span><br><span class="line">  diameter: function() &#123;</span><br><span class="line">    return this.radius * 2</span><br><span class="line">  &#125;,</span><br><span class="line">  perimeter: () =&gt; 2 * 3.14 * this.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(shape.diameter())</span><br><span class="line">console.log(shape.perimeter())</span><br></pre></td></tr></table></figure><p>undefined 的类型转换<br>如何判断是不是 NaN</p><ul><li>window.isNaN 会先把参数转化为数字类型,再判断是不是 NaN,所以像 string 类型的会是 true;</li><li>而 Number.isNaN 会先判断参数是不是数字类型,不是就返回 false, 是数字类型再进入判断是不是 NaN</li><li>利用 NaN 是 JavaScript 之中唯一不等于自身的值</li><li>Object.is(+0, -0)，Object.is() 是 ES6 用来比较两个值是否严格相等</li></ul><a id="more"></a><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ul><li>cdn 是什么，回源策略，cdn 缓存</li></ul><h1 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h1><ol><li><p>根据数字整除处理返回字符串</p></li><li><p>url 的 querystring</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基础知识要深刻，扎实，不要模棱两可，懂个大概&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;typeof&quot;&gt;&lt;a href=&quot;#typeof&quot; class=&quot;headerlink&quot; title=&quot;typeof&quot;&gt;&lt;/a&gt;typeof&lt;/h1&gt;&lt;p&gt;函数的默认返回值是 undefined 呀~&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function sayHi () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return (() =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(typeof sayHi())&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h1 id=&quot;作用域-与-变量提升&quot;&gt;&lt;a href=&quot;#作用域-与-变量提升&quot; class=&quot;headerlink&quot; title=&quot;作用域 与 变量提升&quot;&gt;&lt;/a&gt;作用域 与 变量提升&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;var 声明的变量会进行变量提升&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;js 代码自上而下执行之前，浏览器首先会把当前上下文中所有带“var / function”关键字进行提前的声明和定义，解析到它们对应作用域开始的位置，这种预先处理的机制叫做变量提升，变量提升的意义在于创建变量前使用这个变量不报错。&lt;/li&gt;
&lt;li&gt;变量提升也可以称之为预解析。可以理解为这是词法解析的一个环节，语法解析发生在代码执行前&lt;/li&gt;
&lt;li&gt;JavaScript 仅提升声明，而不提升初始化&lt;/li&gt;
&lt;li&gt;函数和变量相比，会被优先提升。（函数声明式，函数提升是整个代码块（相当于申明和初始化都提升了）提升到它所在的作用域的最开始执行，函数字面量式，这种情况和变量提升是一样的）&lt;blockquote&gt;
&lt;h1 id=&quot;所以看一个变量的值，要结合作用域来判断&quot;&gt;&lt;a href=&quot;#所以看一个变量的值，要结合作用域来判断&quot; class=&quot;headerlink&quot; title=&quot;所以看一个变量的值，要结合作用域来判断&quot;&gt;&lt;/a&gt;所以看一个变量的值，要结合作用域来判断&lt;/h1&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function sayHi() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(age)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var name = &amp;apos;xxx&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  let age = 18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var name = &amp;apos;outer&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function sayHi() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var name = &amp;apos;eric&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function sayHi(name) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var name = &amp;apos;eric&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayHi(&amp;apos;param&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var name = &amp;quot;world&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  if(typeof name === &amp;quot;undefined&amp;quot;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var name = &amp;quot;Jack&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      console.log(&amp;quot;Hello &amp;quot; + name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(&amp;quot;Hello &amp;quot; + name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function sayHi() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  name = &amp;apos;hi&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayHi()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// var a = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function b() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var foo=&amp;#123;n:1&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(function (foo) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(foo.n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    foo.n = 3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var foo = &amp;#123;n:2&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(foo.n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)(foo);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(foo.n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function f1(a)&amp;#123; // a = 111，有默认值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    function a()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var a = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f1(2)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;函数的参数名是按值传递的，参数类型是引用类型的话，传递的是引用的地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;函数参数和变量的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数有形参，形参会被添加到函数的作用域中，并且形参不会被重新定义。var 声明与形参同名的变量会被忽略，即参数的优先级高于变量的提升。&lt;/li&gt;
&lt;li&gt;ES6 的 let 和 const 会因为作用域内重复声明而报错。&lt;/li&gt;
&lt;li&gt;如果函数内声明一个和形参同名的函数，装载顺序为 函数参数 &amp;gt; 函数声明，而在函数声明装载时，如果函数体内有个和参数名相同的函数声明，那么这个函数就会覆盖形参。&lt;/li&gt;
&lt;li&gt;有默认参数的，再传实参，参数值 会覆盖 函数声明。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;let：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;let 声明的变量的作用域是块级的；&lt;/li&gt;
&lt;li&gt;let 不能重复声明已存在的变量；&lt;/li&gt;
&lt;li&gt;let 有暂时性死区，不会被提升。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const shape = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  radius: 10,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  diameter: function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return this.radius * 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  perimeter: () =&amp;gt; 2 * 3.14 * this.radius&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(shape.diameter())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(shape.perimeter())&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;undefined 的类型转换&lt;br&gt;如何判断是不是 NaN&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;window.isNaN 会先把参数转化为数字类型,再判断是不是 NaN,所以像 string 类型的会是 true;&lt;/li&gt;
&lt;li&gt;而 Number.isNaN 会先判断参数是不是数字类型,不是就返回 false, 是数字类型再进入判断是不是 NaN&lt;/li&gt;
&lt;li&gt;利用 NaN 是 JavaScript 之中唯一不等于自身的值&lt;/li&gt;
&lt;li&gt;Object.is(+0, -0)，Object.is() 是 ES6 用来比较两个值是否严格相等&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>【CSS】flex &amp; grid</title>
    <link href="https://wangyx233.github.io/2022/02/23/%5BCSS%5Dflex%20copy/"/>
    <id>https://wangyx233.github.io/2022/02/23/[CSS]flex copy/</id>
    <published>2022-02-23T09:41:33.064Z</published>
    <updated>2022-02-23T09:41:55.845Z</updated>
    
    <content type="html"><![CDATA[<p>平时常用 flex 进行对齐和布局，习惯了 align-items 和 justify-content，也会遇到过宽度换行的情况。</p><p>flex: 1 是什么？ 2 是什么？ 10px？有单位是 flex-basis 的值，无单位的话则为 flex-grow 的值</p><blockquote><p>即：一个无单位数(<number>): 它会被当作 flex:<number> 1 0;<br>注：省略值和默认值不同</number></number></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 关键字值 */</span><br><span class="line">flex: initial; // 0 1 auto 根据自身宽高设置尺寸，会收缩但不会伸长。适合一侧宽度固定，另一侧宽度任意，display: flex; 默认值</span><br><span class="line">flex: auto; // 1 1 auto 根据自身宽高，会收缩会伸长；优先扩张，适合内容动态适配</span><br><span class="line">flex: none; // 0 0 auto 根据自身宽高设置尺寸，不会收缩也不会伸长；适合自身不变的</span><br><span class="line"></span><br><span class="line">flex-grow: 省略时1</span><br><span class="line">flex-shrink: 省略时1</span><br><span class="line">flex-basis: 省略时0</span><br><span class="line">flex: 1 -&gt; 1 1 0% // 优先缩小自己的体积，充分利用剩余空间，又不侵占其他元素的位置，适合等分</span><br><span class="line">flex: 10px -&gt; 1 1 10px</span><br></pre></td></tr></table></figure><p>最近有使用 grid 布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display: grid;</span><br><span class="line">grid-template-columns: repeat(3, 1fr);</span><br><span class="line">grid-template-rows: repeat(3, 1fr);</span><br><span class="line">grid-gap: 10px;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时常用 flex 进行对齐和布局，习惯了 align-items 和 justify-content，也会遇到过宽度换行的情况。&lt;/p&gt;
&lt;p&gt;flex: 1 是什么？ 2 是什么？ 10px？有单位是 flex-basis 的值，无单位的话则为 flex-grow 的值
      
    
    </summary>
    
      <category term="css" scheme="https://wangyx233.github.io/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>&lt;JS基础&gt;手写小试</title>
    <link href="https://wangyx233.github.io/2022/02/16/%5BJS%E5%9F%BA%E7%A1%80%5D%E6%89%8B%E5%86%99%E5%B0%8F%E8%AF%95/"/>
    <id>https://wangyx233.github.io/2022/02/16/[JS基础]手写小试/</id>
    <published>2022-02-16T06:44:26.879Z</published>
    <updated>2022-02-16T07:53:29.292Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、数组扁平化"><a href="#一、数组扁平化" class="headerlink" title="一、数组扁平化"></a>一、数组扁平化</h4><p>如何将一个多维数组变成一个一维数组，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, [2, [3, [4, [5]]]]]</span><br><span class="line">// =&gt; [1,2,3,4,5]</span><br></pre></td></tr></table></figure><p>看到数组扁平，第一想到的是 concat()，然后是递归，依次实现一番。</p><p>(1) 递归</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function flat(arr, depth = 1) &#123;</span><br><span class="line">  let res = []</span><br><span class="line">  arr.forEach((elem) =&gt; &#123;</span><br><span class="line">    if(!Array.isArray(elem) || !depth)&#123;</span><br><span class="line">      res.push(elem)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      res = res.concat(flat(elem, depth - 1))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) reduce()配合 concat()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function flat(arr, depth = 1) &#123;</span><br><span class="line">  return depth ? arr.reduce((temp, elem) =&gt; (temp.concat(Array.isArray(elem) ? flat(elem, depth - 1) : elem)) , []) : arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) 内置 API，一顿操作，竟然忽略了 Js Array 的内置 api–flat()，按指定深度递归遍历数组，将所有元素与遍历的子数组中的元素合并为一个新数组返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var newArray = arr.flat([depth])</span><br><span class="line">const res = arr.flat(Infinity);</span><br></pre></td></tr></table></figure><p>(4) 正则，另辟蹊径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const res1 = JSON.stringify(arr).replace(/\[|\]/g, &apos;&apos;).split(&apos;,&apos;); // 原来数字变成了字符串</span><br><span class="line">const res2 = JSON.parse(`[$&#123;JSON.stringify(arr).replace(/\[|\]/g, &apos;&apos;)&#125;]`);</span><br></pre></td></tr></table></figure><p>(5) 迭代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function flat(arr, depth = 1) &#123;</span><br><span class="line">  while(arr.some(elem =&gt; Array.isArray(elem)) &amp;&amp; depth) &#123;</span><br><span class="line">    arr = [].concat(...arr)</span><br><span class="line">    depth--</span><br><span class="line">  &#125;</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、数组去重"><a href="#二、数组去重" class="headerlink" title="二、数组去重"></a>二、数组去重</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 17, &apos;1&apos;, 17, true, true, false, false, &apos;true&apos;, &apos;a&apos;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">// =&gt; [1, &apos;1&apos;, 17, true, false, &apos;true&apos;, &apos;a&apos;, &#123;&#125;, &#123;&#125;]</span><br></pre></td></tr></table></figure><p>看到数组去重，首先想到的是维护一个 object 用于记录出现过的值然后去掉重复，然后想到 filter 也可以实现类似的</p><p>(1) object 方法，普通 object 的 key 都会转换成 String 类型，所以可以借助 ES6 的 Map;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const uniq = (arr) =&gt; &#123;</span><br><span class="line">  const map = new Map();</span><br><span class="line">  const res = [];</span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if (!map.has(arr[i])) &#123;</span><br><span class="line">      map.set(arr[i], true);</span><br><span class="line">      res.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) filter，过滤得到首次出现的元素。判断元素是否出现过还可以使用 arr.indexOf(elem) === -1 或者 arr.includes(elem)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const res = arr.filter((elem, index) =&gt; arr.indexOf(elem) === index);</span><br></pre></td></tr></table></figure><p>(3) ES6 的 Set 数据结构，特性是每个元素都是唯一的，没有重复的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const res = [...new Set(arr)];</span><br><span class="line">[...new Set(&apos;ababbc&apos;)].join(&apos;&apos;); // &apos;abc&apos;</span><br></pre></td></tr></table></figure><h4 id="三、深拷贝"><a href="#三、深拷贝" class="headerlink" title="三、深拷贝"></a>三、深拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function cloneDeep(data, exist = new Map()) &#123;</span><br><span class="line">  if(typeof data !== &apos;object&apos; || data === null) return data</span><br><span class="line">  if(data instanceof Date) return new Date(data)</span><br><span class="line">  if(data instanceof RegExp) return new RegExp(data)</span><br><span class="line">  if(exist.has(data)) return exist.get(data)</span><br><span class="line">  let result = Array.isArray(data) ? [] : &#123;&#125;</span><br><span class="line">  exist.set(data, result)</span><br><span class="line">  const keys = [...Object.keys(data), ...Object.getOwnPropertySymbols(data)]</span><br><span class="line">  keys.forEach(key =&gt; &#123;</span><br><span class="line">    result[key] = cloneDeep(data[key], exist)</span><br><span class="line">  &#125;)</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 两个有序数组[1,3,5]和[2,4,6]，写一个 mergeArr(a,b)合并两个数组，最终得到一个有序数组</p><p>_.get()</p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、数组扁平化&quot;&gt;&lt;a href=&quot;#一、数组扁平化&quot; class=&quot;headerlink&quot; title=&quot;一、数组扁平化&quot;&gt;&lt;/a&gt;一、数组扁平化&lt;/h4&gt;&lt;p&gt;如何将一个多维数组变成一个一维数组，如：&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【浏览器】从输入URL到页面展示发生了什么？</title>
    <link href="https://wangyx233.github.io/2022/02/16/%5B%E6%B5%8F%E8%A7%88%E5%99%A8%5D%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://wangyx233.github.io/2022/02/16/[浏览器]从输入URL到页面展示发生了什么/</id>
    <published>2022-02-16T02:04:47.724Z</published>
    <updated>2022-03-21T06:34:17.209Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前置知识：目前浏览器都有哪些进程？</p></blockquote><ul><li>浏览器主进程</li><li>渲染进程：默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中。</li><li>网络进程</li><li>GPU 进程</li><li>插件进程</li></ul><blockquote><p>1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程</p></blockquote><p>多进程模型提升了浏览器的稳定性、流畅性和安全性。但同样不可避免地带来了一些问题，更高的资源占用，更复杂的体系架构。<br>为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统。<br>浏览器的主进程，渲染进程，插件进程。其他的变成基本服务，比如，网络进程、GPU 进程、Audio 进程、Video 进程、文件进程、Profile 进程、UI 进程、设备进程…内存不够的系统中，会把相关的进程都合并进主进程。</p><ol><li>用户输入 url 并回车</li><li>浏览器进程检查 url，组装协议，构成完整的 url</li><li>浏览器进程通过进程间通信（IPC）把 url 请求发送给网络进程</li><li>网络进程接收到 url 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程</li><li>如果没有，网络进程向 web 服务器发起 http 请求（网络请求），请求流程如下：</li></ol><ul><li>进行 DNS 解析，获取服务器 ip 地址，端口（端口是输入的，没输入 http 80，https 443)，如果请求协议是 HTTPS，那么还需要建立 TLS 连接</li><li>利用 ip 地址和服务器建立 tcp 连接</li><li>构建请求头信息</li><li>发送请求头信息</li><li>服务器响应后，网络进程接收响应头和响应信息，并解析响应内容</li></ul><ol start="6"><li>网络进程解析响应流程；</li></ol><ul><li>检查状态码，如果是 301/302，则需要重定向，从 Location 自动中读取地址，重新进行第 4 步 （301/302 跳转也会读取本地缓存），如果是 200，则继续处理请求。</li><li>200 响应处理：检查响应类型 Content-Type，如果是字节流类型(application/octet-stream)，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是 html 则通知浏览器进程准备渲染进程准备进行渲染。</li></ul><ol start="7"><li>准备渲染进程</li></ol><ul><li>浏览器进程检查当前 url 是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程(process-per-site-instance)</li></ul><ol start="8"><li>传输数据、更新状态。</li></ol><ul><li>渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”</li><li>渲染进程接收完数据后，向浏览器发送“确认提交”</li><li>浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏 url、前进后退的历史状态、更新 web 页面</li></ul><p>总体来说，分为网络请求和渲染两大部分，即导航流程和渲染流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前置知识：目前浏览器都有哪些进程？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;浏览器主进程&lt;/li&gt;
&lt;li&gt;渲染进程：默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。排版引
      
    
    </summary>
    
      <category term="浏览器" scheme="https://wangyx233.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>【JS基础】执行</title>
    <link href="https://wangyx233.github.io/2022/02/15/%5BJS%E5%9F%BA%E7%A1%80%5D%E6%89%A7%E8%A1%8C/"/>
    <id>https://wangyx233.github.io/2022/02/15/[JS基础]执行/</id>
    <published>2022-02-15T06:26:06.772Z</published>
    <updated>2022-02-16T03:33:36.571Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 执行主要分为两个阶段：</p><ul><li>代码预编译阶段</li><li>代码执行阶段</li></ul><p>代码预编译阶段</p><ul><li>预编译阶段进行变量声明</li><li>预编译阶段变量声明进行提升，但是值为 undefined</li><li>预编译阶段所有非表达式的函数声明进行提升</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foo(10)</span><br><span class="line">function foo (num) &#123;</span><br><span class="line">    console.log(foo)</span><br><span class="line">    foo = num;</span><br><span class="line">    console.log(foo)</span><br><span class="line">    var foo</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo)</span><br><span class="line">foo = 1</span><br><span class="line">console.log(foo)</span><br><span class="line">// undefined</span><br><span class="line">// 10</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><blockquote><p>作用域在预编译阶段确定，但是作用域链是在执行上下文的创建阶段完全生成的。执行上下文包括了：变量对象、作用域链以及 this 的指向</p></blockquote><p>预编译阶段创建变量对象(Variable Object, VO)，在执行阶段，变量对象转换为激活对象(Active Object)，即完成 VO -&gt; AO</p><blockquote><p>正常来讲，在函数执行完毕并出栈时，函数内局部变量在下一个垃圾回收节点会被回收，该函数对应的执行上下文将会被销毁，这也正是我们在外界无法访问函数内定义的变量的原因。也就是说，只有在函数执行时，相关函数可以访问该变量，该变量在预编译阶段进行创建，在执行阶段进行激活，在函数执行完毕后，相关上下文被销毁。</p></blockquote><blockquote><p>闭包： 函数嵌套函数时，内层函数引用了外层函数作用域下的变量，并且内层函数在全局环境下可访问，就形成了闭包。</p></blockquote><p>浏览器的垃圾清除</p><ul><li>标记清除</li><li>引用计数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript 执行主要分为两个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码预编译阶段&lt;/li&gt;
&lt;li&gt;代码执行阶段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码预编译阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预编译阶段进行变量声明&lt;/li&gt;
&lt;li&gt;预编译阶段变量声明进行提升，但是值为 un
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>【读书】JavaScript高级程序设计</title>
    <link href="https://wangyx233.github.io/2021/07/13/%5B%E8%AF%BB%E4%B9%A6%5DJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://wangyx233.github.io/2021/07/13/[读书]JavaScript高级程序设计/</id>
    <published>2021-07-13T03:21:58.359Z</published>
    <updated>2021-07-13T03:21:58.363Z</updated>
    
    <content type="html"><![CDATA[<p>script标签<br>defer vs async<br>共同点：只对外部脚本有效，src=’xxx’<br>不同：</p><blockquote><p>defer表明脚本立即下载，但是执行会推迟，在DOMContentLoaded之前执行。即加载无需等待，HTML5规定执行需要有序的。<br>async表明脚本会并行下载，下载完立即执行，不保证执行的顺序。会在页面loaded执行前完成。类似 DOM 内通过createElement创建script标签(可配合rel=’preload’)。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;script标签&lt;br&gt;defer vs async&lt;br&gt;共同点：只对外部脚本有效，src=’xxx’&lt;br&gt;不同：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;defer表明脚本立即下载，但是执行会推迟，在DOMContentLoaded之前执行。即加载无需等待，HTML5
      
    
    </summary>
    
      <category term="生活" scheme="https://wangyx233.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浏览器の网络-HTTP</title>
    <link href="https://wangyx233.github.io/2021/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E3%81%AE%E7%BD%91%E7%BB%9C-HTTP/"/>
    <id>https://wangyx233.github.io/2021/06/30/浏览器の网络-HTTP/</id>
    <published>2021-06-30T02:45:57.340Z</published>
    <updated>2021-07-13T03:21:58.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP是应用层协议</p><img src="/gallery/http.png"><a id="more"></a><p>ABNF语法规则<br>Chrome小绩效，network里面，按住shift可以看到鼠标悬停请求的上下游，绿色是其上游，红色是其下游</p><h3 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP/1"></a>HTTP/1</h3><ul><li><p>HTTP/0.9 -&gt; 1991出现的，依靠TCP(传输层协议)，三次握手建立连接，四次挥手断开连接。只有一个请求行类似GET /index.html，没有请求头和请求体，服务端也没有返回头信息，用ASCII字节码来传递HTML消息</p></li><li><p>HTTP/1.0，增加了请求头和响应头，并且以Key-Value的形式保存，客户端在发起请求的时候会带上请求头和请求行，然后服务端在返回信息的时候也会返回响应头和响应体。<br>那是怎样支持多种文件传输的呢？请求头应该包含什么信息，告诉服务端需要怎样的数据？<br>文件的类型,文件编码是什么，是否压缩，什么类型语言…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Charset: ISO-8859-1,utf-8</span><br><span class="line">Accept-Language: zh-CN,zh</span><br></pre></td></tr></table></figure><p>服务器接收到了请求头，会根据请求头的要求准备数据，如果服务器没有符合请求头的要求，那会返回服务端拥有的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: application/json // text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><p>然后浏览器会根据浏览器的返回来处理文件</p><p>除了可以处理多种文件外，HTTP/1.0，还引入了状态码，Cache，用户代理等特性</p></li><li><p>HTTP/1.1</p></li></ul><ol><li>增加了持久链接，不需要每次传输数据，都进行TCP链接。即在一次TCP链接里可以传输多个HTTP请求，只要浏览器或者服务端没有明确的断开连接，这个TCP连接一直保持。优势是可以减少TCP连接和断开的次数，减轻服务端的压力，提升HTTP的请求时长。<br>持久连接在HTTP/1.1中是默认打开的，不用特地设置打开，关闭的话在请求头上加上Connection: close即可。Connection: keep-alive<br>目前浏览器，同一个域名默认允许同时建立6个TCP持久连接</li><li>HTTP1.1 管线，虽然TCP可以保持连接，但是HTTP请求需要等到有返回再发下一个请求，即是顺序的。如果TCP通道中的某个请求因为各种原因没有返回，那会阻塞后面其他的请求 -&gt; 队头堵塞。所以HTTP1.1，支持将多个HTTP请求批量发送到服务器，但是服务端还是根据请求的顺序来返回。所以…FireFox、Chrome都放弃了管线化</li><li>提供了虚拟主机的支持，请求头中增加了Host，一个服务器可以支持多个域名，服务端也可以根据Host，来进行不同的响应</li><li>Transfer-Encoding: chunked。可以对动态生成内容支持。HTTP/1.0 中需要在响应头中设置完整的数据大小，如Content-Length: 101。HTTP/1.1支持Chunk transfer ，可以把数据分成任意大小数据块，每个数据块附上上一个数据块的大小，最后发送一个零长度的数据块作为结束。</li><li>支持客户端Cookies、安全机制。</li></ol><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p>RTT round-trip time 来回通讯往返时间<br>HTTP1.1 存在的问题，HTTP/1.1的带宽利用率不理想，带宽：每秒最大能发送（上行）和接收（下行）的字节数。<br>why？</p><ol><li>TCP慢启动，减少网络拥塞，有一个提速的过程</li><li>同时开启多个TCP连接，互相可能会存在抢占带宽的情况</li><li>HTTP/1.1 队头堵塞的问题，不能并行请求数据<br>所以，HTTP/2为了解决这个问题，TCP协议还是需要使用，慢启动和多个连接是TCP协议的问题，解决方法可以总结为，一个域名只维持一个TCP长连接，并且消除队头堵塞，即要实现并行请求，不需要等待其他请求的完成，随时可以给服务器发送请求，并且服务器也可以随时返回处理好的请求资源。核心是多路复用<blockquote><p>多路复用，HTTP/2 添加了一个二进制分帧层，请求信息经过二进制分帧层会被转换成一个个带有ID的帧，通过协议栈将这些帧发送到服务器。服务器接收到所有帧后，会将同一ID的帧合并成一条完整的请求，处理该请求，并将响应行，响应头，响应体分别发送到二进制分帧层</p></blockquote></li></ol><p>除了多路复用，HTTP/2还可以设置请求的优先级，服务推送，头部压缩</p><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p>甩掉TCP,TCL的包袱，HTTP/2在应用层解决了队头阻塞的问题，但是TCP协议可以理解为上是一个按照顺序传递数据的管道，所以管道内丢数据，或者故障了，整个TCP连接都会处于暂停状态，需要等待丢失的数据包重新传输，所以在TCP的传输过程中，由于单个数据包的丢失而造成的阻塞成为TCP上的队头阻塞。<br>由于HTTP/1.1可以同时维持多个TCP连接，而HTTP/2同时只维持一个TCP连接，所以随着丢包率的增加，HTTP/2的传输速率表现反而不如HTTP/1.1好用</p><p>RTT是反映网络性能的一个重要指标，TCP的握手会出现网络延时，浪费多个RTT的时间</p><p>TCP协议僵化</p><blockquote><p>HTTP/3 选择了UDP协议，基于UDP实现了可靠传输，多路复用，快速握手，有序交付，TLS —–&gt; QUIC 协议，音同quick</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h2&gt;&lt;p&gt;HTTP是应用层协议&lt;/p&gt;
&lt;img src=&quot;/gallery/http.png&quot;&gt;
    
    </summary>
    
      <category term="网络" scheme="https://wangyx233.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="https://wangyx233.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS</title>
    <link href="https://wangyx233.github.io/2021/06/30/%E5%AE%89%E5%85%A8%E4%BA%86-HTTPS/"/>
    <id>https://wangyx233.github.io/2021/06/30/安全了-HTTPS/</id>
    <published>2021-06-30T02:45:57.335Z</published>
    <updated>2021-07-13T03:21:58.470Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP的明文传输带来的问题，可能在传输过程中信息被窃取或者篡改，伪造，容易发生中间人攻击。<br>HTTP -&gt; 安全层（SSL/TLS） -&gt; 传输层 -&gt; 网络层，其中安全层的作用是对发送的HTTP请求进行加密操作，以及对接收到的HTTP请求进行解密操作。</p><p>对称加密，非对称加密的优缺点，得到一个对称加密和非对称加密搭配使用的方式。<br>传输过程中使用对称加密传输数据，而对称加密所需的密钥则通过非对称加密传输。搭配数字证书，数字证书是向浏览器方明确服务器方的身份，以及提供公钥。</p><ol><li>浏览器端向服务端发送请求，包含对称加密套件列表 + 非对称加密套件列表 + client_random</li><li>服务端接到请求后，向浏览器端发送选择的，对称加密套件 + 非对称加密套件 + service_random + 数字证书</li><li>浏览器端接到响应，先验证数字证书，然后 client_random + service_random 生成 pre_master，用公钥加密pre_master，再加浏览器确认，发送到服务端</li><li>服务端接到请求先用私钥解密，得到pre_master，服务器发送确认</li><li>开始 client_random + service_random + premaster 生成的 master secret 加密的数据进行传输。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTTP的明文传输带来的问题，可能在传输过程中信息被窃取或者篡改，伪造，容易发生中间人攻击。&lt;br&gt;HTTP -&amp;gt; 安全层（SSL/TLS） -&amp;gt; 传输层 -&amp;gt; 网络层，其中安全层的作用是对发送的HTTP请求进行加密操作，以及对接收到的HTTP请求进行解密
      
    
    </summary>
    
      <category term="网络" scheme="https://wangyx233.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTPS" scheme="https://wangyx233.github.io/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>同源策略与Web安全</title>
    <link href="https://wangyx233.github.io/2021/06/30/web%E5%AE%89%E5%85%A8/"/>
    <id>https://wangyx233.github.io/2021/06/30/web安全/</id>
    <published>2021-06-30T02:45:57.334Z</published>
    <updated>2021-07-13T03:21:58.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h1><p>Web页面安全，浏览器网络安全，浏览器安全</p><h1 id="同源策略-Same-origin-policy"><a href="#同源策略-Same-origin-policy" class="headerlink" title="同源策略 Same-origin policy"></a>同源策略 Same-origin policy</h1><p>什么是同源？</p><blockquote><p>两个URL的协议、域名、端口都相同，则这两个URL同源</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.yixuanwang.cn/?article=1</span><br><span class="line">http://www.yixuanwang.cn/?article=0</span><br></pre></td></tr></table></figure><p>相同源之间可以互相访问资源和操作DOM结点的，不同源之间会有一定安全策略的制约，即为同源策略。<br>不同源之间不能对DOM对象进行读写操作，不能读取Cookie、LocalStorage等数据，也不能通过XMLHttpRequest传递数据。<br>如果想做以上操作怎么办？</p><ul><li>页面引用第三方资源可能会导致XSS攻击 -&gt; CSP 内容安全策略，让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码</li><li>安全地进行数据传递，CORS跨域资源共享</li><li>安全地相互操作DOM，跨文档消息机制window.postMessage</li></ul><h2 id="XSS攻击-Cross-Site-Scripting-跨站脚本"><a href="#XSS攻击-Cross-Site-Scripting-跨站脚本" class="headerlink" title="XSS攻击-Cross Site Scripting 跨站脚本"></a>XSS攻击-Cross Site Scripting 跨站脚本</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>XSS是指攻击者向HTML，DOM中注入恶意脚本，从而在用户浏览页面时通过恶意注入的脚本对用户实施攻击。<br>可能会获取用户的Cookies，监控用户的行为“addEventListener”，也可能通过DOM伪造假的登录窗口，也可能生成浮窗广告，影响体验。</p><ul><li><p>存储型XSS，恶意脚本插入网站的数据库里，再读取的时候会进行攻击。</p></li><li><p>反射型 XSS 攻击，在请求连接里注入恶意脚本，将请求提交给Web服务器，Web服务器收到请求，又将恶意代码反射给了浏览器</p></li><li><p>基于 DOM 的 XSS 攻击，不涉及服务器，通过页面劫持等方法将恶意脚本注入页面，修改web页面</p><h3 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办"></a>怎么办</h3></li><li><p>服务器对输入数据进行转码</p></li><li><p>充分利用CSP(Content-Security-Policy)，限制其他源的资源下载，禁止向第三方域提交数据，禁止执行内联脚本和未授权的脚本，即使上报</p></li><li><p>使用 HttpOnly 属性，HTTP的响应头，set-cookied: xxxx ; HttpOnly。只能通过HTTP请求使用，无法通过document.cookie获取<br>还可以通过添加验证码的方式防止脚本冒充用户进行提交危险操作，对于一些不信任的输入，还可以限制其输入长度</p></li></ul><p>npm xss库</p><h2 id="CSRF攻击：陌生链接不要随便点"><a href="#CSRF攻击：陌生链接不要随便点" class="headerlink" title="CSRF攻击：陌生链接不要随便点"></a>CSRF攻击：陌生链接不要随便点</h2><h2 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h2><p>CSRF(Cross-site request forgery)，跨站请求伪造。攻击者引诱用户打开恶意网站，利用用户的登录状态，发起跨站请求做坏事。</p><ul><li><p>自动发起GET请求，如将请求接口隐藏在图片中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://www.abc.cn/sendcoin?user=xxx&amp;number=10&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>自动发起POST请求，一个隐藏的表单</p></li><li><p>引诱用户点击链接</p></li></ul><h3 id="怎么办-1"><a href="#怎么办-1" class="headerlink" title="怎么办"></a>怎么办</h3><ul><li>对于响应头的Cookie设置，SameSite可以设置Strict、Lax 和 None</li><li>验证请求的来源站点，通过Origin，Referer判断</li><li>设置CSRF Token，每次请求都携带该token进行验证</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安全问题&quot;&gt;&lt;a href=&quot;#安全问题&quot; class=&quot;headerlink&quot; title=&quot;安全问题&quot;&gt;&lt;/a&gt;安全问题&lt;/h1&gt;&lt;p&gt;Web页面安全，浏览器网络安全，浏览器安全&lt;/p&gt;
&lt;h1 id=&quot;同源策略-Same-origin-policy&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="安全" scheme="https://wangyx233.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="https://wangyx233.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>【读书】小狗钱钱</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5B%E8%AF%BB%E4%B9%A6%5D%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1/"/>
    <id>https://wangyx233.github.io/2021/06/30/[读书]小狗钱钱/</id>
    <published>2021-06-30T02:45:57.333Z</published>
    <updated>2021-07-13T03:21:58.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何实现梦想"><a href="#如何实现梦想" class="headerlink" title="如何实现梦想"></a>如何实现梦想</h2><ul><li>要有自信！！！（建立自信，最好每天写成功日记）</li><li>72小时法则：当你决定做一件事的时候，必须在72小时内开始行动，不然很有可能再也不会做（上升到本人，大概需要在72秒内就做吧🐶）</li><li>不要抱怨</li><li>一定要坚持！！！养成习惯</li><li>幸运是充分准备加努力工作的结果</li><li>利用碎片化时间，珍惜时间，不要等待。每天十分钟，可以带来真正的改变</li><li>要勇敢</li></ul><h2 id="如何赚💰"><a href="#如何赚💰" class="headerlink" title="如何赚💰"></a>如何赚💰</h2><a id="more"></a><ul><li>要始终帮别人解决问题 </li><li>要始终集中精力，关注你知道的！！！你能做到的！！！你拥有的！！！</li><li>注意你的想法和实施这个想法的勇气</li></ul><h2 id="如何养“鹅”生🥚"><a href="#如何养“鹅”生🥚" class="headerlink" title="如何养“鹅”生🥚"></a>如何养“鹅”生🥚</h2><ul><li>进行资金分配 50% 40% 10%</li><li>减少不必要的花费！！！很重要，无意义的促销，优惠，要避免</li><li>不要把大部分的💰用来偿还贷款</li><li>把💰放在安全的地方，要有监管，还要分散风险</li></ul><h2 id="Ps：如何快速计算利息和复利"><a href="#Ps：如何快速计算利息和复利" class="headerlink" title="Ps：如何快速计算利息和复利"></a>Ps：如何快速计算利息和复利</h2><blockquote><p>72公式：用72除以年利率 -&gt; 资金翻倍/减半de时间</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何实现梦想&quot;&gt;&lt;a href=&quot;#如何实现梦想&quot; class=&quot;headerlink&quot; title=&quot;如何实现梦想&quot;&gt;&lt;/a&gt;如何实现梦想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;要有自信！！！（建立自信，最好每天写成功日记）&lt;/li&gt;
&lt;li&gt;72小时法则：当你决定做一件事的时候，必须在72小时内开始行动，不然很有可能再也不会做（上升到本人，大概需要在72秒内就做吧🐶）&lt;/li&gt;
&lt;li&gt;不要抱怨&lt;/li&gt;
&lt;li&gt;一定要坚持！！！养成习惯&lt;/li&gt;
&lt;li&gt;幸运是充分准备加努力工作的结果&lt;/li&gt;
&lt;li&gt;利用碎片化时间，珍惜时间，不要等待。每天十分钟，可以带来真正的改变&lt;/li&gt;
&lt;li&gt;要勇敢&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;如何赚💰&quot;&gt;&lt;a href=&quot;#如何赚💰&quot; class=&quot;headerlink&quot; title=&quot;如何赚💰&quot;&gt;&lt;/a&gt;如何赚💰&lt;/h2&gt;
    
    </summary>
    
      <category term="生活" scheme="https://wangyx233.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="投资" scheme="https://wangyx233.github.io/tags/%E6%8A%95%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title>【网络】前端开发中的HTTP</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5B%E7%BD%91%E7%BB%9C%5Dhttp/"/>
    <id>https://wangyx233.github.io/2021/06/30/[网络]http/</id>
    <published>2021-06-30T02:45:57.332Z</published>
    <updated>2021-07-13T03:21:58.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>HTTP的缓存机制！！！<strong>重要</strong></li><li>状态码</li><li>headers</li><li>Restful API</li></ul><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><ol><li>分类<ul><li>1xx 服务器收到请求</li><li>2xx 请求成功</li><li>3xx 重定向</li><li>4xx 客户端错误</li><li>5xx 服务端错误</li></ul></li><li>常见<ul><li>200 成功</li><li>301 永久重定向（配合location新地址，浏览器自动处理，下次会直接访问新的地址）</li><li>302 临时重定向（配合location新地址，浏览器自动处理，下次还会访问旧的地址）短网址，百度之类的搜索引擎的链接，why？</li><li>304 资源未修改，缓存 <strong>注</strong></li><li>307 internal redirect</li><li>403 没有权限</li><li>404 not found</li><li>500 服务器错误</li><li>502</li><li>504 网关超时，服务器内部</li></ul></li><li>协议规范</li></ol><h2 id="Restful-API"><a href="#Restful-API" class="headerlink" title="Restful API"></a>Restful API</h2><blockquote><p>API设计方法，把每个URL当做唯一的资源标识。<br>如何设计一个资源？</p></blockquote><ul><li>尽量不用url参数，如：/api/list?page=2  -&gt; /api/list/2</li><li>用method表示操作类型，POST,PATCH/PUT,DELETE,GET</li></ul><h2 id="HTTP-Headers"><a href="#HTTP-Headers" class="headerlink" title="HTTP Headers"></a>HTTP Headers</h2><ol><li>常见的Request Headers<ul><li>Accept 浏览器可以的数据格式</li><li>Accept-Encoding 浏览器可支持的压缩算法，如：gzip</li><li>Accept-Language 浏览器支持的语言</li><li>Connection: keep-alive 保持TCP连接</li><li>Cookie</li><li>Host</li><li>User-Agent </li><li>Content-Type 发送数据格式，如：application/json</li><li>Authorization token验证</li></ul></li><li>常见的Response Headers<ul><li>Content-Type 发送数据格式，如：application/json</li><li>Content-Length 返回数据的大小，多少字节</li><li>Content-Encoding 返回数据的压缩算法，如：gzip</li><li>Set-Cookie 服务端改cookie</li></ul></li><li>自定义headers</li><li>用于缓存的headers</li></ol><h2 id="HTTP缓存机制"><a href="#HTTP缓存机制" class="headerlink" title="HTTP缓存机制"></a>HTTP缓存机制</h2><p>什么是缓存？为什么需要缓存？哪些资源可以被缓存-&gt;js/css/img静态资源和业务数据，html不能被缓存</p><blockquote><p>页面加载更快，网络请求慢，减少网络请求的体积和数量，也是不稳定的</p></blockquote><ol><li>强制缓存<br>服务端控制什么资源可以缓存，通过Response Headers中的cache-control 控制过期时间<br>Cache-Control的值</li></ol><ul><li>max-age=86400(秒)</li><li>no-cache 不用强制缓存，去服务端处理</li><li>no-store 不用强制缓存，也不用服务器缓存</li><li>private 允许用户客户端做缓存</li><li>public 允许中间如cdn<br>Expires也是做缓存过期控制的，已被Cache-Control代替，以Cache-Control为主</li></ul><ol start="2"><li>协商缓存(对比缓存)<br>服务端缓存策略，服务端来判断是否用缓存，即服务端判断客户端资源是否和服务端资源一样。如果一致则返回304，否则返回200和最新资源<br>注意：资源标识</li></ol><ul><li>Response Headers里Last-Modified：资源最后修改时间(精确到秒级)，Etag资源的唯一标识(优先级高，资源被重复生成而内容不变)</li><li>再次请求的时候，If-Modified-Since: Last-Modified时间(Request Headers里)</li><li>Etag，If-None-Match: Etag的值(Request Headers里)<br>两者共存会优先使用Etag，Last-Modified只能精确到秒级</li></ul><p>整个缓存过程！</p><h2 id="刷新页面"><a href="#刷新页面" class="headerlink" title="刷新页面"></a>刷新页面</h2><ol><li>正常操作：浏览器url，跳转，前进后退等。<blockquote><p>强制缓存有效，协商缓存有效 </p></blockquote></li><li>手动刷新，F5，刷新按钮<blockquote><p>强制缓存失效，协商缓存有效 </p></blockquote></li><li>强制刷新<blockquote><p>强制缓存失效，协商缓存失效</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;HTTP的缓存机制！！！&lt;strong&gt;重要&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;状态码&lt;/li&gt;
&lt;li&gt;header
      
    
    </summary>
    
      <category term="网络" scheme="https://wangyx233.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="https://wangyx233.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>【版本管理】gitの世界</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5B%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%5Dgit%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>https://wangyx233.github.io/2021/06/30/[版本管理]git的世界/</id>
    <published>2021-06-30T02:45:57.330Z</published>
    <updated>2021-07-13T03:21:58.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">git config --global user.name &apos;xxx&apos;</span><br><span class="line">git config --global user.email &apos;xxx&apos;</span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure><ul><li>local</li><li>global</li><li>system</li></ul><h1 id="工作区-暂存区"><a href="#工作区-暂存区" class="headerlink" title="工作区/暂存区"></a>工作区/暂存区</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -u // 已经被管理的文件 update</span><br></pre></td></tr></table></figure><ul><li><p>重命名，git的命令类比linux的系统命令，可直接git commit </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm xxx // 删除</span><br><span class="line">git mv old new</span><br></pre></td></tr></table></figure></li><li><p>git log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br><span class="line">git log -n // 最近几次commit</span><br><span class="line">git log -all --graph// 所有分支</span><br></pre></td></tr></table></figure></li><li><p>git branch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -v // 本地分支</span><br><span class="line">git branch -av</span><br></pre></td></tr></table></figure></li><li><p>.git文件夹</p></li></ul><ol><li><p>HEAD 指向某个commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b branch </span><br><span class="line">git diff HEAD HEAD^^ / HEAD~n</span><br></pre></td></tr></table></figure></li><li><p>config</p></li><li><p>refs</p></li></ol><ul><li>heads 分支</li><li>tags 里程碑</li></ul><ol start="4"><li>objects<br>blob文件对象 tree commit三者之间的关系<br>只要文件的内容相同，在git里就是唯一的，和文件名没有关系<br>加入暂存区的内容，才会再objects里面有体现<br>commit -&gt; tree -&gt; blob<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t xxx 看文件的类型</span><br><span class="line">git cat-file -p xxx 看内容</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>分离头指针 detached HEAD 没有经过某个分支做修改<br>git checkout commit-id 开发后切换分支易丢失，会提示创建新分支git branch name commit-id<br>在分支上做变更</p></li><li><p>branch 清理</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br><span class="line">git branch -d</span><br><span class="line">git branch -D</span><br></pre></td></tr></table></figure><ul><li><p>修改commit message</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend // 最近一次commit</span><br><span class="line">git rebase -i   // 变基要修改的父commit，在为同步到远端，合并commit也可以实现</span><br></pre></td></tr></table></figure></li><li><p>diff</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached //暂存区和HEAD的不同</span><br><span class="line">git diff // 工作区和暂存区的差异，不加参数是比较所有变动</span><br><span class="line">git diff -- filename filename filename </span><br><span class="line">git diff branch_name/commit-id/ branch_name/commit-id -- filename</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD // 暂存区恢复到工作区</span><br><span class="line">git reset HEAD -- filename</span><br><span class="line">git reset --hard/--soft commit-id</span><br><span class="line">git checkout -- filename // 工作区内容恢复到暂存区一样</span><br></pre></td></tr></table></figure><ul><li><p>stash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git stash list</span><br><span class="line">git stash pop // stash </span><br><span class="line">git stash apply // stash 列表内的信息还在</span><br></pre></td></tr></table></figure></li><li><p>.gitignore</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx/ // xxx的文件夹会被忽略</span><br><span class="line">xxx // xxx的文件和文件夹都会忽略</span><br></pre></td></tr></table></figure><ul><li>备份</li></ul><ol><li>哑协议：没有协议头 xxx/xx.git，看不到传输速度，速率没有智能协议高</li><li>智能协议：带协议头 &gt; file:///xxx/xxx.git<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare</span><br><span class="line">git remote add xxx.git</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>远端操作，fast-forwards，解决冲突，集成的分支不要做变基，注意fast-forwards</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git merge</span><br><span class="line">git pull</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li><li><p>git vs svn</p></li></ul><ol><li>svn需要获取批准</li><li>权限问题，效率</li><li>可以托管代码，协同合作</li></ol><ul><li><p>工作流</p></li><li><p>rerere</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --local rerere.enabled true</span><br><span class="line">git merge // 解决冲突</span><br><span class="line">git add</span><br><span class="line">git commit</span><br><span class="line">git reset</span><br><span class="line">git rebase</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="git" scheme="https://wangyx233.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://wangyx233.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>【必备】开发环境 &amp; 运行环境</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5B%E5%BC%80%E5%8F%91%5D%E5%B7%A5%E5%85%B7/"/>
    <id>https://wangyx233.github.io/2021/06/30/[开发]工具/</id>
    <published>2021-06-30T02:45:57.329Z</published>
    <updated>2021-07-13T03:21:58.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><ul><li>git</li><li>调试工具</li><li>抓包</li><li>webpack babel</li><li>linux</li></ul><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>git show commit-id</p><p>~/.ssh</p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><ul><li>同一个局域网下</li><li>手机配电脑的代理</li><li>设置ssh代理proxy</li><li>重定向map</li></ul><h2 id="webpack-amp-babel"><a href="#webpack-amp-babel" class="headerlink" title="webpack &amp; babel"></a>webpack &amp; babel</h2><ol><li>ES6模块化<ul><li>export {aaa,bbb,ccc}; import {aaa,bbb,ccc} from ‘xxx’ </li><li>export default {aaa}; import a from ‘xxx’</li></ul></li><li>ES6语法</li><li>压缩，整合代码，配置</li></ol><h2 id="常用linux命令"><a href="#常用linux命令" class="headerlink" title="常用linux命令"></a>常用linux命令</h2><pre><code>- ls -a- mv old new 修改文件名- cp name copyname- cat head tail- grep 查找- vimtutor</code></pre><h1 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h1><ul><li>页面加载过程</li><li>性能优化</li><li>安全</li></ul><h2 id="页面加载过程"><a href="#页面加载过程" class="headerlink" title="页面加载过程"></a>页面加载过程</h2><ul><li>从输入url到渲染出页面的整个过程</li><li>window.onload vs DOMContentLoaded</li></ul><ol><li>加载资源形式</li><li>加载过程<ul><li>DNS解析：域名-&gt;IP地址</li><li>浏览器根据IP地址向服务器发起http请求</li><li>服务器处理请求，并返回给浏览器</li></ul></li><li>渲染过程<ul><li>DOM树</li><li>CSSOM</li><li>DOM + CSSOM -&gt; Render Tree</li><li>根据Render Tree渲染页面</li><li>遇到 script 则暂停渲染，优先加载js文件，执行js 代码</li><li>直到渲染完</li></ul></li></ol><p>css文件为什么要放在head中？避免重复渲染<br>js为什么要放在body最后？不阻塞加载</p><p>load // 页面全部加载完，整个资源加载完，比如img，视频，iframe都加载完<br>DOMContentLoaded // DOM渲染完即可执行<br>window.load</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li>减少CPU计算量，减少网络加载耗时</li><li>多使用缓存 - 空间换时间（Chrome浏览器，简洁，每个标签页一个进程）</li></ul><h3 id="从何入手"><a href="#从何入手" class="headerlink" title="从何入手"></a>从何入手</h3><ul><li>加载更快<ol><li>减少资源体积：压缩代码（JS，CSS，图片…）服务器端gzip，三分之一</li><li>减少访问次数：合并代码，SSR服务端渲染，缓存(文件内容不变，hash不变)</li><li>使用更快的网络，CDN</li></ol></li><li>渲染更快<ol><li>css放在head，js放在body最后</li><li>尽早的执行js，用DOMContentLoaded</li><li>懒加载，图片懒加载</li><li>对DOM查询进行缓存</li><li>频繁DOM操作合并一起</li><li>节流 throttle、防抖 debounce</li></ol></li></ul><h3 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h3><blockquote><p>两个事件之间的时间间隔超过time才会执行，没超过间隔的任务都会取消。即在事件结束和暂停的时候触发，间断理解</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn, delay = 500) &#123;</span><br><span class="line">    let timer = null;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        if (timer) clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(() =&gt; &#123;</span><br><span class="line">            fn.apply(this, arguments);</span><br><span class="line">            timer = null;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 throttle"></a>节流 throttle</h3><blockquote><p>无论触发速率多快，都保持一个频率触发。比如，拖拽时间，无论拖拽的多快都会每隔100ms触发一次。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, delay = 100) &#123;</span><br><span class="line">    let timer = null;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        if (timer) return;</span><br><span class="line">        timer = setTimeout(() =&gt; &#123;</span><br><span class="line">            fn.apply(this, arguments);</span><br><span class="line">            timer = null;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开发环境&quot;&gt;&lt;a href=&quot;#开发环境&quot; class=&quot;headerlink&quot; title=&quot;开发环境&quot;&gt;&lt;/a&gt;开发环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;git&lt;/li&gt;
&lt;li&gt;调试工具&lt;/li&gt;
&lt;li&gt;抓包&lt;/li&gt;
&lt;li&gt;webpack babel&lt;/li
      
    
    </summary>
    
      <category term="工具" scheme="https://wangyx233.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://wangyx233.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【生活】如果有购房需求</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5B%E4%BA%BA%E7%94%9F%5D%E8%B4%AD%E6%88%BF/"/>
    <id>https://wangyx233.github.io/2021/06/30/[人生]购房/</id>
    <published>2021-06-30T02:45:57.328Z</published>
    <updated>2021-07-13T03:21:58.438Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>房产经纪人-一度觉得自己可以成为</p></blockquote><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>不论二手还是新房都有一些共通之处，最终要的是要多学，多看，多比较</p><blockquote><p>平时买个几块钱的菜都要比来比去，怎么到了几十上百万的🏡的时候就比买白菜还随意呢？</p></blockquote><ul><li><p>现在资讯无比发达，所以在下手之前可以通过各种大v，公众号，或者直播了解一些房产的基本信息。</p><h2 id="外部因素"><a href="#外部因素" class="headerlink" title="外部因素"></a>外部因素</h2><ol><li>学区属性是否刚需</li><li>交通地铁</li><li>邻居</li><li>车位</li><li>流通性</li><li>…</li></ol><h2 id="内部因素"><a href="#内部因素" class="headerlink" title="内部因素"></a>内部因素</h2><ol><li>楼层，楼高</li><li>采光，遮挡</li><li>隔音，噪音，是否临街</li><li>下水，独立下水</li><li>供暖，物业</li><li>窗户</li><li>…</li></ol></li><li><p>可以多实地看几套二手房，看房又不💰，实地感受一下各种因素的影响，以及自己的接受度</p></li><li><p>二手房尤其要注意🏡的流通性，大概率5-8年会换房，所以中介费，还有税费要注意</p></li><li><p>新房封顶以后才能批贷，这点要注意。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;房产经纪人-一度觉得自己可以成为&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h1&gt;&lt;p&gt;不论二手还是新房都有一
      
    
    </summary>
    
      <category term="生活" scheme="https://wangyx233.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="购房" scheme="https://wangyx233.github.io/tags/%E8%B4%AD%E6%88%BF/"/>
    
  </entry>
  
  <entry>
    <title>【工程化】Webpack</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5B%E5%B7%A5%E7%A8%8B%E5%8C%96%5DWebpack/"/>
    <id>https://wangyx233.github.io/2021/06/30/[工程化]Webpack/</id>
    <published>2021-06-30T02:45:57.328Z</published>
    <updated>2021-07-13T03:21:58.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><h2 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h2><ol><li>转换ES6</li><li>转换JSX</li><li>压缩混淆</li><li>CSS预处理器</li><li>图片压缩<br>…</li></ol><p>gulp 任务打包器，文件流的概念，每一步构建的结果不会存本地磁盘，而是存在内存里，可以加快打包速度。</p><p>webpack vs gulp 社区生态丰富，配置灵活，插件化扩展，官方更新迭代快；module builder vs task runner</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>配置文件，默认：webpack.config.js<br>可以使用 webpack –config xxx 指定配置文件</p><p>webpack<br>webpack-cli</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ol><li>entry：模块依赖打包的入口，单页应用为字符串，多页应用为{key: value}</li><li>output：将编译的文件输出到磁盘，通过filename [xxx]区别多入口多输出，输出的文件名称，为entry设置的key名</li><li>loaders！webpack开箱即用的只有js和json两种类型，所以需要通过loaders去支持其他文件类型并转成有效的模块，并且可以加到依赖图里<br>loaders其实是个函数，接受源文件为参数，返回转换的结果。链式调用的，从右向左执行<br>比如：</li></ol><ul><li>babel-loader</li><li>css-loader</li><li>less-loader</li><li>file-loader</li></ul><ol start="4"><li>plugins，增强webpack的功能，对打包文件的优化，资源的管理，环境变量的注入。作用于整个构建过程</li></ol><ul><li>CommonsChunkPlugin</li><li>HtmlWebpackPlugin</li><li>UglifyjsWebpackPlugin</li></ul><ol start="5"><li>mode: 指定打包的环境，production，development</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: &apos;xxx&apos;,</span><br><span class="line">        admin: &apos;sss&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;[xxx].js&apos;,</span><br><span class="line">        path: &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    mode: &apos;production&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>文件监听的原理分析<br>轮询地判断文件最后编辑时间是否变化，某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等aggregateTimeout</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watchOptions: &#123;</span><br><span class="line">    ignored: /node_modules/,</span><br><span class="line">    aggregateTimeout: 300, // 监听到变化后，多长时间后再去执行</span><br><span class="line">    poll: 1000 // 1s询问多少次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>热更新<br>webpack compile<br>HMR Server   -&gt; HMR Runtime，会被注入到浏览器的bundle.js里面，浏览器里的bundle.js 就可以建立连接websocket，更新变化<br>Bundle Server -&gt; 浏览器访问 localhost</p></li></ol><ul><li>两个阶段，启动阶段 文件系统 -&gt; webpack compile -&gt; Bundle Server</li><li>变更阶段，文件系统 -&gt; webpack compile -&gt; HMR Server -&gt; HMR Runtime （json形式）</li></ul><ol start="8"><li>文件指纹 - 打包后输出的文件名后缀<br>怎样生成的？</li></ol><ul><li>hash，和整个项目的构建有关，只要项目文件有修改，整个项目构建的hash就会更改</li><li>chunkhash，和webpack打包的chunk有关，不同的entry会生成不同的chunkhash</li><li>contenthash，根据文件内容来生成hash，文件内容不变，则contenthash不变</li></ul><p>ps. file-loader 里面的hash也是指contenthash的意思。style-loader是将css代码插入到head中,MiniCssExtractPlugin是将css文件提取出独立的文件，二者互斥</p><ol start="9"><li>清理构建目录 - clean-webpack-plugin</li><li>css</li></ol><ul><li>属性前缀 - autoprefixer，postcss-loader</li><li>px rem 相互转换 rem: font-size of the root element。px2rem-loader</li></ul><ol start="10"><li><p>静态资源内联，raw-loader。读取文件的内容，然后把文件的内容插入到对应的位置</p></li><li><p>多页面打包，MPA - 借助 glob</p><blockquote><p>glob.sync(path.join(__dirname, ‘./src/*/index.js’))<br>动态获取entry以及HtmlWebpackPlugin</p></blockquote></li><li><p>source-map定位到源代码，开发环境中用，线上环境关闭<br>cheap-source-map , inline-source-map，eval 不会有单独的map文件</p></li><li><p>提取公共资源</p></li></ol><ul><li>HtmlWebpackExternalsPlugin，放cdn的地址</li><li>SplitChunkPlugin</li></ul><ol start="14"><li>Tree Shaking<br>设置mode: production,是默认开启的</li></ol><ul><li>原理：DCE（Dead Code  Elimination）<br>代码不可到达的，不能执行；执行结果不会使用；代码只写不用</li><li>利用ES6模块的特点，只能作为模块顶部的语句出现；import的模块名只能是字符串常量；import binding是不可变的</li><li>uglify阶段删除无用代码</li><li>具有副作用的代码，tree shaking会失效</li></ul><p>副作用：一个函数会、或者可能会对函数外部变量产生影响的行为</p><ol start="15"><li><p>Scope hoisting<br>问题：</p><ul><li>大量函数闭包包裹代码，导致体积增大</li><li>运行代码时创建的函数作用域多，内存开销大</li></ul><p>模块转换，一个闭包包裹；import被转换成__webpack_require</p></li><li><p>代码分割，动态import，通过JSONP实现</p></li></ol><ul><li>抽离相同代码到一个共享块</li><li>脚本懒加载，初始下载的代码更小 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;历史&quot;&gt;&lt;a href=&quot;#历史&quot; class=&quot;headerlink&quot; title=&quot;历史&quot;&gt;&lt;/a&gt;历史&lt;/h1&gt;&lt;h2 id=&quot;为什么需要&quot;&gt;&lt;a href=&quot;#为什么需要&quot; class=&quot;headerlink&quot; title=&quot;为什么需要&quot;&gt;&lt;/a&gt;为什么需
      
    
    </summary>
    
      <category term="Webpack" scheme="https://wangyx233.github.io/categories/Webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>【生活】如果有保险需求</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5B%E4%BA%BA%E7%94%9F%5D%E5%AE%B6%E5%BA%AD%E4%BF%9D%E9%99%A9%E9%85%8D%E7%BD%AE/"/>
    <id>https://wangyx233.github.io/2021/06/30/[人生]家庭保险配置/</id>
    <published>2021-06-30T02:45:57.327Z</published>
    <updated>2021-07-13T03:21:58.419Z</updated>
    
    <content type="html"><![CDATA[<p>人生中总有各种事情发生，鉴于马上要背上巨额贷款，为了一定程度上抵御风险，不得不看起了保险。基于自己浅薄的研究，总结了几大类产品：</p><p>看病(尤其是大病)：</p><ul><li>百万医疗</li><li>重疾</li></ul><p>GG:</p><ul><li>寿险</li><li>意外险</li></ul><p>如果不考虑太多的，平时缴纳的社保，以及公司的补充医疗基本能够覆盖平时的看病就医。所以保险里的医疗部分一般主要cover大病系列，百万医疗是可以报销治疗过程中的费用。而重疾则是一次性给付，确诊了就赔付，弥补无法搬砖导致的损失，支撑生活。</p><ul><li>百万医疗，支付宝上可以入好医保6/20年版本的，年轻时刻几百左右。</li><li>重疾，是真的贵。2021/2月要执行新规，先观望吧，之前入的话，能择优理赔的更好。</li></ul><p>意外和馅饼也不知道哪个先来。所以如果为了买个安心，用不到当然更好，这个时候就祭出了寿险。如果不小心GG，还会留下一部分💰，保证家里的继续。</p><ul><li>寿险，选个性价比高的就行，最好用不到，所以选个自己能接受的价格，保自己想要的额度就好。目前只看了大麦2021，擎天柱5号…，如果是夫妻双方都苦苦支撑起了一个家，还有大麦甜蜜家2021这种项目。</li><li>意外，如果配置了其他的寿险，医疗啥的，也可以不用care这个。也不需要买长期的，即买即用，一年的价格也便宜，比如大护甲xxx。</li></ul><p>如果要买保险的话，一定要仔细看下投保须知和除外责任，尽量减少踩太多坑坑坑。<br>jin se太难了</p><p>当然一切都看开，其实无所畏惧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人生中总有各种事情发生，鉴于马上要背上巨额贷款，为了一定程度上抵御风险，不得不看起了保险。基于自己浅薄的研究，总结了几大类产品：&lt;/p&gt;
&lt;p&gt;看病(尤其是大病)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;百万医疗&lt;/li&gt;
&lt;li&gt;重疾&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GG:&lt;/p&gt;
&lt;u
      
    
    </summary>
    
      <category term="生活" scheme="https://wangyx233.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="保险" scheme="https://wangyx233.github.io/tags/%E4%BF%9D%E9%99%A9/"/>
    
  </entry>
  
  <entry>
    <title>【WebAPI】BOM</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BWebAPI%5DBOM/"/>
    <id>https://wangyx233.github.io/2021/06/30/[WebAPI]BOM/</id>
    <published>2021-06-30T02:45:57.327Z</published>
    <updated>2021-07-13T03:21:58.455Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>BOM -&gt; Browser Object Model</p></blockquote><ul><li>如何识别浏览器的类型</li><li>分别拆解url各部分</li></ul><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>navigator</li><li>screen</li><li>location</li><li>history<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 1. navigator</span><br><span class="line">const ua = navigator.userAgent;</span><br><span class="line"></span><br><span class="line">// 2. screen</span><br><span class="line">const width = screen.width;</span><br><span class="line">const height = screen.height;</span><br><span class="line"></span><br><span class="line">// 3. location</span><br><span class="line">location.href</span><br><span class="line">location.protocol</span><br><span class="line">location.pathname</span><br><span class="line">location.hash</span><br><span class="line">location.search</span><br><span class="line">location.host</span><br><span class="line"></span><br><span class="line">// 4. history</span><br><span class="line">history.back();</span><br><span class="line">history.forwards();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;BOM -&amp;gt; Browser Object Model&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如何识别浏览器的类型&lt;/li&gt;
&lt;li&gt;分别拆解url各部分&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>【React】Virtual DOM</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BReact%5D%E8%99%9A%E6%8B%9FDOM/"/>
    <id>https://wangyx233.github.io/2021/06/30/[React]虚拟DOM/</id>
    <published>2021-06-30T02:45:57.326Z</published>
    <updated>2021-07-13T03:21:58.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What？"><a href="#What？" class="headerlink" title="What？"></a>What？</h1><p>Virtual DOM本质上是JS 和 DOM 之间的一个映射缓存，是能够描述DOM结构及其属性的JS对象。</p><ul><li>虚拟DOM是JS对象</li><li>虚拟DOM是对真实DOM的描述</li></ul><p>挂载阶段，根据JSX的描述，构建出虚拟DOM，然后通过ReactDOM.render实现虚拟DOM到真实DOM的映射<br>更新阶段，页面的变化在作用于真实DOM之前，会先作用于虚拟DOM</p><h1 id="Why？"><a href="#Why？" class="headerlink" title="Why？"></a>Why？</h1><ul><li>jQuery解决DOM API 不好使的问题。还解决浏览器兼容，链式API调用，插件扩展</li><li>模板引擎，只关心数据，不关心DOM细节。操作真实DOM的范围过大、频率过高，但思想是数据驱动视图</li><li>虚拟DOM的点不在性能。虚拟DOM有没有借鉴模板引擎无法考证，但是思想上有一定的递进关系。JSX不是模板，而是JS的一个体验像模板的扩展语法糖，然后增加了个虚拟DOM的缓存层。</li></ul><blockquote><p>差量更新。即当DOM操作比较频繁时，会将前后两次的DOM树变化进行对比diff，定位到需要更新的部分，生成一个“补丁集”，把“补丁”patch打在需要更新的那部分真实DOM上，就可以实现差量更新<br>批量更新。batch函数处理，把短时间内的多次DOM操作合成一个次更新，即把收集的多个补丁集暂存到队列中，再讲最终结果交给渲染函数，实现DOM的集中化批量更新。</p></blockquote><ol><li>研发体验/研发效率。虚拟DOM思想是数据驱动视图，前端声明式编程。</li><li>性能不是卖点。性能还不错，性能量化不能一概而论只看一个指标，得看实际情况。DOM操作量级有关</li><li>价值？跨平台，一次编码多次应用。虚拟DOM是对实际渲染内容的一次抽象</li><li>规避xss攻击</li></ol><p>缺点：</p><ol><li>内存占用高，虚拟DOM，object</li><li>无法进行极致优化。如Google Earth</li></ol><h1 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h1><h2 id="调和Reconciliation-和-Diff算法"><a href="#调和Reconciliation-和-Diff算法" class="headerlink" title="调和Reconciliation 和 Diff算法"></a>调和Reconciliation 和 Diff算法</h2><blockquote><p>调和是将虚拟DOM映射到真实DOM的过程。Diff算法只是其中的一个小部分，深度优先遍历</p></blockquote><ol><li><p>React 15为代表的“栈调和”<br>传统的递归比较两棵树结构的不同算法复杂度是O(n^3)，这个复杂度显然不能令人接受，所以React中做了什么呢，将复杂度转换成O(n)</p><ul><li>Diff算法性能突破的关键点是“分层比较”<br>分层比较其实是分层递归比较，所以“同层级操作”是主流，只针对相同层级的节点进行比较，如果是跨层级的节点操作，其实是对应这销毁和重建的过程，尽量保持DOM节点的稳定性。</li><li>类型一致的节点才有继续Diff的必要<br>根据主要“矛盾”类型不一致的节点，直接放弃比较，原地替换旧的节点。</li><li>key属性的设置，可以尽可能重用同一层级内的节点<br>key主要解决的是同一层级下节点的重用问题。设置key的元素可以避免不必要的销毁和重建，只是调整顺序排列。<blockquote><p>注：作为一个节点的唯一标识，使用key之前，保证key的唯一和稳定。<br>大致过程可以描述为树对比、组件对比、元素对比<br>总结：栈调和机制下的Diff算法，其实是树的深度优先遍历过程。<br>这个过程是同步的过程，不可被打断。Stack Reconciler 需要的时间越长，意味着JS线程将霸占主线程的时间越长。进而导致会出现渲染卡死、交互无响应的现象。</p></blockquote></li></ul></li><li><p>React 16以来的“Fiber调和”<br>Fiber：纤程，对渲染过程进行更加精细的控制。是Fiber树结构的节点单位，也就是React 16下的“虚拟DOM”,并且Fiber节点保存了组件需要更新的状态和副作用。</p></li></ol><ul><li>可中断</li><li>可恢复</li><li>优先级</li></ul><h1 id="Better？"><a href="#Better？" class="headerlink" title="Better？"></a>Better？</h1><ol><li>避免跨层级节点移动</li><li>设置唯一的key，尽量减少组件层级</li><li>设置shouldComponentUpdate 或者 React.pureComponet 减少 diff 次数</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;What？&quot;&gt;&lt;a href=&quot;#What？&quot; class=&quot;headerlink&quot; title=&quot;What？&quot;&gt;&lt;/a&gt;What？&lt;/h1&gt;&lt;p&gt;Virtual DOM本质上是JS 和 DOM 之间的一个映射缓存，是能够描述DOM结构及其属性的JS对象。&lt;/p&gt;
      
    
    </summary>
    
      <category term="React" scheme="https://wangyx233.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://wangyx233.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>【React】生命周期</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BReact%5D%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://wangyx233.github.io/2021/06/30/[React]生命周期/</id>
    <published>2021-06-30T02:45:57.326Z</published>
    <updated>2021-07-13T03:21:58.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-15"><a href="#React-15" class="headerlink" title="React 15"></a>React 15</h2><img src="/gallery/react15life.png"><ul><li>Mounting 阶段：组件的初始化渲染<br>在组件一生中仅会发生一次。组件初始化，然后被渲染到真实的 DOM 中，完成“首次渲染”。render 不会操作真实的 DOM，真实 DOM 的渲染工作，在挂载阶段是由 ReactDOM.render 来承接的。componentDidMount 在渲染后触发，此时真实的 DOM 已经挂载，可以进行数据请求，初始化等操作。</li><li>Updating 阶段：组件的更新<ol><li>父组件更新触发的更新。componentReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的</li><li>组件调用 setState 触发更新。 shouldComponentUpdate 决定组件的 re-render</li></ol></li><li>Unmounting 阶段：组件的卸载。 组件被移除了，或者设置了 key，在 render 过程中发现 key 改变了</li></ul><h2 id="React-16"><a href="#React-16" class="headerlink" title="React 16"></a>React 16</h2><h3 id="React-16-4"><a href="#React-16-4" class="headerlink" title="React 16.4"></a>React 16.4</h3><img src="/gallery/react16life.png"><a id="more"></a><ul><li><p>Mounting 阶段：组件的初始化渲染<br>废弃了 componentWillMount，新增了 getDerivedStateFromProps。getDerivedStateFromProps 不是 componentWillMount 的替代品，而是试图替换掉 componentWillReceiveProps，因此它有且仅有一个用途：使用 props 来派生/更新 state。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static getDerivedStateFromProps(props, state)</span><br><span class="line">// 1. getDerivedStateFromProps 是一个静态方法。静态方法不依赖组件实例而存在，因此在这个方法内部是访问不到 this</span><br><span class="line">// 2. 该方法可以接收两个参数：props 和 state，它们分别代表当前组件接收到的来自父组件的 props 和当前组件自身的 state</span><br><span class="line">// 3. getDerivedStateFromProps 需要一个对象格式的返回值，getDerivedStateFromProps 的返回值之所以不可或缺，是因为 React 需要用这个返回值来更新（派生）组件的 state，getDerivedStateFromProps 方法对 state 的更新动作并非“覆盖”式的更新，而是针对某个属性的定向更新</span><br></pre></td></tr></table></figure><p>React 16 之前，render 方法必须返回单个元素，而 React 16 允许我们返回元素数组和字符串。<br>componentDidCatch(error, info)</p></li><li><p>Updating 阶段：组件的更新<br>在 React 16.4 中，任何因素触发的组件更新流程（包括由 this.setState 和 forceUpdate 触发的更新流程）都会触发 getDerivedStateFromProps；而在 v 16.3 版本时，只有父组件的更新会触发该生命周期。<br>在确保生命周期函数的行为更加可控可预测，从根源上帮开发者避免不合理的编程方式，避免生命周期的滥用；同时，也是在为新的 Fiber 架构铺路。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) &#123;&#125;</span><br></pre></td></tr></table></figure><p>getSnapshotBeforeUpdate 的返回值会作为第三个参数给到 componentDidUpdate。它的执行时机是在 render 方法之后，真实 DOM 更新之前。在这个阶段里，我们可以同时获取到更新前的真实 DOM 和更新前后的 state&amp;props 信息。getSnapshotBeforeUpdate 要想发挥作用，离不开 componentDidUpdate 的配合。</p></li><li><p>Unmounting 阶段：组件的卸载，同 React 15</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为什么要改呢？<br>React 16 改造生命周期的主要动机是为了配合 Fiber 架构带来的异步渲染机制，针对生命周期中长期被滥用的部分推行了具有强制性的最佳实践。这一系列的工作做下来，首先是确保了 Fiber 机制下数据和视图的安全性，同时也确保了生命周期方法的行为更加纯粹、可控、可预测。Fiber 会使原本同步的渲染过程变成异步的。<br>新的生命周期分为Render 和 Commit阶段，Commit阶段涉及实际的DOM修改，不会被打断，而Render阶段可以被打断<br>如果在废除的 willMount ，willUpdate，willReceiveProps生命周期中进行如下操作，由于这些生命周期都在Render阶段，可随时被打断。配合Fiber的异步渲染可能会导致无法预料的结果展示。</p><ul><li>setState</li><li>fetch</li><li>操作真实DOM<br>……</li></ul><blockquote><p><a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;React-15&quot;&gt;&lt;a href=&quot;#React-15&quot; class=&quot;headerlink&quot; title=&quot;React 15&quot;&gt;&lt;/a&gt;React 15&lt;/h2&gt;&lt;img src=&quot;/gallery/react15life.png&quot;&gt;

&lt;ul&gt;
&lt;li&gt;Mounting 阶段：组件的初始化渲染&lt;br&gt;在组件一生中仅会发生一次。组件初始化，然后被渲染到真实的 DOM 中，完成“首次渲染”。render 不会操作真实的 DOM，真实 DOM 的渲染工作，在挂载阶段是由 ReactDOM.render 来承接的。componentDidMount 在渲染后触发，此时真实的 DOM 已经挂载，可以进行数据请求，初始化等操作。&lt;/li&gt;
&lt;li&gt;Updating 阶段：组件的更新&lt;ol&gt;
&lt;li&gt;父组件更新触发的更新。componentReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的&lt;/li&gt;
&lt;li&gt;组件调用 setState 触发更新。 shouldComponentUpdate 决定组件的 re-render&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Unmounting 阶段：组件的卸载。 组件被移除了，或者设置了 key，在 render 过程中发现 key 改变了&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;React-16&quot;&gt;&lt;a href=&quot;#React-16&quot; class=&quot;headerlink&quot; title=&quot;React 16&quot;&gt;&lt;/a&gt;React 16&lt;/h2&gt;&lt;h3 id=&quot;React-16-4&quot;&gt;&lt;a href=&quot;#React-16-4&quot; class=&quot;headerlink&quot; title=&quot;React 16.4&quot;&gt;&lt;/a&gt;React 16.4&lt;/h3&gt;&lt;img src=&quot;/gallery/react16life.png&quot;&gt;
    
    </summary>
    
      <category term="React" scheme="https://wangyx233.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://wangyx233.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>【React】源码从入门到跑路</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BReact%5D%E6%BA%90%E7%A0%81%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%B7%91%E8%B7%AF/"/>
    <id>https://wangyx233.github.io/2021/06/30/[React]源码从入门到跑路/</id>
    <published>2021-06-30T02:45:57.325Z</published>
    <updated>2021-07-13T03:21:58.401Z</updated>
    
    <content type="html"><![CDATA[<ul><li>event 事件为什么需要bind(this)</li></ul><ol><li>对于class内普通定义的触发函数需要bind this，而使用静态方法定义则可以不用绑定<pre><code>class Test { constructor(props) {     this.normalFun = this.normalFun.bind(this) // 只执行一次 } normalFun() {} staticFun = () =&gt; {} eventFun = event =&gt; {} // 追加的event参数 render() {     return &lt;div onClick={this.staticFun}&gt;&lt;/div&gt; }}</code></pre></li><li>由于this指向的问题，如果普通模式不bind this的话，此时this指向为undefined，而静态方法的this指向当前实例</li><li>如果要bind的话，bind this 的位置写在什么地方合适呢？和执行的次数有关，性能优化小点</li></ol><ul><li>event 参数，不是原生的event，是组合事件<br>通过event.<em>proto</em>.constructor区分，React的event是组合事件(SyntheticEvent)，原生的为MouseEvent。通过nativeEvent获取原生事件<br>event.target,event.currentTarget vs event.nativeEvent.target 触发的 event.nativeEvent.currentTarget 绑定的document，React 17之前。<br>自定义参数，最后会追加一个参数是event</li></ul><p>区别 vue ：原生的事件，绑定在当前元素上<br>react：不是原生的事件，是组合事件SyntheticEvent模拟DOM事件所有能力，react 17 之前绑定在document，之后当前元素</p><ul><li>表单</li></ul><ol><li>受控组件，类似双向数据绑定</li><li>非受控组件<br>propTypes 类型检查 component.propTypes</li></ol><ul><li>父组件子组件通讯</li></ul><ol><li>传值 list = {xxx}</li><li>传函数，父组件控制数据，数据提升 cFun = {xxx}</li></ol><ul><li>setState</li></ul><ol><li>不可变值</li><li>可能是异步</li><li>可能会被合并</li><li>可能是同步</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;event 事件为什么需要bind(this)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;对于class内普通定义的触发函数需要bind this，而使用静态方法定义则可以不用绑定&lt;pre&gt;&lt;code&gt;class Test {
 constructor(props
      
    
    </summary>
    
      <category term="React" scheme="https://wangyx233.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://wangyx233.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>【React】数据交互</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BReact%5D%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/"/>
    <id>https://wangyx233.github.io/2021/06/30/[React]数据交互/</id>
    <published>2021-06-30T02:45:57.324Z</published>
    <updated>2022-03-10T08:52:44.561Z</updated>
    
    <content type="html"><![CDATA[<p>React 的核心特征是“数据驱动视图”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UI = render(data)</span><br></pre></td></tr></table></figure><h2 id="基于-props-的单向数据流"><a href="#基于-props-的单向数据流" class="headerlink" title="基于 props 的单向数据流"></a>基于 props 的单向数据流</h2><blockquote><p>props：组件从概念上类似与 JavaScript 函数，它接受任意的入参(props)并返回用于描述页面展示内容的 React 元素。</p></blockquote><p>所谓单向数据流，指的就是当前组件的 state 以 props 的形式流动时，只能流向组件树中比自己层级更低的组件。 比如在父-子组件这种嵌套关系中，只能由父组件传 props 给子组件，而不能反过来。</p><p>基于 props 传参这种形式，我们可以轻松实现父-子通信、子-父通信和兄弟组件通信。</p><a id="more"></a><h3 id="父-子组件通信"><a href="#父-子组件通信" class="headerlink" title="父-子组件通信"></a>父-子组件通信</h3><p>React 的数据流是单向的，父组件可以直接将 this.props 传入子组件，实现父-子间的通信。</p><h3 id="子-父组件通信"><a href="#子-父组件通信" class="headerlink" title="子-父组件通信"></a>子-父组件通信</h3><p>考虑到 props 是单向的，子组件并不能直接将自己的数据塞给父组件，但 props 的形式也可以是多样的。假如父组件传递给子组件的是一个绑定了自身上下文的函数，那么子组件在调用该函数时，就可以将想要交给父组件的数据以函数入参的形式给出去，以此来间接地实现数据从子组件到父组件的流动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Child extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    text: &apos;child&apos;s text&apos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeText = () =&gt; &#123;</span><br><span class="line">    this.props.changeFatherText(this.state.text)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;child&quot;&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.changeText&#125;&gt;</span><br><span class="line">          Change father&apos;s text</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Father extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    text: &quot;Init father&apos;s text&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">  changeText = (newText) =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      text: newText</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;father&quot;&gt;</span><br><span class="line">        &lt;p&gt;&#123;`father&apos;s text：[$&#123;this.state.text&#125;]`&#125;&lt;/p&gt;</span><br><span class="line">        &lt;Child</span><br><span class="line">          changeFatherText=&#123;this.changeText&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><p>前提：兄弟组件之间共享了同一个父组件。这个前提条件使得我们可以继续利用父子组件这一层关系，将“兄弟 1 → 兄弟 2”之间的通信，转化为“兄弟 1 → 父组件”（子-父通信）、“父组件 → 兄弟 2”（父-子）通信两个步骤。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>props 进行数据传递除了适合上述三种情况外，特别复杂的情况并不推荐， 比如多层嵌套的组件结构就不适用。会浪费很多中间代码，非常繁琐，中间组件也会引入很多无意义的属性，维护成本剧增，所以层层传递 props 要不得。</p><h2 id="“发布-订阅”模式驱动数据流"><a href="#“发布-订阅”模式驱动数据流" class="headerlink" title="“发布-订阅”模式驱动数据流"></a>“发布-订阅”模式驱动数据流</h2><p>监听事件的位置和触发事件的位置是不受限的，所以如何实现呢？<br>发布-订阅模式中有两个关键的动作：事件的监听（订阅）和事件的触发（发布）：</p><ul><li>on()：负责注册事件的监听器，指定事件触发时的回调函数</li><li>emit()：负责触发事件，可以通过传参使其在触发的时候携带数据</li><li>off()：负责监听器的删除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class tryEventEmitter &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.eventMap = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  on(type, handler) &#123;</span><br><span class="line">    if (typeof handler !== &apos;function&apos;) throw new Error(&quot;请输入一个函数&quot;);</span><br><span class="line">    if (!this.eventMap[type]) this.eventMap[type] = [];</span><br><span class="line">    this.eventMap[type].push(handler);</span><br><span class="line">  &#125;</span><br><span class="line">  emit(type, params) &#123;</span><br><span class="line">    if (this.eventMap[type]) &#123;</span><br><span class="line">      this.eventMap[type].forEach((handler, index) =&gt; &#123;</span><br><span class="line">        handler(params);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  off(type, handler) &#123;</span><br><span class="line">    if (this.eventMap[type]) &#123;</span><br><span class="line">      this.eventMap[type].splice(this.eventMap[type].indexOf(handler) &gt;&gt;&gt; 0 , 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Context-API-工作流"><a href="#Context-API-工作流" class="headerlink" title="Context API 工作流"></a>Context API 工作流</h2><blockquote><p>React 16.3 开始改进。React.createContext,Provider,Consumer</p></blockquote><ul><li>Provider,数据的提供者</li><li>Consumer,数据的消费者</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const AppContext = React.createContext(defaultValue)</span><br><span class="line">const &#123; Provider, Consumer &#125; = AppContext</span><br><span class="line">&lt;Provider&gt;</span><br><span class="line">&lt;/Provider&gt;</span><br><span class="line">&lt;Consumer&gt;</span><br><span class="line">&lt;/Consumer&gt;</span><br></pre></td></tr></table></figure><p>新版改进后的 Context，在 shouldComponentUpdate 为 false 时，仍可以保持后代组件数据的一致性<br>在 Redux 的整个工作过程中，数据流是严格单向的<br>Redux 通过提供一个统一的状态容器，使得数据能够自由而有序地在任意组件之间穿梭</p><blockquote><p>PS: 可用来进行国际化</p></blockquote><h2 id="全局变量-事件-window-xxx-document-addEventListener-不推荐。不易维护，事件的顺序性"><a href="#全局变量-事件-window-xxx-document-addEventListener-不推荐。不易维护，事件的顺序性" class="headerlink" title="全局变量/事件 window.xxx, document.addEventListener() 不推荐。不易维护，事件的顺序性"></a>全局变量/事件 window.xxx, document.addEventListener() 不推荐。不易维护，事件的顺序性</h2><h2 id="Redux-提供可预测化的状态管理"><a href="#Redux-提供可预测化的状态管理" class="headerlink" title="Redux - 提供可预测化的状态管理"></a>Redux - 提供可预测化的状态管理</h2><ul><li>全局单一数据源 store，只读的</li><li>纯函数，保持稳定输出 reducer，对变化进行分发和处理</li><li>state 只读的静态类型，通过 ation 触发。action 的作用是通知 reduce 让改变发生<br>数据流是严格单向的！！！通过提供一个统一的状态容器，使得数据能够自由有序地在任意组件之间穿梭</li></ul><p>Redux-thunk，如何处理异步 Action？深入理解，手写</p><blockquote><p>技术无高低，切勿捧一踩一</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React 的核心特征是“数据驱动视图”&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UI = render(data)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;基于-props-的单向数据流&quot;&gt;&lt;a href=&quot;#基于-props-的单向数据流&quot; class=&quot;headerlink&quot; title=&quot;基于 props 的单向数据流&quot;&gt;&lt;/a&gt;基于 props 的单向数据流&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;props：组件从概念上类似与 JavaScript 函数，它接受任意的入参(props)并返回用于描述页面展示内容的 React 元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所谓单向数据流，指的就是当前组件的 state 以 props 的形式流动时，只能流向组件树中比自己层级更低的组件。 比如在父-子组件这种嵌套关系中，只能由父组件传 props 给子组件，而不能反过来。&lt;/p&gt;
&lt;p&gt;基于 props 传参这种形式，我们可以轻松实现父-子通信、子-父通信和兄弟组件通信。&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://wangyx233.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://wangyx233.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>【React】事件系统</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BReact%5D%E4%BA%8B%E4%BB%B6/"/>
    <id>https://wangyx233.github.io/2021/06/30/[React]事件/</id>
    <published>2021-06-30T02:45:57.323Z</published>
    <updated>2021-07-13T03:21:58.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h1><ol><li>事件捕获</li><li>目标阶段</li><li>事件冒泡</li></ol><h1 id="事件委托-事件代理"><a href="#事件委托-事件代理" class="headerlink" title="事件委托/事件代理"></a>事件委托/事件代理</h1><blockquote><p>把多个子元素的同一类型的监听逻辑，合并到父元素上通过一个监听函数来管理的行为，就是事件委托。<br>e.target 这个属性，指的是触发事件的具体目标，记录着事件的源头。</p></blockquote><h1 id="React事件系统"><a href="#React事件系统" class="headerlink" title="React事件系统"></a>React事件系统</h1><h2 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h2><blockquote><p>当事件在具体的DOM节点上被触发后，最终都会冒泡到document(或者ReactDOM.render绑定的元素)，document上所绑定的统一事件处理程序会将事件分发给具体的组件实例。</p></blockquote><p>合成事件是React自定义的事件对象，符合W3C规范，在底层抹平了不同浏览器的差异，在上层向开发者暴露统一的，稳定的，与DOM原生事件相同的事件接口。不必关注兼容问题，专注业务开发。<br>合成事件不是原生的事件，但是它保存了原生事件的引用，e.nativeEvent</p><blockquote><p>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault<br>比如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handleClick() &#123;</span><br><span class="line">  console.log(&apos;this is:&apos;, this);</span><br><span class="line">&#125;</span><br><span class="line">&lt;div onClick=&#123;()=&gt;this.handleClick()&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DOM事件流&quot;&gt;&lt;a href=&quot;#DOM事件流&quot; class=&quot;headerlink&quot; title=&quot;DOM事件流&quot;&gt;&lt;/a&gt;DOM事件流&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;事件捕获&lt;/li&gt;
&lt;li&gt;目标阶段&lt;/li&gt;
&lt;li&gt;事件冒泡&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 
      
    
    </summary>
    
      <category term="React" scheme="https://wangyx233.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://wangyx233.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>【React】前端路由-React Router</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BReact%5D%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
    <id>https://wangyx233.github.io/2021/06/30/[React]前端路由/</id>
    <published>2021-06-30T02:45:57.323Z</published>
    <updated>2021-07-13T03:21:58.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What"><a href="#What" class="headerlink" title="What"></a>What</h1><ul><li>切换Hash</li><li>切换Path<br>HTML5的History API中的 pushState、replaceState，还需要在服务端配置historyApiFallback<br>路由守卫<h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1></li></ul><ol><li>路由器：BrowserRouter 和 HashRouter</li></ol><ul><li>BrowserRouter 是使用 HTML 5 的 history API 来控制路由跳转的。</li><li>HashRouter 是通过 URL 的 hash 属性来控制路由跳转的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">window.location.hash</span><br><span class="line">// 监听hash变化，点击浏览器的前进后退会触发</span><br><span class="line">window.addEventListener(&apos;hashchange&apos;, function(event)&#123;</span><br><span class="line">    // 根据 hash 的变化更新内容</span><br><span class="line">&#125;,false)</span><br><span class="line">window.history.forward()  // 前进到下一页</span><br><span class="line">window.history.back() // 后退到上一页</span><br><span class="line">window.history.go(2)</span><br><span class="line">history.pushState(data[,title][,url]); // 向浏览历史中追加一条记录</span><br><span class="line">history.replaceState(data[,title][,url]); // 修改（替换）当前页在浏览历史中的信息</span><br><span class="line">window.addEventListener(&apos;popstate&apos;, function(e) &#123;</span><br><span class="line">  console.log(e)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>go、forward 和 back 等方法的调用确实会触发 popstate，但是pushState 和 replaceState 不会。不过这一点问题不大，我们可以通过自定义事件和全局事件总线来手动触发事件。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;What&quot;&gt;&lt;/a&gt;What&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;切换Hash&lt;/li&gt;
&lt;li&gt;切换Path&lt;br&gt;HTML5的History API中的 pushState、
      
    
    </summary>
    
      <category term="React" scheme="https://wangyx233.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://wangyx233.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>【React】性能优化</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BReact%5D%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://wangyx233.github.io/2021/06/30/[React]性能优化/</id>
    <published>2021-06-30T02:45:57.323Z</published>
    <updated>2021-07-13T03:21:58.397Z</updated>
    
    <content type="html"><![CDATA[<ul><li>善用 shouldComponentUpdate</li><li>PureComponent  + Immutable.js</li><li>函数组件的性能优化：React.memo 和 useMemo</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;善用 shouldComponentUpdate&lt;/li&gt;
&lt;li&gt;PureComponent  + Immutable.js&lt;/li&gt;
&lt;li&gt;函数组件的性能优化：React.memo 和 useMemo&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="React" scheme="https://wangyx233.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://wangyx233.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>【React】setState 同步 or 异步？</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BReact%5DsetState/"/>
    <id>https://wangyx233.github.io/2021/06/30/[React]setState/</id>
    <published>2021-06-30T02:45:57.322Z</published>
    <updated>2021-07-13T03:21:58.385Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在React管控下的setState是异步，而脱离React管控的则表现为同步。</p></blockquote><a id="more"></a><h1 id="异步？"><a href="#异步？" class="headerlink" title="异步？"></a>异步？</h1><p>在React自己的生命周期和合成事件中，可以拿到控制权，将状态放入队列，控制执行节奏。即isBatchingUpdates -&gt; true，进入dirtyComponents，false则循环更新dirtyComponents里的所有组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// 函数分发</span><br><span class="line">ReactComponent.prototype.setState = function (partialState, callback) &#123;</span><br><span class="line">  this.updater.enqueueSetState(this, partialState);</span><br><span class="line">  if (callback) &#123;</span><br><span class="line">    this.updater.enqueueCallback(this, callback, &apos;setState&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 将新的state放到组件的状态队列中，并且用enqueueUpdate来处理要更新的实例</span><br><span class="line">enqueueSetState: function (publicInstance, partialState) &#123;</span><br><span class="line">  // 根据 this 拿到对应的组件实例</span><br><span class="line">  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, &apos;setState&apos;);</span><br><span class="line">  // 这个 queue 对应的就是一个组件实例的 state 数组</span><br><span class="line">  var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);</span><br><span class="line">  queue.push(partialState);</span><br><span class="line">  //  enqueueUpdate 用来处理当前的组件实例</span><br><span class="line">  enqueueUpdate(internalInstance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// batchingStrategy用于批量更新的对象</span><br><span class="line">function enqueueUpdate(component) &#123;</span><br><span class="line">  ensureInjected();</span><br><span class="line">  // 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段</span><br><span class="line">  if (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    // 若当前没有处于批量创建/更新组件的阶段，则立即更新组件</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  // 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等”</span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">  if (component._updateBatchNumber == null) &#123;</span><br><span class="line">    component._updateBatchNumber = updateBatchNumber + 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  // 全局唯一的锁标识</span><br><span class="line">  isBatchingUpdates: false, // 当前未进行任何批量操作</span><br><span class="line">  // 发起更新动作的方法</span><br><span class="line">  batchedUpdates: function(callback, a, b, c, d, e) &#123;</span><br><span class="line">    // 缓存锁变量</span><br><span class="line">    var alreadyBatchingStrategy = ReactDefaultBatchingStrategy.isBatchingUpdates</span><br><span class="line">    // 把锁“锁上”</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = true // 现在正处于批量操作中，需要更新的组件暂时进入DirtyComp</span><br><span class="line">    if (alreadyBatchingStrategy) &#123;</span><br><span class="line">      callback(a, b, c, d, e)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 启动事务，将 callback 放进事务里执行</span><br><span class="line">      transaction.perform(callback, null, a, b, c, d, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 事务通过wrapper进行封装。一个wrapper包含一对initialize和close方法</span><br><span class="line">var RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: function () &#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// FLUSH_BATCHED_UPDATES在close阶段，会循环遍历所有的dirtyComponents，调用updateComponent刷新组件</span><br><span class="line">var FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)</span><br><span class="line">&#125;;</span><br><span class="line">var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];</span><br></pre></td></tr></table></figure><blockquote><p>说明：一个事务是将要执行的method使用wrapper封装起来，再通过Transaction提供的perform方法执行。在执行perform之前，先执行所有wrapper的initialize，perform（即method执行后）再执行所有的close方法。<br>总结：<br>isBatchingUpdates，这个变量在React的生命周期钩子函数及合成事件执行前，已经被改为true，所以这时调用setState不会立即生效。当函数执行完毕后，事务的close方法会再把isBatchingUpdates改为false</p></blockquote><p>为什么要异步？</p><ul><li>避免重复的re-render</li><li>批量更新，setState会在一个队列中，相同的会做合并，只针对最新的state做一次更新<br>减小频繁re-render</li></ul><h1 id="同步？"><a href="#同步？" class="headerlink" title="同步？"></a>同步？</h1><p>在React管控下的setState一定是异步的，发生了同步的行为，是有其他操作帮助setState脱离了React的管控。<br>在 addEventListener 、setTimeout、setInterval 会同步更新</p><h1 id="Why？"><a href="#Why？" class="headerlink" title="Why？"></a>Why？</h1><p>React 15为例，</p><ol><li>批量更新 - batchingStrategy(锁管理器，锁：isBatchingUpdates)</li><li>事务 Transaction 机制，Transaction创建一个黑盒，该黑盒能封装任何的方法。</li><li>保持内部一致性，props的更新（props的更新来自于父组件state的改变）</li><li>支持异步渲染，启用并发更新</li></ol><blockquote><p>PS: React 17之前是通过isBatchingUpdates判断，之后是lanes 算法的优先级来区分</p></blockquote><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol><li><p>合成事件 -&gt; 事件委托<br>React 17 版本之前，事件监听是在document上，DOM事件触发后冒泡到document，React找到对应的组件，造出一个合成事件，并按组件数模拟一遍事件冒泡。<br>React 17 版本，事件委托不在挂载document上，而是挂在DOM容器上，即ReactDom.Render调用的节点。</p></li><li><p>看看输出什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Test extends React.Component &#123;</span><br><span class="line">  state  = &#123;</span><br><span class="line">      count: 0</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class="line">    console.log(this.state.count); // 0</span><br><span class="line">    this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class="line">    console.log(this.state.count); // 0</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class="line">      console.log(this.state.count); // 2</span><br><span class="line">      this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class="line">      console.log(this.state.count); // 3</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在React管控下的setState是异步，而脱离React管控的则表现为同步。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="React" scheme="https://wangyx233.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://wangyx233.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>【React】ReactDom.render</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BReact%5DReactDOM.render/"/>
    <id>https://wangyx233.github.io/2021/06/30/[React]ReactDOM.render/</id>
    <published>2021-06-30T02:45:57.322Z</published>
    <updated>2021-07-13T03:21:58.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ReactDom-render-调用栈逻辑"><a href="#ReactDom-render-调用栈逻辑" class="headerlink" title="ReactDom.render 调用栈逻辑"></a>ReactDom.render 调用栈逻辑</h1><ul><li>scheduleUpdateOnFiber</li><li>commitRoot 正式渲染DOM</li></ul><ol><li>初始化阶段 - 完成Fiber🌲基本实体的构建</li><li>render阶段 - 深度优先搜索过程</li><li>commit阶段</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ReactDom-render-调用栈逻辑&quot;&gt;&lt;a href=&quot;#ReactDom-render-调用栈逻辑&quot; class=&quot;headerlink&quot; title=&quot;ReactDom.render 调用栈逻辑&quot;&gt;&lt;/a&gt;ReactDom.render 调用栈逻辑&lt;/
      
    
    </summary>
    
      <category term="React" scheme="https://wangyx233.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://wangyx233.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>【React】Why JSX?</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BReact%5DJSX/"/>
    <id>https://wangyx233.github.io/2021/06/30/[React]JSX/</id>
    <published>2021-06-30T02:45:57.321Z</published>
    <updated>2022-03-10T08:52:15.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h1><ul><li>JSX 的本质是什么，它和 JS 之间到底是什么关系？</li><li>为什么要用 JSX？不用会有什么后果？</li><li>JSX 背后的功能模块是什么，这个功能模块都做了哪些事情？</li></ul><a id="more"></a><h1 id="What？"><a href="#What？" class="headerlink" title="What？"></a>What？</h1><blockquote><p>JSX 是 JavaScript 的一个语法扩展，实质是快速构建页面结构的语法糖<br>ReactDOM 在渲染所有输入内容之前，默认会进行转义，可以有效地防止 XSS 攻击</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">React.creatElement(type, config, children)  // 格式化数据，调用ReactElement创建虚拟DOM</span><br><span class="line"></span><br><span class="line">export function createElement(type, config, children) &#123;</span><br><span class="line">  ....</span><br><span class="line">  return ReactElement(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    ReactCurrentOwner.current,</span><br><span class="line">    props,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const ReactElement = function(type, key, ref, self, source, owner, props) &#123;</span><br><span class="line">  const element = &#123;</span><br><span class="line">    // REACT_ELEMENT_TYPE是一个常量，用来标识该对象是一个ReactElement</span><br><span class="line">    $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    // 内置属性赋值</span><br><span class="line">    type: type,</span><br><span class="line">    key: key,</span><br><span class="line">    ref: ref,</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    // 记录创造该元素的组件</span><br><span class="line">    _owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line">  return element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(element, container, [callback]) // 真实的DOM</span><br></pre></td></tr></table></figure><h1 id="Why？"><a href="#Why？" class="headerlink" title="Why？"></a>Why？</h1><p>代码变得更为简洁，而且代码结构层次更为清晰<br>JSX 层次分明，嵌套逻辑清晰。用 JSX 降低学习成本，提高研发效率和研发体验</p><h1 id="How？"><a href="#How？" class="headerlink" title="How？"></a>How？</h1><p>是什么 -&gt; 不用会怎样 -&gt; 用了有什么好处<br>JSX 是一个 JavaScript 的语法扩展。主要用于声明 React 元素，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 React.createElement 的一种语法糖。<br>Babel 读取代码并解析，生成 AST，再将 AST 传入插件层进行转换，在转换时就可以将 JSX 的结构转换为 React.createElement 的函数</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JSX 的本质是什么，它和 JS 之间到底是什么关系？&lt;/li&gt;
&lt;li&gt;为什么要用 JSX？不用会有什么后果？&lt;/li&gt;
&lt;li&gt;JSX 背后的功能模块是什么，这个功能模块都做了哪些事情？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="React" scheme="https://wangyx233.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://wangyx233.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>【React】React-Hooks</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BReact%5DReact-Hooks/"/>
    <id>https://wangyx233.github.io/2021/06/30/[React]React-Hooks/</id>
    <published>2021-06-30T02:45:57.321Z</published>
    <updated>2022-03-10T08:51:49.028Z</updated>
    
    <content type="html"><![CDATA[<p>React-Hooks 自 React 16.8 以来才真正被推而广之</p><h1 id="What-amp-Why"><a href="#What-amp-Why" class="headerlink" title="What &amp; Why"></a>What &amp; Why</h1><h2 id="类组件-Class-Component-vs-函数-无状态组件"><a href="#类组件-Class-Component-vs-函数-无状态组件" class="headerlink" title="类组件 Class Component vs 函数/无状态组件"></a>类组件 Class Component vs 函数/无状态组件</h2><blockquote><p>所谓类组件，就是基于 ES6 Class 这种写法，通过继承 React.Component 得来的 React 组件<br>函数组件/无状态组件，在没有 Hooks 加持的条件加，函数组件无法维护自己的 state</p></blockquote><p>二者并没有优劣，只是根据不同的场景采用不同的形式。</p><blockquote><p>区别：函数组件会捕获 render 内部的状态。面向对象与函数式的不同。this 调用的区别<br>注：对于函数组件，props 会保持渲染结果符合预期。更利于逻辑拆分与重用组件<br>为了回归 UI = render(data)的本质，所以需要补齐函数组件所缺乏的的类组件的能力，React Hooks 应运而生。即一套能够使函数组件更强大、更灵活的“钩子”<br>ex.</p></blockquote><ul><li>useState() 为函数组件引入了 state，const [state, setState] = useState(initialState)</li><li>useEffect() 允许函数执行副作用操作，即弥补了生命周期的缺失，比如 componentDidMount、componentDidUpdate 和 componentWillUnmount。操作 DOM、订阅事件、调用外部 API。<br>useEffect(callBack, [])，返回的函数成为“清除函数 ”</li><li>callback 是否有 return,决定是否在卸载阶段执行。有 return 则会在挂载执行 return 之前的内容，卸载阶段执行 return 的函数。即 useEffect 回调中返回了一个函数，那它会被作为清除函数处理。</li><li>[],判断是否每次页面渲染后都执行。如果 []不为空，React 会在每次渲染前对比前后两次的渲染，查看数组内部是否有变量发生了更新。注意引用类型的比较可能因为变化导致判断结果不同。</li><li>useLayoutEffect() 同 useEffect 都是用来处理副作用的，底层函数签名也是一致的，都是 mountEffectImpl，在使用上也没有什么区别。但 useEffect 是异步调用的，useLayoutEffect 则是在 DOM 变更后同步调用，主要避免页面闪烁、调整样式、处理 DOM，但正是由于同步操作，所以避免在 useLayoutEffect 中做计算量大耗时的任务，以免出现阻塞。<br>Hooks 开发需要抛弃生命周期的思考模式，以 effects 的角度重新思考</li></ul><h2 id="所以-Why"><a href="#所以-Why" class="headerlink" title="所以 Why?"></a>所以 Why?</h2><p>优势：</p><ul><li>告别难以理解的 Class，this 和生命周期，降低学习成本。不必用实践层面的约束解决设计层面的问题</li><li>解决业务逻辑难以拆分的问题。更好的进行逻辑拆分，避免重复冗余的代码。</li><li>使状态逻辑复用变得简单可行。状态复用 HOC（高阶组件）</li></ul><p>局限：</p><ul><li>函数补齐能力还需继续完善，声明周期还有未纳入 Hooks 中的</li><li>复杂的，耦合和自由。有严格的规则约束</li><li>常量声明</li></ul><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ol><li>只在 React 函数中调用 Hook</li><li>不要在循环，条件和嵌套中用 Hook。why？<br>eslint-plugin-react-hooks</li></ol><p>以 setState 为例，</p><ul><li>mountState，初始化 hook，将 hook 相关的所有信息都收敛在一个 hook 对象里，hook 对象之间以单向链表的形式相互串联。</li><li>updateState，按顺序去遍历之前构造好的链表，然后取相应的数据进行渲染。重点：按“顺序”去修改！</li></ul><p>PS:<br>心智模型：引用唐纳德·诺曼，是指用户头脑中对一个产品应该具有的概念和行为的知识。这个知识可能来源于用户以前使用类似产品的沉淀，或者用户根据使用该产品要达到的目标而对产品概念和行为的一种期望。</p><h1 id="Q-amp-A-如何设计-React-的组件？"><a href="#Q-amp-A-如何设计-React-的组件？" class="headerlink" title="Q&amp;A: 如何设计 React 的组件？"></a>Q&amp;A: 如何设计 React 的组件？</h1><blockquote><p>展示组件的复用性更强，灵巧组件则更专注与业务本身</p></blockquote><ul><li>展示组件： 无状态组件，只做展示，独立运行</li></ul><ol><li>代理组件</li><li>样式组件</li><li>布局组件</li></ol><ul><li>灵巧组件： 有状态组件，主要进行业务逻辑和数据状态处理</li></ul><ol><li>容器组件</li><li>高阶组件</li></ol><ul><li>逻辑复用</li><li>链式调用</li><li>渲染劫持</li><li>缺陷：丢失静态函数，refs 属性不能透传</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React-Hooks 自 React 16.8 以来才真正被推而广之&lt;/p&gt;
&lt;h1 id=&quot;What-amp-Why&quot;&gt;&lt;a href=&quot;#What-amp-Why&quot; class=&quot;headerlink&quot; title=&quot;What &amp;amp; Why&quot;&gt;&lt;/a&gt;What 
      
    
    </summary>
    
      <category term="React" scheme="https://wangyx233.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://wangyx233.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>【JS基础】浏览器中JavaScript执行机制</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BJS%E5%9F%BA%E7%A1%80%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%ADJavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>https://wangyx233.github.io/2021/06/30/[JS基础]浏览器中JavaScript的执行机制/</id>
    <published>2021-06-30T02:45:57.320Z</published>
    <updated>2021-07-13T03:21:58.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量提升（Hoisting）"><a href="#变量提升（Hoisting）" class="headerlink" title="变量提升（Hoisting）"></a>变量提升（Hoisting）</h2><h3 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h3><blockquote><p>JavaScript代码执行过程中，JS引擎会把变量声明和函数声明部分提升到代码的开头，并不是物理性的移动，实际中代码并没有改变，而是JS引擎在编译阶段放进内存的。<br>一段JS代码在执行时，先经过编译，编译完成后，再进入执行阶段。<br>编译后的内容分为两部分：执行上下文（Execution context）和可执行代码。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">showName()</span><br><span class="line">console.log(myname)</span><br><span class="line">var myname = &apos;xxx&apos;</span><br><span class="line">function showName() &#123;</span><br><span class="line">  console.log(&apos;函数showName被执行&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// 编译</span><br><span class="line">var myname;</span><br><span class="line">function showName() &#123; //函数定义放到堆中，变量环境中showName指向该函数</span><br><span class="line">  console.log(&apos;函数showName被执行&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行</span><br><span class="line">showName()</span><br><span class="line">console.log(myname)</span><br><span class="line">myname = &apos;xxx&apos;</span><br></pre></td></tr></table></figure><h3 id="QA-代码中相同的变量和函数如何处理？"><a href="#QA-代码中相同的变量和函数如何处理？" class="headerlink" title="QA 代码中相同的变量和函数如何处理？"></a>QA 代码中相同的变量和函数如何处理？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&apos;aaa&apos;);</span><br><span class="line">&#125;</span><br><span class="line">showName();</span><br><span class="line">function showName() &#123;</span><br><span class="line">    console.log(&apos;bbb&apos;);</span><br><span class="line">&#125;</span><br><span class="line">showName();</span><br></pre></td></tr></table></figure><a id="more"></a><p>前者会被覆盖</p><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>执行上下文：</p><ul><li>全局上下文</li><li>函数上下文</li></ul><h3 id="What-1"><a href="#What-1" class="headerlink" title="What?"></a>What?</h3><blockquote><p>利用栈的结构来管理上下文，调用栈是JS引擎追踪函数执行的一个机制</p></blockquote><ul><li>Chrome 浏览器Sources -&gt; Call Stack 可查看</li><li>console.trace()</li></ul><h3 id="栈溢出（Stack-Overflow）"><a href="#栈溢出（Stack-Overflow）" class="headerlink" title="栈溢出（Stack Overflow）"></a>栈溢出（Stack Overflow）</h3><blockquote><p>调用栈是有大小的，当入栈的执行上下文超过一定数目，JS引擎就会报错，即为栈溢出 {超过了最大栈调用大小（Maximum call stack size exceeded）}</p></blockquote><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><blockquote><p>变量和函数可以访问的范围，即作用域控制着变量和函数的可见性和生命周期</p></blockquote><p>ES6</p><ul><li>全局作用域</li><li>函数作用域，作用于函数内部</li><li>块级作用域，作用于{}内部，let，const</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function letTest() &#123;</span><br><span class="line">  let x = 1;</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    let x = 2;  // 不同的变量</span><br><span class="line">    console.log(x);  // 2</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(x);  // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用块内声明的变量不影响块外面的变量</p><h3 id="How-如何支持块级作用域的"><a href="#How-如何支持块级作用域的" class="headerlink" title="How? 如何支持块级作用域的"></a>How? 如何支持块级作用域的</h3><p>代码编译生成执行上下文时，</p><ul><li>var 声明的变量会放到变量环境</li><li>let / const 声明的变量被放到词法环境（Lexical Environment）</li></ul><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>在每个执行上下文中都包含了一个外部引用，用来指向外部的执行上下文，这个外部引用成为outer。</p><blockquote><p>当一个变量使用，会在当前执行上下文中寻找，如果没有则会在outer指向的执行上下文中寻找，这个查找链条即为作用域链。在JS执行过程中，作用域链是由词法作用域决定的。</p></blockquote><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><blockquote><p>词法作用域是指作用域由代码中函数声明的位置来决定的，词法作用域是静态的作用域，由此可以预测代码运行过程中的行为。</p></blockquote><p>注：词法作用域是在代码阶段就决定好的，和函数怎样调用没有关系</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p>根据词法作用域的规则，内部函数总能访问外部函数中声明的变量，当通过调用一个外部返回一个内部函数后，即使外部函数已经执行结束了，但内部函数引用外部函数的变量仍保存在内存中，这些变量的集合称之为闭包。</p></blockquote><p>Chrome / Sources / Scope 顺序 Local -&gt; Closure -&gt; Global</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>注： 作用域链和this不同</p><blockquote><p>this是和执行上下文绑定的，每个执行上下文都有一个this</p></blockquote><ul><li>全局执行上下文中的this -&gt; Window</li><li>函数执行上下文中的this，谁调用this就指向谁，箭头函数不会创建自己的执行上下文，所以this为外部函数的this<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></li></ul><h3 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h3><ul><li>call，foo.call(obj)</li><li>bind</li><li>apply</li><li>对象调用方法设置，使用对象来调用内部的方法，该方法的this指向对象</li><li>构造函数中设置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function CreateObj()&#123;</span><br><span class="line">  this.name = &quot; test &quot;</span><br><span class="line">&#125;</span><br><span class="line">var myObj = new CreateObj()</span><br></pre></td></tr></table></figure><p>通过new来创建对象的过程，this指向新对象本身</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var tempObj = &#123;&#125;</span><br><span class="line">CreateObj.call(tempObj)</span><br><span class="line">return tempObj</span><br></pre></td></tr></table></figure><h3 id="this存在的问题"><a href="#this存在的问题" class="headerlink" title="this存在的问题"></a>this存在的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">  name : &quot; test &quot;,</span><br><span class="line">  showThis: function()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    function bar()&#123;console.log(this)&#125; // Window</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis() // myObj</span><br></pre></td></tr></table></figure><ol><li>嵌套函数的this不会从外部函数中继承，根据自身的执行上下文，有自己的this</li></ol><p>如果想要继承怎么办？</p><ul><li>如果想在内部函数中用外部函数的this，可以用一个变量中转一番，把外部的this存为一个变量，在内部函数中使用</li><li>使用箭头函数</li></ul><ol start="2"><li>普通函数中的this指向Window<br>在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是 undefined</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量提升（Hoisting）&quot;&gt;&lt;a href=&quot;#变量提升（Hoisting）&quot; class=&quot;headerlink&quot; title=&quot;变量提升（Hoisting）&quot;&gt;&lt;/a&gt;变量提升（Hoisting）&lt;/h2&gt;&lt;h3 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;What?&quot;&gt;&lt;/a&gt;What?&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;JavaScript代码执行过程中，JS引擎会把变量声明和函数声明部分提升到代码的开头，并不是物理性的移动，实际中代码并没有改变，而是JS引擎在编译阶段放进内存的。&lt;br&gt;一段JS代码在执行时，先经过编译，编译完成后，再进入执行阶段。&lt;br&gt;编译后的内容分为两部分：执行上下文（Execution context）和可执行代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;showName()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(myname)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var myname = &amp;apos;xxx&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function showName() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&amp;apos;函数showName被执行&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 编译&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var myname;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function showName() &amp;#123; //函数定义放到堆中，变量环境中showName指向该函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&amp;apos;函数showName被执行&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 执行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;showName()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(myname)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myname = &amp;apos;xxx&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;QA-代码中相同的变量和函数如何处理？&quot;&gt;&lt;a href=&quot;#QA-代码中相同的变量和函数如何处理？&quot; class=&quot;headerlink&quot; title=&quot;QA 代码中相同的变量和函数如何处理？&quot;&gt;&lt;/a&gt;QA 代码中相同的变量和函数如何处理？&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function showName() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(&amp;apos;aaa&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;showName();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function showName() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(&amp;apos;bbb&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;showName();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>【JS基础】异步</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BJS%E5%9F%BA%E7%A1%80%5D%E5%BC%82%E6%AD%A5/"/>
    <id>https://wangyx233.github.io/2021/06/30/[JS基础]异步/</id>
    <published>2021-06-30T02:45:57.320Z</published>
    <updated>2021-07-13T03:21:58.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ul><li>同步和异步的区别</li><li>手写Promise</li><li>前端异步的场景</li><li>event loop（事件循环）的机制，画图</li><li>async/await</li><li>Promise的三种状态，then，catch的连接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;, 1000);</span><br><span class="line">console.log(3)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(5)</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>why?<br>遇到等待（请求，定时任务）不能卡住<br>单线程-&gt;异步<br>JS是单线程，异步不会阻塞代码的执行，同步会阻塞代码的执行</p><p>why Promise?</p><ul><li>编码习惯，回调</li><li>callback hell -&gt; 管道串联</li></ul><ol><li>event loop 事件循环</li></ol><ul><li>同步代码在call stack一步一步执行</li><li>遇到异步代码先记录下来</li><li>等到“时机成熟”，把异步函数放到call queue中</li><li>如果call stack 为空（即同步代码执行完）Event Loop开始工作</li><li>轮询查找call queue，如果有则移到call stack 执行</li><li>然后继续查找</li></ul><p>由于JS是单线程的，异步(setTimeout, ajax)，DOM事件也都是基于event loop</p><ol start="2"><li>Promise<ul><li>三种状态，变化是不可逆的，只能从pending变化。且状态的改变和是否执行 resolve，reject有关<ul><li>pending</li><li>resolved</li><li>rejected</li></ul></li><li>状态的变化和表现<ul><li>pending状态，不会触发then和catch</li><li>resolved状态，会触发后续的then回调</li><li>rejected状态，会触发后续的catch回调<blockquote><p>resolved状态和rejected状态可以直接触发，如Promise.resolve()，Promise.reject()</p></blockquote></li></ul></li><li>then，catch链式调用对状态的影响 <ul><li>then 返回一个Promise，如果有报错状态为rejected，正常则状态为resolved</li><li>catch 正常状态返回resolved，里面有报错则返回rejected</li></ul></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(1) // 1</span><br><span class="line">&#125;).catch(() =&gt; &#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(3) //3</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(1) // 1</span><br><span class="line">    throw new Error(&apos;err1&apos;)</span><br><span class="line">&#125;).catch(() =&gt; &#123;</span><br><span class="line">    console.log(2) // 2</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(3) //3</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(1) // 1</span><br><span class="line">    throw new Error(&apos;err1&apos;)</span><br><span class="line">&#125;).catch(() =&gt; &#123;</span><br><span class="line">    console.log(2) // 2</span><br><span class="line">&#125;).catch(() =&gt; &#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>async/await</li></ol><ul><li>callback hell</li><li>Promise 回调函数</li><li>async/await同步的语法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;同步和异步的区别&lt;/li&gt;
&lt;li&gt;手写Promise&lt;/li&gt;
&lt;li&gt;前端异步的场景&lt;/li&gt;
&lt;li&gt;event loop（事件循环）的机制，画图&lt;/li&gt;
&lt;li&gt;async/await&lt;/li&gt;
&lt;li&gt;Promise的三种状态，then，catch的连接&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;console.log(1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setTimeout(() =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, 1000);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setTimeout(() =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(4)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(5)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>【JS基础】原型与原型链</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BJS%E5%9F%BA%E7%A1%80%5D%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://wangyx233.github.io/2021/06/30/[JS基础]原型与原型链/</id>
    <published>2021-06-30T02:45:57.319Z</published>
    <updated>2021-07-13T03:21:58.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol><li>如何判断一个变量是不是数组？</li><li>class的原型本质</li></ol><a id="more"></a><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><ul><li>constructor</li><li>属性</li><li>方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">    constructor(content) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    hello() &#123;</span><br><span class="line">        console.log(`hello $&#123;this.content&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const newDemo = new Demo(&apos;world&apos;);</span><br><span class="line">newDemo.hello();</span><br></pre></td></tr></table></figure></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>extends</li><li>super</li><li>扩展/重写方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class SubDemo extends Demo&#123;</span><br><span class="line">    constructor(content, subcontent) &#123;</span><br><span class="line">        super(content);</span><br><span class="line">        this.subcontent = subcontent;</span><br><span class="line">    &#125;</span><br><span class="line">    show() &#123;</span><br><span class="line">        console.log(`hello $&#123;this.content&#125; $&#123;this.subcontent&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const sDemo = new SubDemo(&apos;world&apos;, &apos;hoho&apos;);</span><br><span class="line">sDemo.hello();</span><br><span class="line">sDemo.show();</span><br></pre></td></tr></table></figure><h2 id="类型判断-instanceof"><a href="#类型判断-instanceof" class="headerlink" title="类型判断 instanceof"></a>类型判断 instanceof</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sDemo instanceof SubDemo // true</span><br><span class="line">sDemo instanceof Demo // true</span><br><span class="line">sDemo instanceof Object // true</span><br><span class="line"></span><br><span class="line">[] instanceof Array // true</span><br><span class="line">[] instanceof Object // true</span><br></pre></td></tr></table></figure><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typeof Demo // &apos;function&apos;</span><br><span class="line">typeof SubDemo // &apos;function&apos;</span><br><span class="line"></span><br><span class="line">// 隐式原型，显示原型</span><br><span class="line">console.log(sDemo.__proto__)</span><br><span class="line">console.log(SubDemo.prototype)</span><br><span class="line">console.log(sDemo.__proto__ === SubDemo.prototype) // true</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 原型关系</span><br><span class="line"></span><br><span class="line">* 每个class都有显示原型prototype</span><br><span class="line">* 每个实例都有隐式原型__proto__</span><br><span class="line">* 实例的__proto__指向对应class的prototype</span><br><span class="line"></span><br><span class="line">### 基于原型的执行规则</span><br><span class="line"></span><br><span class="line">&gt; 实例获取属性和方法时，先从自身的属性和方法中寻找，如果找不到则自动到__proto__中查找</span><br><span class="line"></span><br><span class="line">## 原型链</span><br></pre></td></tr></table></figure><p>console.log(SubDemo.prototype.<strong>proto</strong>)<br>console.log(Demo.prototype === SubDemo.prototype.<strong>proto</strong>) // true</p><p>Demo.prototype.<strong>proto</strong> === Object.prototype<br>Object.prototype.<strong>proto</strong> === null</p><pre><code>&gt; 所以 variable instanceof 构造函数类型，即根据原型链看variable的隐式原型__proto__是不是在其判断的显示原型上{% img /gallery/prototype_demo.png %}## 实践-简易实现jQuery考虑插件/扩展项class jQuery {    constructor(selector) {}}- 插件，写在其显示原型上jQuery.prototype.plugin = () =&gt; {}- 扩展项，可在继承其基础上，再重写新的方法class myjQuery extends jQuery {    constructor(selector) {        super(selector)    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;如何判断一个变量是不是数组？&lt;/li&gt;
&lt;li&gt;class的原型本质&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>【JS基础】变量类型与比较</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BJS%E5%9F%BA%E7%A1%80%5D%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%AF%94%E8%BE%83/"/>
    <id>https://wangyx233.github.io/2021/06/30/[JS基础]变量类型与比较/</id>
    <published>2021-06-30T02:45:57.319Z</published>
    <updated>2021-07-13T03:21:58.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol><li>typeof 能判断什么类型？</li><li>=== vs == 有什么不同？</li><li>值类型与引用类型有什么区别？</li><li>手写深拷贝？</li></ol><a id="more"></a><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="值类型-引用类型"><a href="#值类型-引用类型" class="headerlink" title="值类型 | 引用类型"></a>值类型 | 引用类型</h2><blockquote><p>值类型包括，string，number，boolean，undefined，symbol 值类型是存储在栈中的，存的是值本身</p></blockquote><blockquote><p>常见的引用类型包括，object，array，null(特殊的引用类型，只向空地址)，function(特殊的引用类型，也可以独立为函数类型)  引用类型则是在栈中存变量以及变量指向的内存地址，实际的值是由内存地址指向存在堆中的，普通的浅拷贝，复制的是栈中的内容（考虑到存储，性能）</p></blockquote><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><ul><li>能区分是值类型还是引用类型，并且能够区分具体的值类型，但是无法细化区分引用类型</li><li>能识别出function类型</li></ul><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>递归实现，function内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">https://codepen.io/yx233/pen/oNzKvbg</span><br><span class="line"></span><br><span class="line">function deepClone(obj) &#123;</span><br><span class="line">  if(typeof obj !== &apos;object&apos; || obj == null) return obj;</span><br><span class="line">  let res = obj instanceof Array ? [] : &#123;&#125;;</span><br><span class="line">  for(let key in obj) &#123;</span><br><span class="line">    if(obj.hasOwnProperty(key)) res[key] = deepClone(obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>字符串拼接，和字符串的加法</li><li>==，类型转换，null == undefined // true, 除了 == null(=== null || === undefined)，其他情况用===判断</li><li>if，逻辑判断，判断的是truely变量 !!a === true，falsely变量 !!b === false。 &amp;&amp; || 返回终止前的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">👇为falsely变量，除此以外为truely变量</span><br><span class="line">!!0 === false</span><br><span class="line">!!null === false</span><br><span class="line">!!undefined === false</span><br><span class="line">!!NaN === false</span><br><span class="line">!!&apos;&apos; === false</span><br><span class="line">!!false === false</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;typeof 能判断什么类型？&lt;/li&gt;
&lt;li&gt;=== vs == 有什么不同？&lt;/li&gt;
&lt;li&gt;值类型与引用类型有什么区别？&lt;/li&gt;
&lt;li&gt;手写深拷贝？&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>【JS基础】事件</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BJS%E5%9F%BA%E7%A1%80%5D%E4%BA%8B%E4%BB%B6/"/>
    <id>https://wangyx233.github.io/2021/06/30/[JS基础]事件/</id>
    <published>2021-06-30T02:45:57.318Z</published>
    <updated>2021-07-13T03:21:58.353Z</updated>
    
    <content type="html"><![CDATA[<ul><li>事件冒泡的流程</li><li>通用的事件监听</li><li>无限下拉的图片列表，如何监听每个图片的点击</li></ul><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>事件绑定</li><li>事件冒泡</li><li>事件代理</li></ul><ol><li><p>事件绑定，事件冒泡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function bindEvent(elem, type, selecotr, fn) &#123;</span><br><span class="line">    if(fn == null) &#123;</span><br><span class="line">        fn = selector;</span><br><span class="line">        selector = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elem.addEventListener(type, e =&gt; &#123;</span><br><span class="line">        let target;</span><br><span class="line">        if(selector) &#123; // 需要代理</span><br><span class="line">            target = e.target;</span><br><span class="line">            if(target.matches(selecotr)) &#123; // 判断是否是触发元素</span><br><span class="line">                fn.call(target, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            fn.call(target, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">const btn = document.getElementById(&apos;btn&apos;);</span><br><span class="line">bindEvent(btn, &apos;click&apos;, event =&gt; &#123;</span><br><span class="line">    console.log(event.target) // 获取触发的元素 </span><br><span class="line">    event.preventDefault() // 取消默认事件</span><br><span class="line">    event.stopPropagation() // 阻止冒泡</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>事件代理</p><ul><li>代码简洁，事件绑定到触发的父元素上</li><li>减少浏览器内存占用</li><li>不要滥用</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;事件冒泡的流程&lt;/li&gt;
&lt;li&gt;通用的事件监听&lt;/li&gt;
&lt;li&gt;无限下拉的图片列表，如何监听每个图片的点击&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>【JS基础】作用域和闭包</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BJS%E5%9F%BA%E7%A1%80%5D%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/"/>
    <id>https://wangyx233.github.io/2021/06/30/[JS基础]作用域和闭包/</id>
    <published>2021-06-30T02:45:57.318Z</published>
    <updated>2022-02-16T05:45:08.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol><li>this 的不同应用场景，以及取值</li><li>手写 bind 函数</li><li>闭包的场景</li></ol><a id="more"></a><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol><li>作用域，一个变量的合法使用范围</li></ol><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域（ES6）TDZ（Temporal Dead Zone）<blockquote><p>自由变量，一个变量在当前作用域没有定义却被使用了，需要沿着作用域一层一层向上查找，找到为止，如果全局作用域都没有找到，那就是 xxxx is not defined 咯</p></blockquote></li></ul><ol start="2"><li>闭包：作用域应用的特殊情况</li></ol><ul><li>函数作为参数被传递</li><li>函数作为返回值被返回<blockquote><p>自由变量的查找是在函数定义的地方，向上级作用域查找，而不是在函数执行的地方查找！</p></blockquote></li></ul><ol start="3"><li>this，函数执行的时候确认的</li></ol><ul><li>普通函数，setTimeout 话看执行时刻</li><li>call apply bind: call,apply 原函数直接调用，bind 会返回一个新的函数</li><li>对象方法</li><li>class</li><li>箭头函数：取上级作用域的 this</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">    name: &apos;xxx&apos;,</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;,</span><br><span class="line">    wait() &#123;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            console.log(this)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    waitTwo() &#123;</span><br><span class="line">        setTimeout(()=&gt; &#123;</span><br><span class="line">            console.log(this)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><ul><li>手写 bind 函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind1 = function () &#123;</span><br><span class="line">    // 获取参数</span><br><span class="line">    const args = Array.prototype.slice.call(arguments);</span><br><span class="line">    const _this = args.shift();</span><br><span class="line">    const self = this;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return self.apply(_this, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;this 的不同应用场景，以及取值&lt;/li&gt;
&lt;li&gt;手写 bind 函数&lt;/li&gt;
&lt;li&gt;闭包的场景&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>【WebAPI】DOM</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BJSWebAPI%5DDOM/"/>
    <id>https://wangyx233.github.io/2021/06/30/[JSWebAPI]DOM/</id>
    <published>2021-06-30T02:45:57.317Z</published>
    <updated>2021-07-13T03:21:58.426Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>DOM -&gt; Document Object Model</p></blockquote><ul><li>DOM数据结构</li><li>DOM常用的API</li><li>attr和property的区别</li><li>如何一次插入多个DOM节点</li></ul><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>DOM 本质</li><li>DOM 节点操作</li><li>DOM 结构操作</li><li>DOM 性能</li></ul><ol><li>DOM本质：从HTML解析出来的一棵树</li><li>DOM节点<ul><li>节点获取的常见API</li><li>通过js修改页面渲染结构：节点property，直接通过属性修改，如：dom.style.width = xxxx,dom.className = ‘xxx’</li><li>修改的是标签的属性：节点attribute，通过getAttibute(‘style’, ‘font-size:16px’),setAttribute()<blockquote><p>property： 修改JS对象属性，不会体现在html中；attribute：修改html属性，改变html结构。都有可能引起DOM重新渲染，可以先优先用property</p></blockquote></li></ul></li><li>DOM结构<ul><li>新增/插入节点，createElement()，appendChild()未存在的节点直接创建，已存在的移动。</li><li>删除节点：removeChild()</li></ul></li><li>DOM性能<ul><li>避免频繁的DOM操作</li><li>对DOM查询做缓存，get操作用变量缓存一下</li><li>将频繁操作改为一次操作，通过document.createDocumentFragment() 创建一个文档片段，将高频操作插入到文档片段中，最后再把文档片段插入</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;DOM -&amp;gt; Document Object Model&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;DOM数据结构&lt;/li&gt;
&lt;li&gt;DOM常用的API&lt;/li&gt;
&lt;li&gt;attr和property的区别&lt;/li&gt;
&lt;li&gt;如何一
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>【WebAPI】存储</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BJSWebAPI%5Dcookie/"/>
    <id>https://wangyx233.github.io/2021/06/30/[JSWebAPI]cookie/</id>
    <published>2021-06-30T02:45:57.317Z</published>
    <updated>2021-07-13T03:21:58.364Z</updated>
    
    <content type="html"><![CDATA[<ul><li>介绍cookie、localStorage、sessionStorage区别</li></ul><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ol><li><p>cookie</p><ul><li>通过;分割的字符串，每一部分都是key=value的形式</li><li>http请求的一部分，用于浏览器和服务端通讯的</li><li>document.cookie修改，默认每次追加或者修改一个key/value</li><li>限制：最大4KB，每次http请求都需要发送到服务端，api太简陋</li></ul></li><li><p>localStorage、sessionStorage</p><ul><li>HTML5专门为存储设计的，最大可存储5M / pre host</li><li>API：getItem() setItem() 存储的为字符串的形式，所以其他格式的数据要注意</li><li>和http请求没关系</li><li>localStorage 永久存储，除非手动或者代码删除；sessionStorage只存在于当前会话，页面关闭清空</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;介绍cookie、localStorage、sessionStorage区别&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>【WebAPI】AJAX</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BJSWebAPI%5DAJAX/"/>
    <id>https://wangyx233.github.io/2021/06/30/[JSWebAPI]AJAX/</id>
    <published>2021-06-30T02:45:57.316Z</published>
    <updated>2021-07-13T03:21:58.446Z</updated>
    
    <content type="html"><![CDATA[<ul><li>手写一个简易的ajax</li><li>跨域</li></ul><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>XMLHttpRequest</li><li>状态码</li><li>跨域： 同源策略，跨域解决方案</li></ul><h2 id="1-XMLHttpRequest"><a href="#1-XMLHttpRequest" class="headerlink" title="1. XMLHttpRequest"></a>1. XMLHttpRequest</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;method&apos;, &apos;url&apos;, &apos;true/false&apos;); // 是否是异步</span><br><span class="line">xhr.onreadystatechange = function () &#123;</span><br><span class="line">    if(xhr.readyState === 4) &#123;</span><br><span class="line">        if(xhr.status === 200) &#123;</span><br><span class="line">            console.log(JSON.parse(xhr.responseText))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(null)</span><br><span class="line">// post</span><br><span class="line">xhr.send(JSON.stringify(&#123;&#125;))</span><br></pre></td></tr></table></figure><p>可以改成promise的情况</p><ul><li><p>xhr.readyState</p><ul><li>0 (未初始化)没有调用send()方法</li><li>1 (载入)已调用send()，正在发送请求</li><li>2 (载入完成)send()方法执行完成，已经接收到全部响应内容</li><li>3 (交互)正在解析响应内容</li><li>4 (完成)响应内容解析完成，可在客户端调用</li></ul></li><li><p>xhr.status http状态码</p><ul><li>2xx 成功处理请求</li><li>3xx 重定向，浏览器直接跳转 301：永久重定向 302：临时重定向 304：资源未改变，用缓存</li><li>4xx 客户端请求错误，404：not found 403：客户端没有权限</li><li>5xx 服务端错误</li></ul></li></ul><h2 id="2-跨域"><a href="#2-跨域" class="headerlink" title="2. 跨域"></a>2. 跨域</h2><ul><li><p>什么是跨域 同源策略</p></li><li><p>JSONP</p></li><li><p>CORS</p><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><blockquote><p>同源：协议，域名，端口三者一致。 Ajax请求时， <strong>浏览器</strong>要求当前页面和server必须同源。CSP安全<br>加载图片css，js可无视同源策略</p></blockquote></li><li><p>img src=’跨域的图片地址’，可用于统计埋点</p></li><li><p>link href=’跨域的css地址’ ，可以使用CDN</p></li><li><p>script src=’跨域的js地址’，可以使用CDN，实现JSONP<br>所有的跨域，都必须经过server端的允许和配合</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3></li><li><p>script可以实现跨域</p></li><li><p>server端可以动态拼接数据返回</p><h3 id="CORS-服务器端设置-http-header"><a href="#CORS-服务器端设置-http-header" class="headerlink" title="CORS - 服务器端设置 http header"></a>CORS - 服务器端设置 http header</h3><ul><li>Access-Control-Allow-Origin</li><li>Access-Control-Allow-Headers</li><li>Access-Control-Allow-Methods</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;手写一个简易的ajax&lt;/li&gt;
&lt;li&gt;跨域&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;XMLHttpRequest&lt;/
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>【HTML】查漏补缺</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BHTML%5D%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    <id>https://wangyx233.github.io/2021/06/30/[HTML]查漏补缺/</id>
    <published>2021-06-30T02:45:57.316Z</published>
    <updated>2021-07-13T03:21:58.466Z</updated>
    
    <content type="html"><![CDATA[<ul><li>语义化</li><li>块级元素，内联元素</li></ul><ol><li>语义化</li></ol><ul><li>人更容易读懂，可读性</li><li>搜索引擎SEO更容易懂</li></ul><ol start="2"><li></li></ol><ul><li>块级： block/table, div, h1, table, p, ul, li</li><li>内联： inline/inline-block, span, img, input, button</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;语义化&lt;/li&gt;
&lt;li&gt;块级元素，内联元素&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;语义化&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;人更容易读懂，可读性&lt;/li&gt;
&lt;li&gt;搜索引擎SEO更容易懂&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;/
      
    
    </summary>
    
      <category term="HTML" scheme="https://wangyx233.github.io/categories/HTML/"/>
    
    
  </entry>
  
  <entry>
    <title>【CSS】梳理</title>
    <link href="https://wangyx233.github.io/2021/06/30/%5BCSS%5D%E6%A2%B3%E7%90%86/"/>
    <id>https://wangyx233.github.io/2021/06/30/[CSS]梳理/</id>
    <published>2021-06-30T02:45:57.315Z</published>
    <updated>2021-07-13T03:21:58.435Z</updated>
    
    <content type="html"><![CDATA[<ul><li>布局</li><li>定位</li><li>图文样式</li><li>响应式</li><li>CSS3 flex 动画</li></ul><ol><li>盒模型，宽度</li><li>margin纵向重叠问题</li><li>margin负值</li><li>BFC理解应用！</li><li>float布局 clearfix</li><li>flex画骰子</li><li>absolute relative</li><li>居中对齐</li><li>line-height 继承</li><li>rem是什么</li><li>如何实现响应式</li><li>CSS3动画</li></ol><ol><li><p>盒模型<br>offsetWidth<br>box-sizing: content-box; 默认值<br>box-sizing: border-box; </p></li><li><p>margin 纵向重叠：相邻元素的margin-top 和 margin-bottom会相互重叠。空内容的P标签也会重叠</p></li><li><p>margin 负值<br>margin-left，margin-top 向相反方向移动<br>margin-right，自身不受影响，右侧元素左移<br>margin-bottom，自身不受影响，下方的会上移<br>空的标签也会重叠</p></li><li><p>BFC</p><blockquote><p>块级格式化上下文。Block Format Content，是一个独立的渲染区域，内部元素的渲染不会影响边界以外的元素。<br>形成BFC的条件：</p></blockquote></li></ol><ul><li>float 不是 none</li><li>position是absolute或者fixed</li><li>overflow不是visible</li><li>display是flex或者inline-block</li></ul><p>常见应用：</p><ul><li>清除浮动</li></ul><ol start="5"><li>圣杯/双飞翼<br>圣杯：<br>三栏布局，两侧内容固定，中间内容宽度自适应</li></ol><ul><li>使用float</li><li>两侧使用margin负值，确定左右两块</li><li>父元素使用padding</li></ul><p>双飞翼：main  left right 顺序</p><ul><li>使用float</li><li>使用margin为左右留白，margin-left</li></ul><ol start="6"><li>手写clearfix</li></ol><p>.clearfix:after {<br>    content: ‘’;<br>    display: ‘table’;<br>    clear: both;<br>}</p><ol start="7"><li><p>flex<br>三色的骰子<br>align-self</p></li><li><p>定位<br>absolute：最近一层的非static的<br>relative：自身定位<br>居中对齐的方式：</p></li></ol><ul><li>水平</li></ul><ol><li>inline: text-align: center</li><li>block: margin: auto</li><li>absolute: left: 50% + margin-left: 负值</li></ol><ul><li>垂直</li></ul><ol><li><p>inline: line-height</p></li><li><p>absolute: top: 50% + margin-top: 负值 或者  top: 50%; left: 50%; transform: translate(-50%, -50%) 或者 top,right,bottom,left:0 + margin: auto</p></li><li><p>line-height 如何继承</p></li></ol><ul><li>如果是具体的数值，直接继承</li><li>如果是数字比例，1，1.5，直接继承这个数值</li><li>如果是百分比，则继承计算出的值，算出line-height的数值<br>和字体的乘积</li></ul><ol start="10"><li>响应式</li></ol><ul><li>rem：相对根元素html的长度单位，em相对父元素的长度单位<br>html {<br>  font-size: 100px;<br>}<br>任何宽度的都可以使用这个rem，width，font-size等</li><li>media-query 设置根元素的font-size，然后设置rem</li><li>vw / vh 网页视口尺寸<br>window.screen.height //屏幕<br>window.innerHeight //视口 100vh 100vw vmax vmin 取vh vw的最大/小<br>document.body.clientHeight //body<br>rem的特性：阶梯型，不够精细</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;布局&lt;/li&gt;
&lt;li&gt;定位&lt;/li&gt;
&lt;li&gt;图文样式&lt;/li&gt;
&lt;li&gt;响应式&lt;/li&gt;
&lt;li&gt;CSS3 flex 动画&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;盒模型，宽度&lt;/li&gt;
&lt;li&gt;margin纵向重叠问题&lt;/li&gt;
&lt;li&gt;margin负值&lt;
      
    
    </summary>
    
      <category term="CSS" scheme="https://wangyx233.github.io/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>&lt;浏览器&gt;浏览器原理初识</title>
    <link href="https://wangyx233.github.io/2020/11/18/%5B%E6%B5%8F%E8%A7%88%E5%99%A8%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E5%88%9D%E8%AF%86/"/>
    <id>https://wangyx233.github.io/2020/11/18/[浏览器]浏览器原理初识/</id>
    <published>2020-11-18T05:39:16.323Z</published>
    <updated>2022-02-15T08:04:43.312Z</updated>
    
    <content type="html"><![CDATA[<h5 id="线程-VS-进程"><a href="#线程-VS-进程" class="headerlink" title="线程 VS 进程"></a>线程 VS 进程</h5><p>一个进程就是一个程序的运行实例。启动一个程序时，浏览器会开辟一块内存用于存放代码，数据和执行任务的主线程。</p><p>进程与线程之间的关系，对于一个进程，其中的线程可以共享进程中的数据，但是一个线程抛出错误，会影响整体进程。对于操作系统中的进程来言，每个进程之间是相互隔离的，每个进程只能访问自己占有的数据，如果一个进程崩溃了或者挂起了，不会影响其他进程。当一个进程关闭时，操作系统会收回它所有占用的内存。</p><p>浏览器变更历史：单线程-&gt;多线程-&gt;SOA 形式（Services Oriented Architecture，面向服务架构）<br>单线程浏览器：不稳定，不安全，不流畅，主要是插件和页面脚本，崩溃的心情<br>多线程：以 Chrome 浏览器为例子，一个浏览器主线程，一个 GPU 进程，一个网络进程，多个渲染进程 Render Process 和多个插件进程 Plugin Process。会导致资源占用高，复杂的体系结构</p><h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h5><h6 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h6><p>TCP 协议，保证页面文件被完整的送达浏览器<br>FP First Paint，页面加载到首次开始绘制的时间。网络加载速度<br>用户数据包协议（User Datagram Protocol）”传输层，UDP 头，端口号。UDP 协议不能知道发送的数据能否到达目的地，但是传输速度快，不那么严格关注数据严格性的领域可以用，如在线视频<br>IP(Internet Protocol)协议，访问任何网站都是从一台计算机向另一台请求信息。数据当然通过网络层进行传输了，IP 头地址和数据信息。<br>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><ul><li>对于数据丢失的问题，TCP 提供了重传机制。</li><li>TCP 引入了数据包排序机制，可以把乱序的数据包合成一个完整的文件。<br>TCP 头不仅包含了目的端口号，源端口号，还包含了排序的序列号。<br>一个完整的 TCP 连接的生命周期包括，“建立连接”、“传输数据”、“断开连接”三个阶段。<br>即三次握手建立连接，数据包校验机制，四次挥手断开连接。 从发送第一个数据包开始，在一定时间没有接收到服务端的反馈则即为丢包，触发重发机制。并且别分成的小数据包，通过 TCP 头的序列号进行排序得到完整的数据。</li></ul><p>为什么要三次握手：因为服务端要确定客户端的接收能力，三次握手确定双方的接收、发送能力是正常的。<br>半连接：服务端收到了 SYN，处于 SYN_RCVD<br>ISN：Initial Sequence Number，动态生成的，根据序列号组装数据<br>第三次连接的时候可以携带数据，第一二次不可以，恶意攻击。<br>SYN Flood：客户端伪造大量 不存在的 IP 向服务端不停地发送 SYN 包，服务端回复确认包，等待确认，由于源地址不存在，因此 Server 需要不断重发直至超时。这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。<br>四次挥手：半关闭<br>MSL（Maximum Segment Lifetime）<br>注：TCP 传输明确 seq，根据序列号组装数据，回复数据 ack = 对方 seq + 1，ACK = xxx。SYN/ACK/FIN 在每端分别技</p><h6 id="HTTP-请求流程"><a href="#HTTP-请求流程" class="headerlink" title="HTTP 请求流程"></a>HTTP 请求流程</h6><p>允许浏览器向服务端发起请求的一种协议，让我们来看一下浏览器端发送 HTTP 请求的流程。</p><ol><li>构建请求</li><li>查找缓存</li><li>准备 IP 和端口，DNS 解析</li><li>TCP 链接，Chrome 同一个域名最多只能建 6 个 TCP 连接</li><li>HTTP 请求<br>Connection: Keep-Alive，会保持 TCP 连接，省去下次请求时建立连接的时间，提升加载速度</li></ol><p>服务器端</p><ol><li>返回请求</li><li>断开连接</li><li>重定向，重定向的地址在 Location 里面</li></ol><ul><li>为什么很多站点第二次打开速度很快</li></ul><ol><li>DNS 缓存</li><li>浏览器资源缓存<br>Cache-Control: Max-age=2000(s)<br>如果资源过期了，浏览器会继续发出请求，并且在 Http 的请求头中加入：If-None-Match:”实体标签”ETag，If-Modified-Since:Date 可以和 Last-Modified 服务器响应首部配合工作<br>服务器会根据这个值判断资源是否有更新新鲜度校验，如果没有更新，则返回 304，告诉浏览器这个资源可以继续使用<br>登录状态，可以用 Cookie 实现，或者 header 头里的 Authorization</li></ol><p>PS: 3xx 状态码</p><ul><li>300 Multiple Choices。内容协商，客户端协商，服务端协商，透明协商。中英文网站切换</li><li>301 Moved Permanently。永久重定向<br>Cache-Control: no-cache，与服务器进行新鲜度验证前不使用缓存内容。<br>Cache-Control: no-store，删除缓存的文档</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;线程-VS-进程&quot;&gt;&lt;a href=&quot;#线程-VS-进程&quot; class=&quot;headerlink&quot; title=&quot;线程 VS 进程&quot;&gt;&lt;/a&gt;线程 VS 进程&lt;/h5&gt;&lt;p&gt;一个进程就是一个程序的运行实例。启动一个程序时，浏览器会开辟一块内存用于存放代码，数据和执行
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/tags/JavaScript/"/>
    
      <category term="浏览器" scheme="https://wangyx233.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JS基础回顾</title>
    <link href="https://wangyx233.github.io/2020/10/16/%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/"/>
    <id>https://wangyx233.github.io/2020/10/16/基础回顾/</id>
    <published>2020-10-16T02:03:15.273Z</published>
    <updated>2020-10-16T02:03:15.273Z</updated>
    
    <content type="html"><![CDATA[<h5 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h5><p>加上 ES6 新加的 Symbol，共 7 种，分别为 String， Number， Boolean， Object， Undefined， Null。<br>分为基本数据类型(6)和 Object。<br>对于基本数据类型，通过字面量的方式声明，类型依旧是字面量，只有在使用的时候才会转换为对应的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typeof()</span><br><span class="line">  特别：</span><br><span class="line">  Symbol-&gt;symbol</span><br><span class="line">  函数-&gt;function,</span><br><span class="line">  null-&gt;object。历史原因对象以000开头，而null恰好为全零</span><br><span class="line">通过Object.prototype.toString.call()可判断准确的类型[object Type]</span><br></pre></td></tr></table></figure><p>PS: Symbol 类型(唯一的值)<br>通过 Symbol()定义，定义后的值不相等，System.prototype.description 为定义时 Symbol(‘xxx’)的标识。<br>使用场景：作为对象的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let sym = Symbol();</span><br><span class="line">let a = &#123;&#125;;</span><br><span class="line">a[sym] = &apos;symbol&apos;;</span><br><span class="line">a = &#123;</span><br><span class="line">  [sym]: &apos;symbol&apos;</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(a, sym, &#123;value: &apos;symbol&apos;&#125;)</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>不能用.运算符，.运算符会直接作为字符串取值。</li><li>Symbol 作为属性名，不会出现在 for…in, for…of 中，也不会出现在 Object.keys(), Object.getOwnPropertyNames()、JSON.stringify()里。</li><li>但也不是私有属性，Object.getOwnPropertySymbols，可以获取指定对象的所有 Symbol 属性名。</li><li>新的 API:Reflect.ownKeys 可以返回所有类型的键名，包括常规键名和 Symbol 键名。</li><li>Symbol.for(description)若没有则会创建一个，若存在则共用一个 symbol 值。 Symbol.keyFor(sym)返回一个已登记即 Symbol.for 的 Symbol 类型值的 key</li><li>其他方法可在需要是再查找。</li></ol><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>转 Boolean 类型。在条件判断时，除了 undefined， null， false， NaN， ‘’， 0， -0，其他所有值都转为 true，包括所有对象<br>对象在转换基本类型时，首先优先级最高的是，Symbol.toPrimitive，然后会调用 valueOf 然后调用 toString。<br>注：<br>‘a’ + + ‘b’ – ‘aNaN’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x==y 比较</span><br><span class="line">undefined == null  // true</span><br><span class="line">[] == true // false</span><br><span class="line">[] == ![] // true [].toString() -&gt; &apos;&apos;，!取反运算符的优先级会高于==， ![] -》 false</span><br></pre></td></tr></table></figure><ol><li>undefined == null，结果是 true。且它俩与所有其他值比较的结果都是 false。</li><li>String == Boolean，需要两个操作数同时转为 Number。</li><li>String/Boolean == Number，需要 String/Boolean 转为 Number。</li><li>Object == Primitive，需要 Object 转为 Primitive(具体通过 valueOf 和 toString 方法)。</li></ol><h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;内置类型&quot;&gt;&lt;a href=&quot;#内置类型&quot; class=&quot;headerlink&quot; title=&quot;内置类型&quot;&gt;&lt;/a&gt;内置类型&lt;/h5&gt;&lt;p&gt;加上 ES6 新加的 Symbol，共 7 种，分别为 String， Number， Boolean， Object， U
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>&lt;JS Review&gt;类型检测</title>
    <link href="https://wangyx233.github.io/2020/10/16/%5B%E9%87%8D%E6%B8%A9JS%5D%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <id>https://wangyx233.github.io/2020/10/16/[重温JS]类型判断/</id>
    <published>2020-10-16T02:03:15.269Z</published>
    <updated>2022-02-24T02:26:59.250Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>来自 null 的拷问？我是谁，我在哪儿</strong></li><li><strong>[Symbol.toStringTag]</strong></li></ul><p>基本数据类型在内存中占用固定大小的内存空间，因此被保存在栈内存中。引用类型，保存在堆内存中。</p><h5 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h5><p>说明确什么能够检测，什么不太行。<br>typeof 是检测基本数据类型的利器，number，string，boolean，undefined。<br>null，object 都只会返回 object；function 返回 function</p><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><p>通过原型链来判断：<br>variable instanceof constructor 判断是什么类型的对象，结果返回 true or false。<br>基础类型判断返回 false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class PrimitiveString &#123;</span><br><span class="line">  static [Symbol.hasInstance](x) &#123;</span><br><span class="line">    return typeof x === &apos;string&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;来自 null 的拷问？我是谁，我在哪儿&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Symbol.toStringTag]&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本数据类型在内存中占用固定大小的内存空间，因此被保存在栈内存中
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>&lt;Linux&gt;自动化部署从入门到放弃</title>
    <link href="https://wangyx233.github.io/2020/09/25/%5BLinux%5D%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <id>https://wangyx233.github.io/2020/09/25/[Linux]自动化部署从入门到放弃/</id>
    <published>2020-09-25T07:15:54.448Z</published>
    <updated>2021-01-15T08:58:13.937Z</updated>
    
    <content type="html"><![CDATA[<ul><li>node 安装，全局使用</li><li>yarn 安装</li><li>nginx 配置</li><li>vue 打包配置</li><li>github action</li></ul><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><ul><li><p>查看服务器绑定域名，查 dns 用服务器 IP 反向解析域名 &gt; dig -x ip | nslookup</p></li><li><p>WEB 服务器“一键”装机</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git -y</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ wget -c xxxxxxx</span><br><span class="line">$ tar -xvf xxxxxxx</span><br><span class="line"></span><br><span class="line">// 修改 ~/.profile</span><br><span class="line"></span><br><span class="line"># Nodejs</span><br><span class="line"></span><br><span class="line">VERSION=v12.18.4</span><br><span class="line">DISTRO=linux-x64</span><br><span class="line">export PATH=/usr/local/lib/nodejs/node-$VERSION-$DISTRO/bin:\$PATH</span><br><span class="line"></span><br><span class="line">. ~/.profile</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- -L https://yarnpkg.com/install.sh | bash</span><br></pre></td></tr></table></figure><ul><li>查找文件 find . -name ‘xxx’</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;node 安装，全局使用&lt;/li&gt;
&lt;li&gt;yarn 安装&lt;/li&gt;
&lt;li&gt;nginx 配置&lt;/li&gt;
&lt;li&gt;vue 打包配置&lt;/li&gt;
&lt;li&gt;github action&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Q-amp-A&quot;&gt;&lt;a href=&quot;#Q-am
      
    
    </summary>
    
    
      <category term="CI/CD" scheme="https://wangyx233.github.io/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>&lt;重温JS&gt;数据类型及基本转换</title>
    <link href="https://wangyx233.github.io/2020/07/28/%E9%87%8D%E6%B8%A9%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wangyx233.github.io/2020/07/28/重温学习/</id>
    <published>2020-07-28T08:40:39.655Z</published>
    <updated>2020-07-29T08:46:46.196Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>7 种语言类型<br>undefined 是一个变量，而并非是一个关键字。老的浏览器中会是，ES5 以后就不是了。函数内部，对象的属性现在也是可以赋值的。<br>if(typeof str === ‘undefined’){<br>// 如果直接用 str === undefined, str 未声明的话可能会报错 not defined<br>}<br>String 用于表示文本数据。String 有最大长度是 2^53 - 1，字符串的 UTF16 编码，charAt、charCodeAt、length 等方法针对的都是 UTF16 编码，其实一个 utf16 单元代表一个字符，这俩数量是对应的，0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）<br>Number 2^64-2^53+3<br>NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字；Infinity，无穷大；-Infinity，负无穷大。<br>还有 +0 -0，1/x 是 Infinity 还是 -Infinity<br>双精度浮点数，有效的检测范围-0x1fffffffffffff 至 0x1fffffffffffff，浮点数运算精度的问题<br>比较浮点数的准确方法是：与 JS 提供的最小精度比较 Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON</p><p>Symbol，非字符串 key 的集合， 可以用于迭代器，Symbol.iterator 需要有 next，next 返回一个对象包括 value 和 done</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o = new Object</span><br><span class="line"></span><br><span class="line">o[Symbol.iterator] = function() &#123;</span><br><span class="line">    var v = 0</span><br><span class="line">    return &#123;</span><br><span class="line">        next: function() &#123;</span><br><span class="line">            return &#123; value: v++, done: v &gt; 10 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for(var v of o)</span><br><span class="line">    console.log(v); // 0 1 2 3 ... 9</span><br></pre></td></tr></table></figure><p>StringToNumber，字符串转换为数组支持进制转换，支持科学计数法，即用 Number()转换。不建议使用 parseInt，用的时候最好传入第二个参数。parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。都会忽略字符串前后的空格</p><ul><li>Number<br>进行十进制的转换，若字符串中带有非数字，都会变成 NaN，数字会正常转换若 0 开头则会被忽略。如果是对象，则先调用对象的 valueOf()方法，如果为 NaN，则再调用 toString()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Number(&apos;&apos;) 0</span><br><span class="line">Number(true) 1</span><br><span class="line">Number(null) 0</span><br><span class="line">Number(undefined) NaN</span><br><span class="line">Number(&apos;123aaa&apos;) NaN</span><br><span class="line">Number([]) 0 -&gt; Number(&apos;&apos;)</span><br><span class="line">+string</span><br></pre></td></tr></table></figure><ul><li>parseInt(string, radix)<br>如果字符串以数字开头，则会忽略掉后续的非数字进行类型转换，否则返回 NaN，即找到字符串中的数字进行转换，若没有则为 NaN。以’0x’开头的十六进制也会转换，浮点数是向下取整，科学计数法也是不会正常转换的<br>radix 不填或填 0 的时候默认为 10,取值范围为 2 ～ 36,radix 超出指定范围返回 NaN，若转换的数字大于 radio，也返回 NaN。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;123aaa&apos;) // 123</span><br><span class="line">parseInt([]) // NaN</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(parseInt) -&gt; [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map((elem, index) =&gt; parseInt(elem, index)) // [1, NaN, NaN]</span><br><span class="line">[&apos;10&apos;,&apos;10&apos;,&apos;10&apos;,&apos;10&apos;,&apos;10&apos;].map(parseInt) // [10, NaN, 2, 3, 4]</span><br><span class="line">[&apos;1.1&apos;, &apos;2&apos;, &apos;0.3&apos;].map(parseInt) // [1, NaN, 0]</span><br></pre></td></tr></table></figure><p>数组的 toString(),会返回一个字符串的拼接；valueOf 还是返回数组。</p><p>NumberToString，正常。</p><h6 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h6><p>装箱，是指讲基本数据类型转化为对象，会频繁产生临时对象，在一些性能要求高的情况下，尽量避免。<br>.运算符提供了装箱操作，所以基本类型通过.可以临时创建一个对象来调用对象的方法。<br>Object.prototype.toString.call() 是可以准确识别对象对应的基本类型的方法，它比 instanceof(constructor) 更加准确，因为 JS 中没有方法可以更改私有的 class 属性。call 本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。</p><h6 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h6><p>拆箱是把对象转换成基本数据类型。toPrimitive<br>对象到 Number，String 的转换都遵循“先拆箱再转换”的原则。把对象-&gt;基本类型-&gt;对应的 String/Number</p><p>通过调用 valueOf()，toString()，没有则报错 TypeError。ES6 以后可以用 Symbol.toPrimitive 自定义转换覆盖以前的 valueOf()，toString()。</p><p>通过 new Number()声明的类型和直接用 Number()声明的类型不同，object 与 number 的区别。<br>toString()还可以传入进制进行计算。valueOf 返回数字</p><p>toFixed(), toPrecision(num)向上取整, toExponential()科学计数法</p><p>String,chartAt(index),chartCodeAt(index)</p><p>PS: 实现一个 parseInt()，Number()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;7 种语言类型&lt;br&gt;undefined 是一个变量，而并非是一个关键字。老的浏览器中会是，ES5 以后就不是了。函数内部，对象的属性现在也是可以赋值的。&lt;br&gt;if(typeof str === ‘undefined’){&lt;br&gt;// 如果直接用 str
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>&lt;Work&gt; 实践</title>
    <link href="https://wangyx233.github.io/2020/07/28/%5B%E5%AE%9E%E8%B7%B5%5D%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>https://wangyx233.github.io/2020/07/28/[实践]性能优化二三事/</id>
    <published>2020-07-28T08:40:39.653Z</published>
    <updated>2020-07-28T08:40:39.654Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h5><ol><li>gzip</li><li>告警系统/埋点</li><li>图表优化，步骤，加载</li></ol><p>其他的通用的方式：秒开率控制，toB 的没有这么多顾虑<br>减少 http 请求 =&gt; JS,CSS 打包，小图片用 data-uri，svg。避免大型背景图<br>利用缓存<br>了解整个前端加载的过程。<br>DNS 解析 =&gt; HTTP DNS<br>TCP 链接三次握手。HTTP/TLS HTTP 2 / HTTPS</p><p>首先得评估下现状，要配合实际情况和业务情况进行性能优化，还得设计相关的指标和标准。最后对结果进行评估，有始有终哦</p><h6 id="Tool"><a href="#Tool" class="headerlink" title="Tool"></a>Tool</h6><p>开发体验，提升效率<br>工具体系构建：版本统一，避免冲突。<br>用一套统一的过程比较方便，从 init 到 dev 再到 public。重要的是构建时间，效率</p><h6 id="持续性构建"><a href="#持续性构建" class="headerlink" title="持续性构建"></a>持续性构建</h6><p>手动，自动。代码提交到仓库，自动发布到测试环境，自动发布系统。<br>结构扫描 phantomjs，代码扫描 jshint，数据采集通过 performance API 检测性能，window.onerror 检测问题。<br>组件化，兼容性，适配性：ppi，dpr。PWA<br>组件化： 三大框架，web component，css houdini，不需要任何额外的运行时支持，就能在现代浏览器环境运行，也可以跟 HTML 无缝结合。<br>适配：</p><ul><li>PPI:Pixel Per Inch 单位英寸像素，屏幕的显示质量。文字，media query</li><li>DPR:Device Pixel Ratio 设备像素比例，物理像素与逻辑像素 px 之间的关系。viewport 控制缩放比</li><li>Resolution: 分辨率，屏幕区域的宽高所占像素数。用 vw，vh 解决</li></ul><p>单页应用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;Performance&quot;&gt;&lt;a href=&quot;#Performance&quot; class=&quot;headerlink&quot; title=&quot;Performance&quot;&gt;&lt;/a&gt;Performance&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;gzip&lt;/li&gt;
&lt;li&gt;告警系统/埋点&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>&lt;JS Review&gt;对象</title>
    <link href="https://wangyx233.github.io/2020/07/28/%5B%E9%87%8D%E6%B8%A9JS%5D%E5%AF%B9%E8%B1%A1/"/>
    <id>https://wangyx233.github.io/2020/07/28/[重温JS]对象/</id>
    <published>2020-07-28T08:40:39.560Z</published>
    <updated>2022-02-24T02:27:23.948Z</updated>
    
    <content type="html"><![CDATA[<h5 id="对象是什么？"><a href="#对象是什么？" class="headerlink" title="对象是什么？"></a>对象是什么？</h5><ul><li>具有唯一标识，内存地址。</li><li>具有状态，属性。</li><li>具有行为，方法。</li></ul><p>JS 的对象具有高度的动态性，可以在运行时对对象添加状态，修改行为。<br>JS 中 Object 的定义，用 new 构造函数()、对象字面量</p><p>构造类的函数-&gt;类的构造函数，一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。用 this 创建对象，无需重新创建一个对象再返回。<br>创建对象的方法，字面量，构造函数 new Object()，Object.create(proto, [propertiesObject])<br>构造函数以大写字母开头，不需要借助 return，通过 this 对象配合 new 实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;name: &apos;xxx&apos;&#125;</span><br><span class="line"></span><br><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">let b = new Person(&apos;xxx&apos;)</span><br><span class="line"></span><br><span class="line">Object.creat(&#123;name: &apos;xxx&apos;&#125;)</span><br></pre></td></tr></table></figure><h5 id="对象的属性类型"><a href="#对象的属性类型" class="headerlink" title="对象的属性类型"></a>对象的属性类型</h5><p>JS 中，属性和方法其实都可以成为对象的属性。属性并不是简单的名称和值，可以用一组特征来描述属性，可分为数据属性和访问器(getter/setter)属性两类。</p><ul><li>数据属性。这个就是常见的对象属性，具有以下特征：</li></ul><ol><li>value</li><li>writable：能否被赋值</li><li>enumerable：被 for in 枚举</li><li>configurable：被删除，或者改变特征值。false 时，writable 可从 true-&gt;false，但无法反向修改。enumerable 则不能修改，会报 TypeError: cannot redefine property。一旦设置为 false，cannot set true</li></ol><ul><li>访问器(getter/setter)属性。属性在读写的时候执行。</li></ul><ol><li>getter：get: () =&gt; {} || undifined</li><li>setter: set: () =&gt; {} || undifined，两者成对出现，若不设置则为 undefined</li><li>enumerable：被 for in 枚举</li><li>configurable：被删除，或者改变特征值<br>ES5 以后：<br>查看属性可用，Object.getOwnPropertyDescripter(object, ‘key’)<br>设置属性的特性可用，Object.defineProperty(object, ‘key’, {})<br>如果通过赋值的方式为属性赋值，则该属性的特征都默认为 true。但如果通过 defineProperty 赋值而不指定特性，则特征都默认为 false</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;a:1&#125;;</span><br><span class="line">o.b = 2;</span><br><span class="line">Object.getOwnPropertyDescripter(o, &apos;b&apos;);</span><br><span class="line"></span><br><span class="line">Object.defineProperty(o, &apos;c&apos;, &#123;value: 3&#125;);</span><br><span class="line">Object.getOwnPropertyDescripter(o, &apos;c&apos;);</span><br><span class="line"></span><br><span class="line">var o = &#123; get a() &#123; return &apos;a&apos; &#125; &#125;;</span><br><span class="line">Object.defineProperty(o, &apos;b&apos;, &#123;get: () =&gt; 2, set: (b) =&gt; console.log(b), configurable:true&#125;)</span><br></pre></td></tr></table></figure><h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><a id="more"></a><p>基于类的面向对象 vs 基于原型的面向对象<br>JS 的原型系统可以描述为：</p><ul><li>每个对象都有一个私有的[[prototype]]，为该对象的原型。</li><li>从对象中获取一个属性，如果自身没有，则会去它的原型上访问，直到原型为空或者找到了该属性为止。</li></ul><p>ES6 以前版本的，面向对象的使用方式，new</p><p><em>new 操作发生了什么</em><br>new fun(x,y,z)</p><ol><li>以构造器的 prototype 属性为原型，创建一个新对象；</li><li>将 this，参数传入构造器进行执行；</li><li>如果构造器返回的是对象，则返回该对象，否则返回(1)创建的对象。</li></ol><p>所以，用 new 的方式进行类的实现，可以在构造函数里面添加属性返回对象，也可以在构造函数的 prototype 里面增加属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">  this.a = 1;</span><br><span class="line">&#125;</span><br><span class="line">var t = new test;</span><br><span class="line"></span><br><span class="line">function test1() &#123;&#125;;</span><br><span class="line">test1.prototype.a = 1;</span><br><span class="line">var t1 = new test1;</span><br></pre></td></tr></table></figure><p>ES6 以后，提供了三个直接操作对象原型的内置方法，因此我们可以通过这些方法直接操作对象的原型，而不需要借助以前基于类的方式来进行。</p><ul><li>Object.create(proto, {…new object}) 根据指定的原型创建新的对象，原型可以为 null</li><li>Object.getPrototypeOf 获取对象的原型</li><li>Object.setPrototypeOf 设置对象的原型</li></ul><p>ES6 提供了 class extends，类中定义的方法和属性则会被写在原型对象之上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class animals &#123;</span><br><span class="line">  constructor(name) &#123; // 数据属性</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  get value() &#123; return this.name; &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(this.name + &apos;is eating!&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class dogs extends animals &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    super(name); // 执行父类的constructor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dog = new dogs(&apos;shishi&apos;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">arguments，类数组，可以取值，也可以得到length</span><br><span class="line">arguments[0] 和 传入的第一个参数的值保持一致，js都是通过值传参的，改变arguments[0],第一个参数的值也会变。但如果没有传入参数，则对应的值也不会改变。</span><br><span class="line">在严格模式里，不允许这样的操作。</span><br><span class="line">函数的参数传递都是按值传递的，并不是按引用传递的。值的复制，分基本类型和引用类型。值和内存地址。所以函数的参数可以当做局部变量。</span><br><span class="line">function setName(obj) &#123;</span><br><span class="line">  obj.name = &apos;hoho&apos;;</span><br><span class="line">  obj = new Object();</span><br><span class="line">  obj.name = &apos;hehe&apos;;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Object();</span><br><span class="line">setName(person);</span><br><span class="line">console.log(person.name)</span><br><span class="line"></span><br><span class="line">function test(person) &#123;</span><br><span class="line">  person.age = 26</span><br><span class="line">  person = &#123;</span><br><span class="line">    name: &apos;yyy&apos;,</span><br><span class="line">    age: 30</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return person</span><br><span class="line">&#125;</span><br><span class="line">const p1 = &#123;</span><br><span class="line">  name: &apos;yck&apos;,</span><br><span class="line">  age: 25</span><br><span class="line">&#125;</span><br><span class="line">const p2 = test(p1)</span><br><span class="line">console.log(p1) // -&gt; ?</span><br><span class="line">console.log(p2) // -&gt; ?</span><br></pre></td></tr></table></figure><h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><p>提供的内置 API，pop(),push(),shift(),unshift(),向数组插入元素的返回数组的 length，从数组中取元素的返回取的元素。<br>sort(),按字符串排序会调用 toString(),所以会借用 sort((a,b) =&gt; {return a - b;}) 返回负数，a 在 b 前面，正数 a 在 b 后面</p><p>concat(),slice()原数组都不会变，都是复制原来的数组生成新的返回。slice()负数，加上数组长度即可。<br>splice 修改原数组，返回操作的数组，只有一项。</p><p>indexOf,lastIndexOf 比较是通过===比较的,所以对象数组的 indexOf 会比较引用在不在，然后返回。</p><p>every [] -&gt; true<br>some [] -&gt; false<br>filter -&gt; []<br>forEach 返回 undefined，一般不需要返回值，或者说如果要用 return，则推荐用 map。若要修改原来数组，需要 return 配合原数组的索引修改。直接同 map 一样 return 值并不会改变。主要功能是对数据进行遍历，进行操作。<br>map 需要 return 返回值，若没有则返回 undefined，结果为修改后生成的新的数组，不会修改原来的数组。速度能更快一些<br>比如食材，cook 的实例。<br>共同点：没有 break 和 continue<br>通过 return 结束本次循环。<br>for…of(break,continue 正常) return 会报错。<br>why？<br>for…in 都不太行<br>reduce,reduceRight 处理 obj 便利<br>和一般意义上的数组不同，即开辟一段连续的内存地址，JS 的数组是由哈希表实现的<br>时间复杂度需要配合增、删、改、查动作来</p><ul><li><p>二维数组<br>const arr = new Array(7).fill([])，[]会是同一个引用 new Array(num).fill(0).map(elem =&gt; new Array())</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const len = arr.length</span><br><span class="line">for(i=0;i&lt;len;i++)&#123;</span><br><span class="line">  a[i] = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h6><p>函数是对象，函数名是指针<br>函数声明 vs 函数表达式<br>函数声明的函数，解析器会率先读取函数声明，并且在函数执行前可用；函数表达式必须等到函数解析器执行到它所在的代码行，才会被真正的解析执行。<br>函数声明提升。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">function wa() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 函数表达式</span><br><span class="line">var wa = function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数内部有两个特殊的对象，arguments，this。arguments 是一个类数组，它有一个特殊的属性 callee，是一个指向拥有 arguments 函数的指针。<br>比如递归中，如果外部函数被重写了用 arguments.callee()调用自身，递归还会正常执行。<br>this 是函数执行的环境对象。调用者的环境。<br>caller，保存这调用当前函数的函数的引用，即调用当前函数的函数是什么。可以用 arguments.callee.caller 表示。解除耦合。<br>严格模式下，callee，caller 都 🙅‍♂️<br>函数都有两个非继承而来的方法，apply()和 call()，用于改变函数内 this 的指向，即在特定的作用域内调用函数。<br>sum.apply(object, arguments)<br>sum.call(object, arg1, arg2)<br>只是传参的方式不一样而已。能方便的更改函数调用的作用域，减少耦合程度。<br>bind(),更改 this 指向。如：sum.bind(object)<br>fun.toString() / fun.valueOf() 返回函数代码</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;对象是什么？&quot;&gt;&lt;a href=&quot;#对象是什么？&quot; class=&quot;headerlink&quot; title=&quot;对象是什么？&quot;&gt;&lt;/a&gt;对象是什么？&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;具有唯一标识，内存地址。&lt;/li&gt;
&lt;li&gt;具有状态，属性。&lt;/li&gt;
&lt;li&gt;具有行为，方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JS 的对象具有高度的动态性，可以在运行时对对象添加状态，修改行为。&lt;br&gt;JS 中 Object 的定义，用 new 构造函数()、对象字面量&lt;/p&gt;
&lt;p&gt;构造类的函数-&amp;gt;类的构造函数，一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。用 this 创建对象，无需重新创建一个对象再返回。&lt;br&gt;创建对象的方法，字面量，构造函数 new Object()，Object.create(proto, [propertiesObject])&lt;br&gt;构造函数以大写字母开头，不需要借助 return，通过 this 对象配合 new 实现&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let a = &amp;#123;name: &amp;apos;xxx&amp;apos;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function Person(name) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let b = new Person(&amp;apos;xxx&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.creat(&amp;#123;name: &amp;apos;xxx&amp;apos;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h5 id=&quot;对象的属性类型&quot;&gt;&lt;a href=&quot;#对象的属性类型&quot; class=&quot;headerlink&quot; title=&quot;对象的属性类型&quot;&gt;&lt;/a&gt;对象的属性类型&lt;/h5&gt;&lt;p&gt;JS 中，属性和方法其实都可以成为对象的属性。属性并不是简单的名称和值，可以用一组特征来描述属性，可分为数据属性和访问器(getter/setter)属性两类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据属性。这个就是常见的对象属性，具有以下特征：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;value&lt;/li&gt;
&lt;li&gt;writable：能否被赋值&lt;/li&gt;
&lt;li&gt;enumerable：被 for in 枚举&lt;/li&gt;
&lt;li&gt;configurable：被删除，或者改变特征值。false 时，writable 可从 true-&amp;gt;false，但无法反向修改。enumerable 则不能修改，会报 TypeError: cannot redefine property。一旦设置为 false，cannot set true&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;访问器(getter/setter)属性。属性在读写的时候执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;getter：get: () =&amp;gt; {} || undifined&lt;/li&gt;
&lt;li&gt;setter: set: () =&amp;gt; {} || undifined，两者成对出现，若不设置则为 undefined&lt;/li&gt;
&lt;li&gt;enumerable：被 for in 枚举&lt;/li&gt;
&lt;li&gt;configurable：被删除，或者改变特征值&lt;br&gt;ES5 以后：&lt;br&gt;查看属性可用，Object.getOwnPropertyDescripter(object, ‘key’)&lt;br&gt;设置属性的特性可用，Object.defineProperty(object, ‘key’, {})&lt;br&gt;如果通过赋值的方式为属性赋值，则该属性的特征都默认为 true。但如果通过 defineProperty 赋值而不指定特性，则特征都默认为 false&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var o = &amp;#123;a:1&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;o.b = 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.getOwnPropertyDescripter(o, &amp;apos;b&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(o, &amp;apos;c&amp;apos;, &amp;#123;value: 3&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.getOwnPropertyDescripter(o, &amp;apos;c&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var o = &amp;#123; get a() &amp;#123; return &amp;apos;a&amp;apos; &amp;#125; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(o, &amp;apos;b&amp;apos;, &amp;#123;get: () =&amp;gt; 2, set: (b) =&amp;gt; console.log(b), configurable:true&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h5 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h5&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>&lt;CSS&gt;Flex</title>
    <link href="https://wangyx233.github.io/2020/07/22/%5BCSS%5Dflex/"/>
    <id>https://wangyx233.github.io/2020/07/22/[CSS]flex/</id>
    <published>2020-07-22T07:22:47.016Z</published>
    <updated>2020-07-22T11:32:21.396Z</updated>
    
    <content type="html"><![CDATA[<p>flex: 1<br>flex-shrink<br>flex-grow<br>flex-basis</p><p>标准盒模型：margin，border，padding，width(即 content area)<br>ie 的 margin，width(border,padding , content area width)</p><p>BFC(Block formatting context) 块级格式化上下文，W3C CSS2.1 规范中的一个概念。盒模型布局的 css 渲染模式，一个隔离的独立容器(独立渲染区域)<br>通俗理解，BFC 像一个封闭的箱子，内部元素随意变换不会影响外部的布局。<br>BFC 的形成条件：<br>html<br>浮动元素：float 除 none 以外的值<br>绝对定位元素：position (absolute、fixed)<br>display 为 inline-block、table-cells、flex<br>overflow 除了 visible 以外的值 (hidden、auto、scroll)<br>解决的问题：</p><ol><li>同一 BCF 下外边距 margin 重叠问题，不同 BFC 容器则不会重叠</li><li>用 BCF 容器清除浮动，包裹浮动的元素。(借助 overflow 触发)</li><li>阻止被浮动覆盖。(借助 overflow 触发)</li><li>用 bcf 实现两栏布局。(借助 overflow 触发)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;flex: 1&lt;br&gt;flex-shrink&lt;br&gt;flex-grow&lt;br&gt;flex-basis&lt;/p&gt;
&lt;p&gt;标准盒模型：margin，border，padding，width(即 content area)&lt;br&gt;ie 的 margin，width(border,pa
      
    
    </summary>
    
    
      <category term="flex" scheme="https://wangyx233.github.io/tags/flex/"/>
    
  </entry>
  
  <entry>
    <title>&lt;问题汇总&gt;</title>
    <link href="https://wangyx233.github.io/2020/07/22/%5B%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%5D/"/>
    <id>https://wangyx233.github.io/2020/07/22/[问题汇总]/</id>
    <published>2020-07-22T07:04:52.719Z</published>
    <updated>2020-07-22T07:05:08.650Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-cdn-是什么，干什么，哪些地方实现了加速"><a href="#1-cdn-是什么，干什么，哪些地方实现了加速" class="headerlink" title="1. cdn 是什么，干什么，哪些地方实现了加速"></a>1. cdn 是什么，干什么，哪些地方实现了加速</h4><h4 id="2-前端缓存策略，强缓存、协商缓存的优先级"><a href="#2-前端缓存策略，强缓存、协商缓存的优先级" class="headerlink" title="2. 前端缓存策略，强缓存、协商缓存的优先级"></a>2. 前端缓存策略，强缓存、协商缓存的优先级</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-cdn-是什么，干什么，哪些地方实现了加速&quot;&gt;&lt;a href=&quot;#1-cdn-是什么，干什么，哪些地方实现了加速&quot; class=&quot;headerlink&quot; title=&quot;1. cdn 是什么，干什么，哪些地方实现了加速&quot;&gt;&lt;/a&gt;1. cdn 是什么，干什么，哪
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>&lt;知识点回顾&gt;JS基础</title>
    <link href="https://wangyx233.github.io/2020/07/17/%5B%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE%5D/"/>
    <id>https://wangyx233.github.io/2020/07/17/[知识点回顾]/</id>
    <published>2020-07-17T02:59:42.854Z</published>
    <updated>2020-07-24T06:39:34.508Z</updated>
    
    <content type="html"><![CDATA[<p>DOM 事件<br>DOM 0 级， element.onClick = () =&gt; {};<br>DOM 2 级，element.addEventListener(name, function(){}, capture = false) 冒泡事件<br>事件模型分为捕获和冒泡，捕获是从 window 自上而下到目标元素，冒泡阶段是从目标元素自下而上向 window 传播。<br>事件委托 delegation，事件冒泡到父元素，所以子元素的事件可以委托到父元素统一处理多个子元素的事件。<br>优点是，不需要为每个子元素绑定事件，减少不必要的开销，提高性能等。且可动态处理事件。<br>阻止默认事件，event.preventDefault()<br>阻止冒泡，event.stopPropagation<br>event.target 事件触发的<br>event.currentTarget 事件监听的元素<br>自定义事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var event = new Event(name) // 无法传达参数</span><br><span class="line">var event = new CustomEvent(name, params)</span><br><span class="line"></span><br><span class="line">elem.addEventListener(name, function()&#123;&#125;, false) // 监听事件</span><br><span class="line">elem.dispatchEvent(event) // 分发触发事件，而非浏览器触发的</span><br></pre></td></tr></table></figure><p>观察者模式：事件<br>手写发布-订阅模式 EventEmitter</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DOM 事件&lt;br&gt;DOM 0 级， element.onClick = () =&amp;gt; {};&lt;br&gt;DOM 2 级，element.addEventListener(name, function(){}, capture = false) 冒泡事件&lt;br&gt;事件模型分为
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>&lt;重温JS&gt;闭包，作用域</title>
    <link href="https://wangyx233.github.io/2020/07/02/%5B%E9%87%8D%E6%B8%A9JS%5D%E9%97%AD%E5%8C%85/"/>
    <id>https://wangyx233.github.io/2020/07/02/[重温JS]闭包/</id>
    <published>2020-07-02T08:39:03.139Z</published>
    <updated>2022-02-16T03:56:15.861Z</updated>
    
    <content type="html"><![CDATA[<h5 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h5><p>闭包是带执行环境的函数，本质是个函数<br>立即执行函数表达式 IIFE，括号前要加;分隔;(function(){})(); 不然会被解析成上一行的函数调用；或者用 void function() {}()</p><ul><li>var</li><li>let： for, if, switch, try/catch/finally…{}包裹的</li><li>Realm： 9.0 标准提出的，主要应用于通过 iframe 等方式创造 window 环境</li></ul><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><ul><li>普通函数，用 function 定义的普通函数 function fun() {}</li><li>箭头函数，const fun = () =&gt; { }</li><li>在 class 中定义的函数，class a { fun() {} }</li><li>生成器函数，function * fun (){}</li><li>用 class 定义的类，实际也是函数 class Foo {constructor (){}}</li><li>异步函数，async function fun() {}，const fun = async ()=&gt; {}， async function fun*() {}</li></ul><h6 id="this"><a href="#this" class="headerlink" title="this"></a>this</h6><p>同一个函数调用方式不同，this 也不同，普通函数的 this 由调用函数时使用的引用决定。箭头函数不论什么引用调用都不会影响它原来的 this，即外层函数调用的 this。<br>生成器函数、异步生成器函数和异步普通函数跟普通函数行为是一致的，异步箭头函数与箭头函数行为是一致的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function showThis()&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line">    showThis: showThis</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showThis(); // global</span><br><span class="line">o.showThis(); // o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const showThis = () =&gt; &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line">    showThis: showThis</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showThis(); // global</span><br><span class="line">o.showThis(); // global</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">    showThis() &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var o = new C();</span><br><span class="line">var showThis = o.showThis;</span><br><span class="line"></span><br><span class="line">showThis(); // undefined</span><br><span class="line">o.showThis(); // o</span><br></pre></td></tr></table></figure><p>切换上下文：函数保存定义时上下文的私有变量[[Environment]],当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的[[Environment]]</p><h5 id="apply，call，bind-操作-this"><a href="#apply，call，bind-操作-this" class="headerlink" title="apply，call，bind 操作 this"></a>apply，call，bind 操作 this</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var number = 5;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    number: 3,</span><br><span class="line">    fn: (function () &#123;</span><br><span class="line">        var number;</span><br><span class="line">        this.number *= 2;</span><br><span class="line">        number = number * 2;</span><br><span class="line">        number = 3;</span><br><span class="line">        return function () &#123;</span><br><span class="line">            var num = this.number;</span><br><span class="line">            this.number *= 2;</span><br><span class="line">            console.log(num);</span><br><span class="line">            number *= 3;</span><br><span class="line">            console.log(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br><span class="line">var myFun = obj.fn;</span><br><span class="line">myFun.call(null);</span><br><span class="line">obj.fn();</span><br><span class="line">console.log(window.number);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;执行上下文&quot;&gt;&lt;a href=&quot;#执行上下文&quot; class=&quot;headerlink&quot; title=&quot;执行上下文&quot;&gt;&lt;/a&gt;执行上下文&lt;/h5&gt;&lt;p&gt;闭包是带执行环境的函数，本质是个函数&lt;br&gt;立即执行函数表达式 IIFE，括号前要加;分隔;(function(){
      
    
    </summary>
    
    
      <category term="closure" scheme="https://wangyx233.github.io/tags/closure/"/>
    
  </entry>
  
  <entry>
    <title>&lt;重温JS&gt;JS中的异步</title>
    <link href="https://wangyx233.github.io/2020/07/01/%5B%E9%87%8D%E6%B8%A9JS%5DJS%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5/"/>
    <id>https://wangyx233.github.io/2020/07/01/[重温JS]JS中的异步/</id>
    <published>2020-07-01T09:38:25.955Z</published>
    <updated>2020-07-02T03:57:33.436Z</updated>
    
    <content type="html"><![CDATA[<p>一个 JavaScript 引擎会常驻内存中，自己发起的任务是微观任务，宿主环境分配的是宏观任务。<br>宏观任务 vs 微观任务，setTimeout 是宏观任务，ES5 之后 加入了 Promise 是 JS 引擎生成的微观任务。w<br>事件循环-&gt;宏观任务的队列，在每个宏观任务里有微观事件的队列。因此一个宏观任务中的微观任务执行后，再进行下一个宏观任务</p><h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p>是 JS 提供的一种标准化的异步处理方式，需要进行 io，等待或者其他操作的函数，不返回真实结果，而返回一个 Promise，在合适的时候再调用函数，等待这个 Promise 的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">  resolve();</span><br><span class="line">  reject();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行顺序是查看有多少个宏观任务，每个宏观任务中有多少个微观任务，根据调用次数确定宏观任务中的微观任务，然后根据宏观任务的触发规则和调用次序再依次执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sleep(duration) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      console.log(&quot;b&quot;);</span><br><span class="line">      setTimeout(resolve,duration);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&quot;a&quot;);</span><br><span class="line">  sleep(5000).then(()=&gt;console.log(&quot;c&quot;));</span><br></pre></td></tr></table></figure><h5 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h5><p>ES2016 新加入的特性。async 函数必定返回 Promise，异步函数，用 await 来等待一个 Promise</p><p>我们现在要实现一个红绿灯，把一个圆形 div 按照绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个 JavaScript 引擎会常驻内存中，自己发起的任务是微观任务，宿主环境分配的是宏观任务。&lt;br&gt;宏观任务 vs 微观任务，setTimeout 是宏观任务，ES5 之后 加入了 Promise 是 JS 引擎生成的微观任务。w&lt;br&gt;事件循环-&amp;gt;宏观任务的队
      
    
    </summary>
    
    
      <category term="Promise" scheme="https://wangyx233.github.io/tags/Promise/"/>
    
      <category term="setTimeout" scheme="https://wangyx233.github.io/tags/setTimeout/"/>
    
  </entry>
  
  <entry>
    <title>&lt;算法基础&gt;动态规划</title>
    <link href="https://wangyx233.github.io/2020/06/01/%5B%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%5D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://wangyx233.github.io/2020/06/01/[算法基础]动态规划/</id>
    <published>2020-06-01T06:55:32.693Z</published>
    <updated>2020-07-01T09:31:09.945Z</updated>
    
    <content type="html"><![CDATA[<h5 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h5><ol><li>计数：how many xxx? 多少种方法可以 blabla</li><li>求最大最小值：max，min…</li><li>求存在性：博弈，是否能 blabla，先手能不能赢，存不存在策略。</li></ol><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ol><li>确定状态。属于定海神针，相当于未知量，类似于 x,y,z。需要开一个数组</li></ol><ul><li>最后一步，最后一个。比如：一共有 k 个硬币，不关心 k-1 前的状态。只要保证 k-1 是最少的达到目标的</li><li>子问题。问题一样，规模变小</li></ul><p>递归的问题，会存在大量的重复计算，效率低下。所以如何优化呢？最容易想到的是加缓存，存一下中间计算值</p><ol start="2"><li><p>转移方程。问题解决了一半</p></li><li><p>初始条件，边界情况：注意边界情况处理数组不要越界，初始条件是一开始就能定下来的比如 f[0]一般是最小的，关键是用转移方程算不出来的，手动定义值。</p></li><li><p>计算顺序。一般情况是从小到大。从上到下，从左到右。原则是，算等式左边的时候，等式右边已经能算出来，用到的状态已经算到了</p></li></ol><p>消除冗余，加速计算。递归的另一种优化方式。</p><p><strong>加法原理</strong></p><ul><li>无重复</li><li>无遗漏</li></ul><h6 id="coin-change-最值"><a href="#coin-change-最值" class="headerlink" title="coin change 最值"></a>coin change 最值</h6><h6 id="unique-path-计数"><a href="#unique-path-计数" class="headerlink" title="unique path 计数"></a>unique path 计数</h6><h6 id="jump-game-存在性"><a href="#jump-game-存在性" class="headerlink" title="jump game 存在性"></a>jump game 存在性</h6><h5 id="常见的动态规划的类型"><a href="#常见的动态规划的类型" class="headerlink" title="常见的动态规划的类型"></a>常见的动态规划的类型</h5><ul><li>坐标</li><li>序列</li><li>划分</li><li>区间</li><li>背包</li><li>最长序列，最长上升子序列</li><li>博弈</li><li>综合</li><li>打印路径</li></ul><h5 id="了解博弈"><a href="#了解博弈" class="headerlink" title="了解博弈"></a>了解博弈</h5><h6 id="巴什博奕-Bash-game"><a href="#巴什博奕-Bash-game" class="headerlink" title="巴什博奕 Bash game"></a>巴什博奕 Bash game</h6><p>A,B 玩报数的游戏，若先报到 30 的那个人会赢，每人每次最多报 2(max) 个数，最少报 1 个数，如何保持自己的不败之地。</p><p>从简单的来思考，若报到 max + 1 即 3，则后面报数的一定会赢。就先看有多少个这个循环 30 / max + 1，若能整除则后者赢，若有余数则前者先报余数个数则必赢。每次都保证两人报的数是 1+max 个就是一个完整的循环。这是基于两人都是特别聪明的前提。<br>1+max 的倍数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;适用情况&quot;&gt;&lt;a href=&quot;#适用情况&quot; class=&quot;headerlink&quot; title=&quot;适用情况&quot;&gt;&lt;/a&gt;适用情况&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;计数：how many xxx? 多少种方法可以 blabla&lt;/li&gt;
&lt;li&gt;求最大最小值：max，min…
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>时间&amp;空间复杂度</title>
    <link href="https://wangyx233.github.io/2020/05/12/%5B%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%5D%E6%97%B6%E9%97%B4&amp;%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://wangyx233.github.io/2020/05/12/[算法基础]时间&amp;空间复杂度/</id>
    <published>2020-05-12T14:14:17.326Z</published>
    <updated>2020-05-13T03:04:03.772Z</updated>
    
    <content type="html"><![CDATA[<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>用 Big O 表示，用来表示程度运行时间维度上的趋势。所以 O 表示忽略掉不重要的部分，留下的关键关系。<br>常见的时间复杂度有：</p><ul><li>常数 O(1)</li><li>对数 O(logn)</li><li>线性 O(n)</li><li>n 的次方 O(n^2…)</li><li>指数 O(k^n)</li><li>阶乘 O(n!)<br>一般通过看随着 n 的改变，代码要运行多少次。n 比较小的话，其实时间复杂度都差不多，关注时间复杂度的情况一般对数据量较大时，程序的效率问题。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 比如：普通递归计算斐波那契，理解递归总共执行了多少次，善用缓存，避免重复计算。或者循环</span><br><span class="line">const fib = (n) =&gt; &#123;</span><br><span class="line">  if (n &lt; 2) return n;</span><br><span class="line">  return fib(n - 1) + fib(n - 2);</span><br><span class="line">&#125;</span><br><span class="line">// O(2^k)</span><br></pre></td></tr></table></figure><h6 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h6><p>用于进行递归程序的时间复杂度计算，一般常见的算法有：</p><ul><li>二分查找 O(logn)</li><li>二叉树遍历 O(n)</li><li>有序二维数据查找 O(n)</li><li>归并排序 O(nlogn)</li></ul><p>二叉树的前中后序遍历，图遍历，搜索算法 DFS,BFS，时间复杂度都是 O(n)，因为有且只经过了每个节点一次，所以是和节点数成线性相关的。</p><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><p>如果是数组，那就是数组的长度，O(n)。二维数组，O(n^2)。<br>如果是递归的，那就是递归的深度，如果递归里面又开了数组，则是两者的最大值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h5&gt;&lt;p&gt;用 Big O 表示，用来表示程度运行时间维度上的趋势。所以 O 表示忽略掉不重要的部分，留下的关键关系。&lt;br&gt;常
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://wangyx233.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>&lt;CSS&gt;回顾伪类与伪元素</title>
    <link href="https://wangyx233.github.io/2020/05/11/%5BCSS%5D%E5%9B%9E%E9%A1%BE%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    <id>https://wangyx233.github.io/2020/05/11/[CSS]回顾伪类与伪元素/</id>
    <published>2020-05-11T06:35:48.173Z</published>
    <updated>2020-05-11T15:06:43.936Z</updated>
    
    <content type="html"><![CDATA[<p>在重温 CSS 选择的时候，看到伪类与伪元素有一瞬间迷惑之情，所以这次重新加深一番印象。</p><h5 id="伪类-pseudo-classes-？伪元素-pseudo-elements-？"><a href="#伪类-pseudo-classes-？伪元素-pseudo-elements-？" class="headerlink" title="伪类(pseudo-classes)？伪元素(pseudo-elements)？"></a>伪类(pseudo-classes)？伪元素(pseudo-elements)？</h5><p>为什么要引入伪类，伪元素？为了格式化文档树以外的信息。</p><ul><li>伪类：用于描述已经存在的元素的某个状态，添加对应的样式。用:,如：hover,:first-child…</li><li>伪元素：用于创建一些不在文档树中的元素。多用::,如：::before,::after…，虽然用户可以看到这些内容，但事实上并不存在在文档树中。</li></ul><p>补充：CSS 的选择器</p><ol><li>元素选择器</li></ol><ul><li>* 通配符选择器</li><li>div,p,span… 元素选择器</li><li>#id</li><li>.class</li></ul><ol start="2"><li>属性选择器</li></ol><ul><li>[attr]</li><li>[attr=val]</li><li>[attr^=val] 以 val 开头属性值的元素</li><li>[attr$=val] 以 val 结尾</li><li>[attr*=val] 属性值包含这个 val 属性值的元素</li><li>[attr~=val] 属性值为 val，或其中一个值为 val 的元素</li><li>[attr|=val] 属性值为 val，或者 val-xxx 的元素</li><li>i 不区分大小写，s 区分大小写<br>eg. <a href="https://codepen.io/yx233/pen/abvGgad" target="_blank" rel="noopener">https://codepen.io/yx233/pen/abvGgad</a></li></ul><ol start="3"><li>关系选择器</li></ol><ul><li>后代选择器： 空格，所有后代</li><li>子选择器：&gt; 直接后代，不包括隔代元素</li><li>兄弟选择器：~ 所有兄弟结点</li><li>相邻选择气：+ 相邻兄弟结点</li></ul><p>选择指向越准确，优先级越高。尽量减少 CSS 选择器的层数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在重温 CSS 选择的时候，看到伪类与伪元素有一瞬间迷惑之情，所以这次重新加深一番印象。&lt;/p&gt;
&lt;h5 id=&quot;伪类-pseudo-classes-？伪元素-pseudo-elements-？&quot;&gt;&lt;a href=&quot;#伪类-pseudo-classes-？伪元素-pseud
      
    
    </summary>
    
    
      <category term="CSS" scheme="https://wangyx233.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>&lt;重温JS&gt;正则从开始到结束</title>
    <link href="https://wangyx233.github.io/2020/05/08/%5B%E9%87%8D%E6%B8%A9JS%5D%E6%AD%A3%E5%88%99%E4%BB%8E%E5%BC%80%E5%A7%8B%E5%88%B0%E7%BB%93%E6%9D%9F/"/>
    <id>https://wangyx233.github.io/2020/05/08/[重温JS]正则从开始到结束/</id>
    <published>2020-05-08T09:06:15.947Z</published>
    <updated>2020-05-08T09:21:49.692Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式用的元字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() [] &#123;&#125; | \ ^ $ . * + ?</span><br></pre></td></tr></table></figure><p>通过 new RegExp() 前一个要转换成字符串，不能直接用正则字面量。如元字符要进行双重转义。<br>正则表达式的 valueOf(),返回正则表达式本身。</p><p>regexp.test(text)<br>regexp.exec(text)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式用的元字符：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
      
    
    </summary>
    
    
      <category term="RegExp" scheme="https://wangyx233.github.io/tags/RegExp/"/>
    
  </entry>
  
  <entry>
    <title>&lt;重温JS&gt;时间处理二三事</title>
    <link href="https://wangyx233.github.io/2020/05/08/%5B%E9%87%8D%E6%B8%A9JS%5D%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>https://wangyx233.github.io/2020/05/08/[重温JS]时间处理二三事/</id>
    <published>2020-05-08T08:48:01.658Z</published>
    <updated>2020-05-08T09:00:04.521Z</updated>
    
    <content type="html"><![CDATA[<p>const current = new Date();<br>Date.parse(current); //turn to UTC,ms<br>Date.UTC(year, month - 1 )<br>Date.now() // s<br>+new Date();</p><p>.toString(),字符串；.valueOf(),数值 ms</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;const current = new Date();&lt;br&gt;Date.parse(current); //turn to UTC,ms&lt;br&gt;Date.UTC(year, month - 1 )&lt;br&gt;Date.now() // s&lt;br&gt;+new Date();&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="moment.js" scheme="https://wangyx233.github.io/tags/moment-js/"/>
    
      <category term="Date" scheme="https://wangyx233.github.io/tags/Date/"/>
    
  </entry>
  
  <entry>
    <title>&lt;安全&gt;从基本安全概念到HTTPS发生了什么</title>
    <link href="https://wangyx233.github.io/2020/05/08/%5B%E5%AE%89%E5%85%A8%5D%E4%BB%8E%E5%9F%BA%E6%9C%AC%E5%AE%89%E5%85%A8%E6%A6%82%E5%BF%B5%E5%88%B0Https/"/>
    <id>https://wangyx233.github.io/2020/05/08/[安全]从基本安全概念到Https/</id>
    <published>2020-05-08T08:23:25.292Z</published>
    <updated>2020-05-11T15:11:55.481Z</updated>
    
    <content type="html"><![CDATA[<p>A 要给 B 发送信息</p><h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><p>加密和解密用的密钥是相同的。</p><h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><p>公钥加密，私钥解密。传递公钥</p><h5 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h5><h5 id="数字签名，数字证书"><a href="#数字签名，数字证书" class="headerlink" title="数字签名，数字证书"></a>数字签名，数字证书</h5><p>私钥加密，公钥解密。传递公钥<br>数字中心</p><h5 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h5><p>先认证服务端，然后服务端再传递加密内容。<br>再进行秘文交换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A 要给 B 发送信息&lt;/p&gt;
&lt;h5 id=&quot;对称加密&quot;&gt;&lt;a href=&quot;#对称加密&quot; class=&quot;headerlink&quot; title=&quot;对称加密&quot;&gt;&lt;/a&gt;对称加密&lt;/h5&gt;&lt;p&gt;加密和解密用的密钥是相同的。&lt;/p&gt;
&lt;h5 id=&quot;非对称加密&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="HTTPS" scheme="https://wangyx233.github.io/tags/HTTPS/"/>
    
      <category term="对称加密" scheme="https://wangyx233.github.io/tags/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="非对称加密" scheme="https://wangyx233.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="数字签名" scheme="https://wangyx233.github.io/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>&lt;Algorithm&gt;查找</title>
    <link href="https://wangyx233.github.io/2020/04/27/%5B%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%5D%E6%9F%A5%E6%89%BE/"/>
    <id>https://wangyx233.github.io/2020/04/27/[算法基础]查找/</id>
    <published>2020-04-27T08:56:53.445Z</published>
    <updated>2020-04-27T09:07:08.708Z</updated>
    
    <content type="html"><![CDATA[<h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>特点：有序列表的查找，时间复杂度 O(logN)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const binary_search = (list, x) =&gt; &#123;</span><br><span class="line">  const mid = Math.ceil(list.length / 2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回忆一下指数，对数是什么，对数是指数的逆运算，求幂的次数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h5&gt;&lt;p&gt;特点：有序列表的查找，时间复杂度 O(logN)&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://wangyx233.github.io/tags/Algorithm/"/>
    
      <category term="search" scheme="https://wangyx233.github.io/tags/search/"/>
    
  </entry>
  
  <entry>
    <title>&lt;了解&gt;浏览器是如何工作的？</title>
    <link href="https://wangyx233.github.io/2020/04/27/%5B%E6%B5%8F%E8%A7%88%E5%99%A8%5D%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/"/>
    <id>https://wangyx233.github.io/2020/04/27/[浏览器]浏览器是如何工作的？/</id>
    <published>2020-04-27T08:07:25.056Z</published>
    <updated>2020-04-27T08:56:01.130Z</updated>
    
    <content type="html"><![CDATA[<p>在浏览器地址栏输入 URL 发生了什么？</p><ol><li>如果是域名，先进行 DNS 解析，根据 IP 地址去服务端请求页面；</li><li>拿到服务端返回的 HTML，解析构建成 DOM 树；</li><li>计算 DOM🌲 上的 CSS 属性；</li><li>根据 CSS 渲染每个元素，在内存中保存为位图；</li><li>进行渲染合成绘制。</li></ol><p>整个过程是流式过程，网页是逐渐加载出来的。</p><h5 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h5><p>HTTP 协议是基于 TCP 协议的，TCP 协议是一个双向协议，而 HTTP 协议是在此基础上规定了 Requst-Response 模式，并且用来传输文本。可以理解为用 TCP 规定了一种用来传输文本的应用层协议。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在浏览器地址栏输入 URL 发生了什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果是域名，先进行 DNS 解析，根据 IP 地址去服务端请求页面；&lt;/li&gt;
&lt;li&gt;拿到服务端返回的 HTML，解析构建成 DOM 树；&lt;/li&gt;
&lt;li&gt;计算 DOM🌲 上的 CSS 属性；&lt;/li
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>&lt;JS Review&gt;垃圾收集</title>
    <link href="https://wangyx233.github.io/2020/04/24/%5B%E9%87%8D%E6%B8%A9JS%5D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
    <id>https://wangyx233.github.io/2020/04/24/[重温JS]垃圾收集/</id>
    <published>2020-04-24T08:21:39.625Z</published>
    <updated>2020-05-07T11:31:28.988Z</updated>
    
    <content type="html"><![CDATA[<p>JS 中实现了自动垃圾回收机制，自动分配内存和释放内存。原理是：找到那些不再使用的变量，然后释放它所占的内存。然后按照固定的时间间隔执行。<br>垃圾收集器需要跟踪变量有没有用，对没有用的变量打上标记，以便后续的回收。标识变量的策略常用的有，标记清除，引用计数。</p><ul><li>标记清除 Mark and Sweep<br>进入环境标记。或者维护一个进入环境的列表，一个离开环境的列表。把环境中用到的或者被其他环境内引用的变量标记去掉，剩下还有标记的都是需要删除的变量。</li><li>引用计数 Reference Count。可能会导致内存一直得不到释放，比如在函数内，两个对象相互调用</li></ul><p>解除引用 Dereferencing,一旦不再使用，最好将他们的值置位 null。主要是全局变量，全局对象等。因为局部变量都会在离开执行环境后，直接解除引用。解除引用，是让这个值脱离执行环境，而不是立即内存回收。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JS 中实现了自动垃圾回收机制，自动分配内存和释放内存。原理是：找到那些不再使用的变量，然后释放它所占的内存。然后按照固定的时间间隔执行。&lt;br&gt;垃圾收集器需要跟踪变量有没有用，对没有用的变量打上标记，以便后续的回收。标识变量的策略常用的有，标记清除，引用计数。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://wangyx233.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>&lt;Algorithm&gt;树</title>
    <link href="https://wangyx233.github.io/2020/04/20/%5B%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%5D%E6%A0%91/"/>
    <id>https://wangyx233.github.io/2020/04/20/[算法基础]树/</id>
    <published>2020-04-20T06:05:28.236Z</published>
    <updated>2020-08-10T07:45:10.588Z</updated>
    
    <content type="html"><![CDATA[<h5 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h5><p>何为树？ 想象一下自然界的 🌲 形态，用术语表达即为：没有闭环的无向图。几个特征可以描述为：每个节点之间有且只有一条路径相连通；如果增加一条路径，图就会连通起来；所以边的数量为节点数-1。节点和路径可以理解为 🌲 的叉。<br>“高度”树的层数，“度”子节点的数量<br>所以二叉树，就是每个节点最多有两条边，即最多有左右两个节点的树。<br>满二叉树即为每个节点如果有子节点那左右节点都具备。如果有这个树有 n 层，那总节点数为 2 の n 次方 - 1，第 n 层的节点数为 2(n -1)。<br>完全二叉树，则是除了最后一层其他层的节点都填满，并且如果最后一层叶子节点如果是右节点，那这个叶子节点的左边必有节点。<br>二叉树的遍历方式：遍历的顺序为根节点在遍历中的顺序。</p><ul><li>前序遍历：根-左-右</li><li>中序遍历：左-根-右</li><li>后序遍历：左-右-根</li></ul><h5 id="优先队列-堆"><a href="#优先队列-堆" class="headerlink" title="优先队列-堆"></a>优先队列-堆</h5><p>理论说明：根节点和子节点之间的关系，以及结点数量。</p><ol><li>如何建堆，最大堆，最小堆。</li><li>数据插入</li><li>应用场景，堆排序，第 K 大的数</li></ol><p>时间复杂度</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h5&gt;&lt;p&gt;何为树？ 想象一下自然界的 🌲 形态，用术语表达即为：没有闭环的无向图。几个特征可以描述为：每个节点之间有且只有一条路径相
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://wangyx233.github.io/tags/Algorithm/"/>
    
      <category term="tree" scheme="https://wangyx233.github.io/tags/tree/"/>
    
      <category term="Binary tree" scheme="https://wangyx233.github.io/tags/Binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>Hover&amp;Focus Effects 简单动画示例</title>
    <link href="https://wangyx233.github.io/2020/04/16/%5BCSS%5DInput%20Bottom%20Animation/"/>
    <id>https://wangyx233.github.io/2020/04/16/[CSS]Input Bottom Animation/</id>
    <published>2020-04-16T03:36:09.777Z</published>
    <updated>2020-05-11T06:31:00.723Z</updated>
    
    <content type="html"><![CDATA[<p>登录页进行账号输入时，为了让焦点聚集在当前输入框上可能会需要配合一些动画效果，或者是某个内容的重点提醒也会在 hover 时增加醒目动画。这些设计虽然很古老，也有用到的场合。<br>主要是借助 CSS3 的 transition 来做效果变换，示例如下：<a href="https://codepen.io/yx233/pen/YzywdJQ" target="_blank" rel="noopener">https://codepen.io/yx233/pen/YzywdJQ</a></p><h5 id="普通元素-hover-effects"><a href="#普通元素-hover-effects" class="headerlink" title="普通元素 hover effects"></a>普通元素 hover effects</h5><ul><li>简单的 border-color 变换。</li><li>借助伪元素实现从左-&gt;右，或从中间向两边延伸的效果。</li></ul><h5 id="input-的-focus"><a href="#input-的-focus" class="headerlink" title="input 的 focus"></a>input 的 focus</h5><p>::after ::before 是指元素文档树内渲染前、后的内容，input 不支持。所以需要借助额外的兄弟元素进行效果实现。</p><p>注：[:focus-within]是当一个元素或者元素的后代有[:focus]伪类时生效的一个选择器。对输入框获得焦点时，其前后左右的小图标，下滑动画等变换都有非常实用的效果。</p><p>注意：登录框前有时会配合放一些小图标，如果用把 icon 当做 input 的 background-image，同时通过定位的方式定位，需要格外注意 Chrome 记住密码情况下的展示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">input[name=&apos;user&apos;] &#123;</span><br><span class="line">  background-image: url(/login/user.svg);</span><br><span class="line">  background-position: 12px;</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">&#125;</span><br><span class="line">// 注意</span><br><span class="line">input:-webkit-autofill,</span><br><span class="line">input:-webkit-autofill:hover,</span><br><span class="line">input:-webkit-autofill:focus,</span><br><span class="line">input:-webkit-autofill:active &#123;</span><br><span class="line">  -webkit-transition: color 9999s linear, background-color 9999s linear;</span><br><span class="line">  -webkit-transition-delay: 9999s;</span><br><span class="line">  background-color: XXX;</span><br><span class="line">  color: XXX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;登录页进行账号输入时，为了让焦点聚集在当前输入框上可能会需要配合一些动画效果，或者是某个内容的重点提醒也会在 hover 时增加醒目动画。这些设计虽然很古老，也有用到的场合。&lt;br&gt;主要是借助 CSS3 的 transition 来做效果变换，示例如下：&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="css" scheme="https://wangyx233.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CSS Secrets</title>
    <link href="https://wangyx233.github.io/2019/08/29/css_secret/"/>
    <id>https://wangyx233.github.io/2019/08/29/css_secret/</id>
    <published>2019-08-29T03:23:05.438Z</published>
    <updated>2020-04-15T11:12:07.616Z</updated>
    
    <content type="html"><![CDATA[<p>回顾元素获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function $$(selector, context) &#123;</span><br><span class="line">  context = context || document;</span><br><span class="line">  var elements = context.querySelectorAll(selector);</span><br><span class="line">  return Array.prototype.slice.call(elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11.20 总结：</p><p>浏览器新特性总么办，加前缀是个失败的尝试。<br>可以通过工具加前缀。不过新特性的使用任重而道远。<br>web 标准是浏览器相关厂商，以及委员会的人共同探讨维护的。</p><p>一、CSS 编写注意技巧：</p><ol><li>减少重复的代码，<br>注意 style 之间的依赖关系，如 em，rem，字体和行高等。具体如何计算相互依赖关系，需要根据实际情况。<br>代码量少，和代码容易维护不是一个概念。<br>currentcolor<br>inherit</li><li>相信眼睛而不紧紧关注数字。<br>比如 垂直居中看着并不居中，圆形看着小，padding 上下左右不一致。</li><li>响应式布局 rwd。一直说响应式布局，但是 media query 不能是最好的解决方法，只能是最后的解决方法。<br>每个媒体查询都会增加成本。每次修改 css 的时候都可能改一遍，复杂性高，经不起折腾。表现的是断点式的表现<br>可以先从减少代码重复来入手。<br>写相对大小 依赖关系。宽度不写具体的 px，用百分比的形式，或者和视口相关的表示如 vh。善用 max-width，min-width。替换元素 img，iframe，vedio 等也要设置 max-width： 100%；<br>推荐弹性布局，或者 inine-block。<br>背景图片要完整地平铺，background-size:cover</li><li>合理使用简写。对于可展开的属性。如，border，background，要贯彻减少代码重复的原则，合理使用简写或者展开。</li></ol><p>例子： background: url(tr.png) no-repeat top right / 2em 2em, url(br.png) no-repeat bottom right / 2em 2em,<br>url(bl.png) no-repeat bottom left / 2em 2em;<br>其中， / 是为了避免歧义。</p><ol start="5"><li><p>是否使用预处理器，如 less，sass 等。<br>建议在项目开始用 css，无法维护时用预处理器。因为要编译就需要时间，文件体积也会变大，还会有自身的 bug，学习成本。<br>如： 原生高级的例子。<br>ul { –accent-color: purple; }<br>ol { –accent-color: rebeccapurple; } li { background: var(–accent-color); }</p><p>11.21 总结：<br>背景与边框<br>rgba，hsla 0 红 120 绿 240 蓝 h 色调 s 饱和度 l 亮度 a 透明度</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;回顾元素获取&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>原型回顾</title>
    <link href="https://wangyx233.github.io/2019/08/21/%E5%8E%9F%E5%9E%8B%E5%9B%9E%E9%A1%BE/"/>
    <id>https://wangyx233.github.io/2019/08/21/原型回顾/</id>
    <published>2019-08-21T11:43:55.178Z</published>
    <updated>2019-08-21T11:46:51.709Z</updated>
    
    <content type="html"><![CDATA[<p>快来快来看一看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    Foo.a = function() &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;</span><br><span class="line">    this.a = function() &#123;</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.a = function() &#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;</span><br><span class="line">Foo.a = function() &#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">&#125;</span><br><span class="line">Foo.a();</span><br><span class="line">let obj = new Foo();</span><br><span class="line">obj.a();</span><br><span class="line">Foo.a();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;快来快来看一看&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://wangyx233.github.io/2019/07/22/%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97/"/>
    <id>https://wangyx233.github.io/2019/07/22/链表队列/</id>
    <published>2019-07-22T08:05:17.090Z</published>
    <updated>2020-05-15T07:09:51.492Z</updated>
    
    <content type="html"><![CDATA[<p>what?<br>链表是一种递归的数据结构，它或者为空，或者为一个指向结点的引用。该结点含有一个泛型元素和一个指向另一个链表的引用(next)。<br>其中，结点是一种含有任何类型数据的抽象实体。<br>链表表示的是一列元素。<br>在追踪链表或其他链式结构代码的时候，可用可视化的方式表示：</p><ol><li>用长方形表示对象</li><li>将实例变量的值写在长方形中</li><li>用指向被引用对象的箭头表示引用关系，链接<br>实现任意插入和删除操作的标准解决方案是双向链表，其中每个结点都含有两个链接(pervious, next)，分别指向不同的方向。</li></ol><p>特点：</p><ol><li>可以处理任意类型的数据</li><li>所需的空间和集合的大小成正比</li><li>操作的所需要的时间总是和集合的大小无关</li></ol><p>补充：</p><ol><li>背包(Bag)是一种不支持从中删除元素的集合数据类型，目的就是收集元素并且迭代遍历收集到的元素，迭代的顺序不确定且元素的处理顺序不重要，可以用栈也可以用队列。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Bag() &#123;&#125;</span><br><span class="line">  add(item)</span><br><span class="line">  isEmpty()</span><br><span class="line">  size()</span><br></pre></td></tr></table></figure><ol start="2"><li>先进先出队列 FIFO</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Queue() &#123;&#125;</span><br><span class="line">  enqueue(item) // 添加一个元素</span><br><span class="line">  dequeue() // 删除最近添加的元素</span><br><span class="line">  isEmpty()</span><br><span class="line">  size()</span><br></pre></td></tr></table></figure><ol start="3"><li>下压栈 LIFO</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Stack() &#123;&#125;</span><br><span class="line">  push(item)</span><br><span class="line">  pop()</span><br><span class="line">  isEmpty()</span><br><span class="line">  size()</span><br><span class="line">例如表达式的求值：遇到左括号忽略，操作数押入操作数的栈里，运算符押入运算符的栈里，遇到右括号运算符栈和操作数栈pop计算得到值，再押入栈中。</span><br><span class="line">如：(1 + ((2 + 3) * (4 * 5)))</span><br></pre></td></tr></table></figure><ol start="4"><li>在一些语言中，数组的长度一经定义就不可改变，并且数组的删除和添加操作需要对元素进行平移会很繁琐。JS 中数组和其他的不同，它是通过对象实现的，操作方便，但是效率可能较其他语言有所不足。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Node(elem) &#123;</span><br><span class="line">  this.elem = elem;</span><br><span class="line">  this.next = null;</span><br><span class="line">  // this.prvious = null;</span><br><span class="line">&#125;</span><br><span class="line">// 查找，插入，删除结点</span><br></pre></td></tr></table></figure><h6 id="跳表-Skip-List"><a href="#跳表-Skip-List" class="headerlink" title="跳表 Skip List"></a>跳表 Skip List</h6><p>1989 前后出现的，适用于有序元素的情况。对标的是二分查找和平衡树(二叉搜索树中的平衡树 AVL Tree)。跳表是一种插入，删除，搜索复杂度都是 logn 的数据结构。如：redis，levelDB<br>一维的数据结构要加速，一般可以升维变成二维的数据结构。空间换时间<br>LRU 缓存</p><p>自己想个 5-10min 看有没有思路，有思路就写了，没思路就直接看题解，学会了。再自己写呦</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;what?&lt;br&gt;链表是一种递归的数据结构，它或者为空，或者为一个指向结点的引用。该结点含有一个泛型元素和一个指向另一个链表的引用(next)。&lt;br&gt;其中，结点是一种含有任何类型数据的抽象实体。&lt;br&gt;链表表示的是一列元素。&lt;br&gt;在追踪链表或其他链式结构代码的时候，可用
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解promise</title>
    <link href="https://wangyx233.github.io/2019/01/16/%E7%90%86%E8%A7%A3promise/"/>
    <id>https://wangyx233.github.io/2019/01/16/理解promise/</id>
    <published>2019-01-15T16:41:34.498Z</published>
    <updated>2019-07-18T11:44:56.858Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么"><a href="#为什么" class="headerlink" title="为什么?"></a>为什么?</h4><p>避免回调地狱<br>有什么问题呢？<br>代码臃肿，可读性差，耦合性差，容易产生bug，不容易维护。不容易复用。在回调里面处理问题。<br>js特点-&gt;异步，主要是靠回调函数实现的。<br>比如，nodejs的特点是高并发和非阻塞，主要靠异步来实现。<br>js是事件注册机制的。<br>函数的执行是进栈和出栈这样的，所以普通的回调函数，try catch是没有作用的。</p><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><p>用于异步计算，用于即将发生的事情，或者不会发生的事情。<br>一个Promise的状态有resolved/rejected/pending/settled<br>new Promise 返回一个promise对象，参数是一个执行函数。执行函数有两个参数，resolve，reject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  // 异步处理</span><br><span class="line">  处理结束后执行resolve , reject</span><br><span class="line">&#125;)</span><br><span class="line">.then() //成功失败的回调，注意：then方法是异步执行的</span><br><span class="line">.catch() //在最外层捕获异常。</span><br><span class="line"></span><br><span class="line">promise.catch(onRejected)</span><br><span class="line">相当于</span><br><span class="line">promise.then(null, onRrejected);</span><br></pre></td></tr></table></figure><p>promise的三种状态:<br>pending 初始化<br>fulfilled 执行成功，调用resolve<br>rejected 失败，调用reject<br>注意promsie状态 只能由 pending =&gt; fulfilled/rejected, 一旦修改就不能再变</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么&quot;&gt;&lt;a href=&quot;#为什么&quot; class=&quot;headerlink&quot; title=&quot;为什么?&quot;&gt;&lt;/a&gt;为什么?&lt;/h4&gt;&lt;p&gt;避免回调地狱&lt;br&gt;有什么问题呢？&lt;br&gt;代码臃肿，可读性差，耦合性差，容易产生bug，不容易维护。不容易复用。在回调里面处理问
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack学习</title>
    <link href="https://wangyx233.github.io/2018/06/15/webpack%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wangyx233.github.io/2018/06/15/webpack学习/</id>
    <published>2018-06-15T08:34:01.696Z</published>
    <updated>2019-02-14T02:49:53.691Z</updated>
    
    <content type="html"><![CDATA[<ol><li>postcss 配置，post.config.js，同时webpack.config.js</li><li>mini-css-extract-plugin 与style-loader不共存</li><li>注意路径和文件名，仔细，认真</li><li>ico图片引入，没什么区别？</li><li>可自动设置dist文件夹下的文件，生成文件的目录你来掌握。</li><li>注意图片引入的路径,使用file-loader，url-loader引入的图片需要配合require使用，才能打包。url可以指定图片大小转换成base64等。<br>若不用require，直接src，需要把图片copy到打包后的文件。</li><li>react-hot-loader 与webpack 自带的hot不相互兼容。只能用一个。</li><li>webpack 的publicpath 定义的是服务在哪个文件下启动的，content可以定义文件的目录。</li><li>静态文件可生成hash模式，避免缓存。</li><li>babel也需要相应的配置。配合babel-import-plugin可以进行ui库的部分引入。还要注意选择babel的stage</li><li>react route4 webpack 服务器，用BrowserRouter,historyApiFallback: true</li></ol><p>gulp 与 webpack的区别<br>gulp 是任务流的，和task有关。<br>webpack 的核心是根据模块构建项目。<br>Webpack 的核心就是模块化地组织，模块化地依赖，然后模块化地打包。相对来上，场景局限在前端模块化打包上；虽然用 gulp + 插件的方式也能实现，但目前看 Webpack 在依赖的模块化构建上是无人能够替代的。<br>gulp 版本号。<br>可以在打包的时候，打入不同的文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;postcss 配置，post.config.js，同时webpack.config.js&lt;/li&gt;
&lt;li&gt;mini-css-extract-plugin 与style-loader不共存&lt;/li&gt;
&lt;li&gt;注意路径和文件名，仔细，认真&lt;/li&gt;
&lt;li&gt;ic
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Echarts3.5.0以上世界地图nameMap变更</title>
    <link href="https://wangyx233.github.io/2017/06/27/Echarts3.5.0%E4%BB%A5%E4%B8%8A%E4%B8%96%E7%95%8C%E5%9C%B0%E5%9B%BEnameMap%E4%BF%AE%E6%94%B9/"/>
    <id>https://wangyx233.github.io/2017/06/27/Echarts3.5.0以上世界地图nameMap修改/</id>
    <published>2017-06-27T09:23:11.000Z</published>
    <updated>2017-06-27T09:29:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天发现使用Echarts，nameMap渲染的世界地图，没有显示美国的数据，美国的区域显示的为United States。经过查找发现，Echarts应该是在3.5.0版本的时候，对world.js的一些国家名称进行了变更，从而导致用官网实例提供的nameMap,无法匹配到国家，进而无法显示。<br>大致看了一下地图，修改后对应的国家信息为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var nameMap =&#123;</span><br><span class="line">  &apos;Central African Rep.&apos;:&apos;中非共和国&apos;,</span><br><span class="line">  &apos;Dem. Rep. Congo&apos;:&apos;刚果民主共和国&apos;,</span><br><span class="line">  &apos;Lao PDR&apos;:&apos;老挝&apos;,</span><br><span class="line">  &apos;W. Sahara&apos;:&apos;西撒哈拉&apos;,</span><br><span class="line">  &apos;Tanzania&apos;:&apos;坦桑尼亚联合共和国&apos;,</span><br><span class="line">  &apos;United States&apos;:&apos;美国&apos;,</span><br><span class="line">  &apos;Korea&apos;: &apos;韩国&apos;,</span><br><span class="line">  &apos;Dem. Rep. Korea&apos;: &apos;朝鲜&apos;,</span><br><span class="line">  &apos;Congo&apos;: &apos;刚果共和国&apos;,</span><br><span class="line">  &apos;Solomon Is.&apos;: &apos;所罗门群岛&apos;,</span><br><span class="line">  &apos;Dominican Rep.&apos;:&apos;多明尼加共和国&apos;,</span><br><span class="line">  &apos;S. Sudan&apos;: &apos;南苏丹&apos; ,</span><br><span class="line">  &quot;Côte d&apos;Ivoire&quot;: &apos;科特迪瓦&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天发现使用Echarts，nameMap渲染的世界地图，没有显示美国的数据，美国的区域显示的为United States。经过查找发现，Echarts应该是在3.5.0版本的时候，对world.js的一些国家名称进行了变更，从而导致用官网实例提供的nameMap,无法匹配
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一些设计知识~</title>
    <link href="https://wangyx233.github.io/2017/06/21/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6/"/>
    <id>https://wangyx233.github.io/2017/06/21/写给大家看的设计书/</id>
    <published>2017-06-21T03:37:56.000Z</published>
    <updated>2017-06-26T10:56:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近要看的书好多，全都在排排坐，先挑了一本设计类的书籍《写给大家看的设计书》</p><h3 id="设计的四大原则"><a href="#设计的四大原则" class="headerlink" title="设计的四大原则"></a>设计的四大原则</h3><h6 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h6><p>对比是为页面增加视觉效果的最有效的途径,也是在不同元素之间建立一种有组织的层次结构最有效方法。要记住一个重要规则:要想实现有效的对比,对比就必须 强烈。千万不要畏畏缩缩。<br>字体的对比，颜色的对比，一定要保持强烈，差别不大的对比没有效果。<br>对比的根本目的有两个,这两个目的相辅相成,无法分开。一个目的是增强页面的效果,如果一个页面看起来很有意思,往往更有可读性。另一个目的是有助于信息的组织。读者应当能立即了解信息以何种方式组织,以及从一项到另一项的逻辑流程。对比元素不能让读者混淆,也不能错误地强调重点(即本不该是重点的元素)。</p><h6 id="重复-一致性"><a href="#重复-一致性" class="headerlink" title="重复-一致性"></a>重复-一致性</h6><p>设计的某些方面需要在整个作品中重复。控制读者视线，设计中视觉元素的重复可以将作品中的各部分连在一起,从而统一并增强整个作品。<br>重复的目的就是统一,并增强视觉效果。不要低估页面视觉效果的威力,如果一个作品看起来很有趣,它往往也更易于阅读。<br>要避免太多地重复一个元素,重复太多会让人讨厌。要注意对比的价值<br>可以通过字体选择、线宽、颜色、形状、大小、空间等来增加对比。 增加对比很容易,途径有很多,这可能是增加视觉效果最有意思也最让人满意的方 法了。重要的是:对比一定要强烈!</p><a id="more"></a><h6 id="对齐-统一性"><a href="#对齐-统一性" class="headerlink" title="对齐-统一性"></a>对齐-统一性</h6><p>任何元素都不能在页面上随意安放。每一项都应当与页面上的 某个内容存在某种视觉联系。<br>对齐方式的选择，左右对齐比居中对齐多了一条无形的对齐基准，效果更好。<br>不是不推荐居中，而是注意居中对齐的应用场景，让居中的效果明显一些，生动一些，比如调整位置，改变字体等。<br>在设计的最初，最好坚持，只使用一种对齐方式！<br>页面的元素不要所以摆放，确保互相有一种对齐方式，人的视觉喜欢有序的东西，并且利于信息的表达。</p><blockquote><p>绝对不要在左对齐的正文或缩进的文本上方将标题居中。如果文本没有明确的左边界和右边界,就无法区分标题是否确实居中,看起来它只是悬挂着而已。</p></blockquote><p>找到一条明确的对齐线，并且以此为标准；如果有照片或图片,让它们和一边或基线对齐，在打破规 则之前必须清楚规则是什么。<br>对齐的根本目的是使页面统一而且有条理。<br>注意：<br>要避免在页面上混合使用多种文本对齐方式(也就是说,不要将某些文本居中,而 另外一些文本右对齐)。<br>另外,要着力避免居中对齐,除非你有意识地想要创建一种比较正式、稳重(通常也更乏味)的表示。并不是完全杜绝使用居中对齐,有时可以有意地选择这种对齐方式,但是不要把它作为默认选择。</p><h6 id="亲密性–有组织性"><a href="#亲密性–有组织性" class="headerlink" title="亲密性–有组织性"></a>亲密性–有组织性</h6><p>将相关的项组织在一起，在一个页面上,物理位置的接近就意味着存在关联。如果多个项相互之间有很近的亲密性,它们就会成为一个视觉单元,而不是多个孤<br>立的元素。<br>布局的时候一定要注意明确元素与其所属元素是否在一起，留意无关元素。<br>善用空白，注意各个元素之间的关系，关注空间。<br>注意：<br>1、避免一个页面上有太多孤立的元素。 不要在元素之间留出同样大小的空白,除非各组同属于一个子集。<br>2、标题、子标题、图表标题、图片能否归入其相关材料?在这个问题上一定要非常清 楚(哪怕只有一点含糊都要尽量避免)。在有很近亲密性的元素之间建立关系。<br>3、不同属一组的元素之间不要建立关系!如果元素彼此无关,要把它们分开。 不要仅仅因为有空白就把元素放在角落或中央。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要看的书好多，全都在排排坐，先挑了一本设计类的书籍《写给大家看的设计书》&lt;/p&gt;
&lt;h3 id=&quot;设计的四大原则&quot;&gt;&lt;a href=&quot;#设计的四大原则&quot; class=&quot;headerlink&quot; title=&quot;设计的四大原则&quot;&gt;&lt;/a&gt;设计的四大原则&lt;/h3&gt;&lt;h6 id=&quot;对比&quot;&gt;&lt;a href=&quot;#对比&quot; class=&quot;headerlink&quot; title=&quot;对比&quot;&gt;&lt;/a&gt;对比&lt;/h6&gt;&lt;p&gt;对比是为页面增加视觉效果的最有效的途径,也是在不同元素之间建立一种有组织的层次结构最有效方法。要记住一个重要规则:要想实现有效的对比,对比就必须 强烈。千万不要畏畏缩缩。&lt;br&gt;字体的对比，颜色的对比，一定要保持强烈，差别不大的对比没有效果。&lt;br&gt;对比的根本目的有两个,这两个目的相辅相成,无法分开。一个目的是增强页面的效果,如果一个页面看起来很有意思,往往更有可读性。另一个目的是有助于信息的组织。读者应当能立即了解信息以何种方式组织,以及从一项到另一项的逻辑流程。对比元素不能让读者混淆,也不能错误地强调重点(即本不该是重点的元素)。&lt;/p&gt;
&lt;h6 id=&quot;重复-一致性&quot;&gt;&lt;a href=&quot;#重复-一致性&quot; class=&quot;headerlink&quot; title=&quot;重复-一致性&quot;&gt;&lt;/a&gt;重复-一致性&lt;/h6&gt;&lt;p&gt;设计的某些方面需要在整个作品中重复。控制读者视线，设计中视觉元素的重复可以将作品中的各部分连在一起,从而统一并增强整个作品。&lt;br&gt;重复的目的就是统一,并增强视觉效果。不要低估页面视觉效果的威力,如果一个作品看起来很有趣,它往往也更易于阅读。&lt;br&gt;要避免太多地重复一个元素,重复太多会让人讨厌。要注意对比的价值&lt;br&gt;可以通过字体选择、线宽、颜色、形状、大小、空间等来增加对比。 增加对比很容易,途径有很多,这可能是增加视觉效果最有意思也最让人满意的方 法了。重要的是:对比一定要强烈!&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>D3.js学习</title>
    <link href="https://wangyx233.github.io/2017/06/21/D3.js%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wangyx233.github.io/2017/06/21/D3.js学习/</id>
    <published>2017-06-21T02:47:53.000Z</published>
    <updated>2017-06-21T03:37:59.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>D3.js实现数据和元素的绑定<br>对于DOM结点的选择，d3.select(‘tag’)选择第一个元素,d3.selectAll(‘tag’)选择所有的元素。<br>对于数据的绑定，tag.datum()将一个数据绑定到元素上，tag.data()将数组内元素分别绑定各元素。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var body = d3.select(&apos;body&apos;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;D3.js实现数据和元素的绑定&lt;br&gt;对于DOM结点的选择，d3.select(‘tag’)选择第一个元素,d3.selectAll(‘tag’)选择所有的元素。&lt;br&gt;对于数据的绑定，tag.datum()将一个数据绑定到元素上，tag.data()将数组内元
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Canvas学习</title>
    <link href="https://wangyx233.github.io/2017/06/12/Canvas%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wangyx233.github.io/2017/06/12/Canvas学习/</id>
    <published>2017-06-12T05:55:20.000Z</published>
    <updated>2018-05-21T12:26:01.640Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;canvas&gt;标签定义一个矩形框画布，默认没有边框和内容,默认大小为300像素×150像素(wxh)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;</span><br><span class="line">style=&quot;border:1px solid #000000;&quot;&gt;</span><br><span class="line">若浏览器不支持canvas标签，将显示这些文字</span><br><span class="line">&lt;/canvas&gt;</span><br></pre></td></tr></table></figure><p>在Js文件中绘制Canvas元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var c=document.getElementById(&quot;myCanvas&quot;);</span><br><span class="line">if(c.getContext(&apos;2d&apos;))&#123; //支持性检查</span><br><span class="line">  var ctx=c.getContext(&quot;2d&quot;);//获取渲染上下文，参数为上下文的格式</span><br><span class="line">  ctx.fillStyle=&quot;#FF0000&quot;; //填充样式，可为颜色、图案、渐变等。</span><br><span class="line">  ctx.fillRect(0,0,150,75);//矩形的填充方法fillRect(x,y,width,height)，矩形左上角坐标为(0,0)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">  // canvas-unsupported code here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h6><p>canvas支持一种原生的图形绘制-矩形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fillRect(x, y, width, height) //绘制一个填充的矩形</span><br><span class="line">strokeRect(x, y, width, height) //绘制一个矩形的边框</span><br><span class="line">clearRect(x, y, width, height) //清除指定矩形区域，让清除部分完全透明</span><br><span class="line">rect(x, y, width, height) //绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。</span><br></pre></td></tr></table></figure><a id="more"></a><h6 id="画路径"><a href="#画路径" class="headerlink" title="画路径"></a>画路径</h6><p>定义开始坐标 moveTo(x,y)<br>定义结束坐标 lineTo(x,y)<br>绘制路径轮廓 stroke()<br>beginPath() 新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。<br>closePath() 闭合路径之后图形绘制命令又重新指向到上下文中。<br>.fill() 进行图形的填充，会进行路径的自动闭合<br>.stroke() 绘制轮廓，需要配合closePath进行路径的闭合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(75,50);</span><br><span class="line">ctx.lineTo(100,75);</span><br><span class="line">ctx.lineTo(100,25);</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure><h6 id="画圆弧"><a href="#画圆弧" class="headerlink" title="画圆弧"></a>画圆弧</h6><p>用arc()方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arc(x, y, radius, startAngle, endAngle, anticlockwise)</span><br><span class="line">画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。</span><br><span class="line">注意：arc()函数中的角度单位是弧度，不是度数。角度与弧度的js表达式:radians=(Math.PI/180)*degrees</span><br></pre></td></tr></table></figure><h6 id="画贝塞尔曲线"><a href="#画贝塞尔曲线" class="headerlink" title="画贝塞尔曲线"></a>画贝塞尔曲线</h6><p>quadraticCurveTo(cp1x, cp1y, x, y)<br>绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。<br>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)<br>绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 一颗心</span><br><span class="line">var heart = document.getElementById(&apos;heart&apos;);</span><br><span class="line">var heartx = heart.getContext(&apos;2d&apos;);</span><br><span class="line">heartx.beginPath();</span><br><span class="line">heartx.moveTo(75,40);</span><br><span class="line">heartx.bezierCurveTo(75,37,70,25,50,25);</span><br><span class="line">heartx.bezierCurveTo(20,25,20,62.5,20,62.5);</span><br><span class="line">heartx.bezierCurveTo(20,80,40,102,75,120);</span><br><span class="line">heartx.bezierCurveTo(110,102,130,80,130,62.5);</span><br><span class="line">heartx.bezierCurveTo(130,62.5,130,25,100,25);</span><br><span class="line">heartx.bezierCurveTo(85,25,75,37,75,40);</span><br><span class="line">heartx.fill();</span><br></pre></td></tr></table></figure><p>save()<br>restore()<br>rotate() 中心在圆点，<br>translate重新映射画布上(0,0)的位置</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;lt;canvas&amp;gt;标签定义一个矩形框画布，默认没有边框和内容,默认大小为300像素×150像素(wxh)。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;canvas id=&amp;quot;myCanvas&amp;quot; width=&amp;quot;200&amp;quot; height=&amp;quot;100&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;style=&amp;quot;border:1px solid #000000;&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;若浏览器不支持canvas标签，将显示这些文字&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/canvas&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在Js文件中绘制Canvas元素。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var c=document.getElementById(&amp;quot;myCanvas&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if(c.getContext(&amp;apos;2d&amp;apos;))&amp;#123; //支持性检查&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var ctx=c.getContext(&amp;quot;2d&amp;quot;);//获取渲染上下文，参数为上下文的格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ctx.fillStyle=&amp;quot;#FF0000&amp;quot;; //填充样式，可为颜色、图案、渐变等。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ctx.fillRect(0,0,150,75);//矩形的填充方法fillRect(x,y,width,height)，矩形左上角坐标为(0,0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  // canvas-unsupported code here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h6 id=&quot;画矩形&quot;&gt;&lt;a href=&quot;#画矩形&quot; class=&quot;headerlink&quot; title=&quot;画矩形&quot;&gt;&lt;/a&gt;画矩形&lt;/h6&gt;&lt;p&gt;canvas支持一种原生的图形绘制-矩形&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fillRect(x, y, width, height) //绘制一个填充的矩形&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;strokeRect(x, y, width, height) //绘制一个矩形的边框&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;clearRect(x, y, width, height) //清除指定矩形区域，让清除部分完全透明&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rect(x, y, width, height) //绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Three.js学习笔记</title>
    <link href="https://wangyx233.github.io/2017/06/05/three.js%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <id>https://wangyx233.github.io/2017/06/05/three.js学习指南/</id>
    <published>2017-06-05T05:59:18.000Z</published>
    <updated>2017-06-20T07:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>一切都建立在引入Three.js后，得到的全局变量THREE。<br>对于页面中，存放渲染效果的元素，可以是普通的div，也可以是canvas。<br>对于div，渲染时添加节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var renderer = new THREE.WebGLRenderer();</span><br><span class="line">renderer.setSize(400, 300);</span><br><span class="line">document.getElementById(&apos;test&apos;).appendChild(renderer.domElement);</span><br><span class="line">renderer.setClearColor(0x000000);//清除原本所在页面颜色，并设置</span><br></pre></td></tr></table></figure><p>而对于定义的canvas标签，其定义及渲染：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=&quot;mainCanvas&quot; width=&quot;400px&quot; height=&quot;300px&quot; &gt;&lt;/canvas&gt;</span><br><span class="line">var renderer = new THREE.WebGLRenderer(&#123;</span><br><span class="line">                    canvas: document.getElementById(&apos;mainCanvas&apos;)&#125;);</span><br></pre></td></tr></table></figure><p>基本概念</p><ol><li>主要分为三大部分，场景（scene）、照相机（camera）、渲染器（renderer）</li><li>首先定义容器渲染所在的DOM包括宽高、颜色等，利用照相机(投影方式)把作为容器的场景渲染到页面上。</li><li>声明渲染器对象renderer，canvas对象的获取方法为renderer.domElement，相机也需要加到场景中去</li></ol><a id="more"></a><h5 id="3D世界"><a href="#3D世界" class="headerlink" title="3D世界"></a>3D世界</h5><p>帧数：图形处理器每秒钟能够刷新几次，通常用fps（Frames Per Second）来表示。</p><h6 id="最开始可以选择引入stat-js记录帧数"><a href="#最开始可以选择引入stat-js记录帧数" class="headerlink" title="最开始可以选择引入stat.js记录帧数"></a>最开始可以选择引入stat.js记录帧数</h6><p>1、new 一个stats对象，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stats = new Stats();</span><br></pre></td></tr></table></figure><p>2、将这个对象加入到html网页中去，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stats.domElement.style.position = &apos;absolute&apos;;</span><br><span class="line">stats.domElement.style.left = &apos;0px&apos;;</span><br><span class="line">stats.domElement.style.top = &apos;0px&apos;;</span><br><span class="line">document.body.appendChild(stat.domElement);</span><br></pre></td></tr></table></figure><p>3、调用函数来统计时间和帧数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stats.update();</span><br><span class="line">或者</span><br><span class="line">stats.begin();</span><br><span class="line">funtion()&#123;&#125;;</span><br><span class="line">stats.end();</span><br></pre></td></tr></table></figure><p>tween.js？</p><h6 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h6><p>相机两种，正交投影相机和透视投影相机，前者是远近的比例相同，而后者具有近大远小的特点。<br>正交投影相机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">THREE.OrthographicCamera(left, right, top, bottom, near, far)</span><br><span class="line">其中，near，far代表相机的深度，为正值。在视景体（Frustum）中的物体才会渲染到页面，相机截取的是对称的</span><br></pre></td></tr></table></figure><p>透视投影相机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">THREE.PerspectiveCamera( fov, aspect, near, far )</span><br><span class="line">fov 视角：视野范围的角度；aspect：横纵比 Width/Height; near:近平面的距离； far远平面的距离</span><br></pre></td></tr></table></figure><p>相机有两个重要的参数</p><blockquote><p>camera.position：控制相机在整个3D环境中的位置（取值为3维坐标对象-THREE.Vector3(x,y,z)）<br>camera.lookAt：控制相机的焦点位置，决定相机的朝向（取值为3维坐标对象-THREE.Vector3(x,y,z)）</p></blockquote><p>应用:<br>设置相机的焦点为原点或者物体的位置坐标，camera.lookAt(new THREE.Vector3(0,0,0))，改变相机的位置camera.position，可以实现围绕物体360度观看物体的效果。<br>相机lookAt与position的设置可以实现以不同视角观察物体的效果。</p><h6 id="要有光！"><a href="#要有光！" class="headerlink" title="要有光！"></a>要有光！</h6><p>光用THREE.Light(hex)，hex16进制的颜色表示；材质在很大程度上，是由光决定的。</p><ul><li>环境光<br>环境光没有明确的光源位置，在各处的亮度也是一致的，设定是只需指定光的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.AmbientLight(hex)</span><br></pre></td></tr></table></figure><p>环境光并不影响物体的color属性，而是ambient属性，默认值为0xffffff。所以，环境光一般设为白色或者灰色</p><ul><li>点光源<br>光源大小可以看做是一个点，照到不同物体上亮度是线性递减的。离光源越远，物体越暗。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">THREE.PointLight(hex, intensity, distance)</span><br><span class="line">其中，intensity是亮度，缺省值为1，表示100%亮度；distance是光源最远照射到的距离，缺省值为0。</span><br><span class="line">var light = new THREE.PointLight(0xffffff, 2, 100);</span><br><span class="line">light.position.set(0, 1.5, 2);</span><br><span class="line">scene.add(light);</span><br></pre></td></tr></table></figure><ul><li>平行光<br>对于任意平行的平面，平行光照射的亮度都是相同的，而与平面所在位置无关。而光源位置的设置异常关键。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">THREE.DirectionalLight(hex, intensity)</span><br><span class="line">light.position.set(2, 5, 3);</span><br></pre></td></tr></table></figure><p>光源的位置并不意味着光从(2, 5, 3)点发出，而是以矢量(-2, -5, -3)的方向照射到所有平面。因此，平面亮度与平面的位置无关，而只与平面的法向量相关。</p><ul><li>聚光灯<br>类似圆锥形的光线，类似现实中的聚光灯模型。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">THREE.SpotLight(hex, intensity, distance, angle, exponent)</span><br><span class="line">angle是聚光灯的张角，缺省值是Math.PI / 3，最大值是Math.PI / 2；exponent是光强在偏离target的衰减指数（target需要定义，缺省值为(0, 0, 0)），缺省值是10。</span><br><span class="line">light.position.set(x1, y1, z1);</span><br><span class="line">light.target.position.set(x2, y2, z2);</span><br></pre></td></tr></table></figure><p>target还可以指定为物体，实现真正的聚光灯效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1),</span><br><span class="line">                    new THREE.MeshLambertMaterial(&#123;color: 0x00ff00&#125;));</span><br><span class="line">var light = new THREE.SpotLight(0xffff00, 1, 100, Math.PI / 6, 25);</span><br><span class="line">light.target = cube;</span><br></pre></td></tr></table></figure><ul><li>阴影<br>Three.js中，能形成阴影的光源只有THREE.DirectionalLight与THREE.SpotLight；能表现阴影效果的材质只有THREE.LambertMaterial与THREE.PhongMaterial。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 初始化，渲染器渲染阴影</span><br><span class="line">renderer.shadowMapEnabled = true;</span><br><span class="line">2. 对于要产生阴影的物体调用</span><br><span class="line">xxx.castShadow = true;</span><br><span class="line">3. 接收阴影的物体</span><br><span class="line">xxx.receiveShadow = true;</span><br></pre></td></tr></table></figure><p>同时，需要设置光源的阴影属性<br>1、 聚光灯，需要设置shadowCameraNear、shadowCameraFar、shadowCameraFov<br>2、 平行光，需要设置shadowCameraNear、shadowCameraFar、shadowCameraLeft、shadowCameraRight、shadowCameraTop以及shadowCameraBottom六个值，相当于正交投影照相机的六个面。只有在这六个面围成的长方体内的物体才能产生阴影效果。<br>在调试阴影效果时，可以开启相机位置：light.shadowCameraVisible = true。<br>阴影的深浅可以通过shadowDarkness设置(0,1)，值越小，阴影颜色越小。<br>另一种实现阴影的方法是Shadow Mapping，即阴影通过贴图的方式贴上来。贴图大小可通过shadowMapWidth与shadowMapHeight来设置。</p><h6 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h6><p>场景中的物体，由几何形状(Geometry)和材质(Material)组成，设置其name属性可以通过scene.getObjectByName(name)获取该物体对象;</p><ul><li>几何形状<br>1、立方体</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">THREE.CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)</span><br><span class="line">其中，后三个参数为宽，高，深度的分段</span><br></pre></td></tr></table></figure><p>2、平面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.PlaneGeometry(width, height, widthSegments, heightSegments)</span><br></pre></td></tr></table></figure><p>3、球体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">THREE.SphereGeometry(radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength)</span><br><span class="line">其中，各参数分别为，半径，经度分割数，纬度分割数，经度开始弧度，经度跨越弧度，纬度开始弧度，纬度跨越弧度</span><br></pre></td></tr></table></figure><p>4、圆形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THREE.CircleGeometry(radius, segments, thetaStart, thetaLength)</span><br></pre></td></tr></table></figure><p>5、圆柱体，圆台等参考<a href="http://www.ituring.com.cn/book/miniarticle/50172" target="_blank" rel="noopener">http://www.ituring.com.cn/book/miniarticle/50172</a></p><ul><li>材质<br>1、 BasicMaterial基本材质不受光照阴影等的影响。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">THREE.MeshBasicMaterial(&#123;</span><br><span class="line">  visible：是否可见，默认为true</span><br><span class="line">  side：渲染面片正面或是反面，默认为正面THREE.FrontSide，可设置为反面THREE.BackSide，或双面THREE.DoubleSide</span><br><span class="line">  wireframe：是否渲染线而非面，默认为false</span><br><span class="line">  color：十六进制RGB颜色，如红色表示为0xff0000</span><br><span class="line">  map：使用纹理贴图</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>2、 Lambert材质（MeshLambertMaterial）是符合Lambert光照模型的材质。只考虑漫反射而不考虑镜面反射的效果，因而对于金属、镜子等需要镜面反射效果的物体就不适应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: //散射光反射能力</span><br><span class="line">    ambient: //环境光反射</span><br><span class="line">    emissive: 0xff0000 //自发光</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3、 Phong材质（MeshPhongMaterial）是符合Phong光照模型的材质。和Lambert不同的是，Phong模型考虑了镜面反射的效果，因此对于金属、镜面的表现尤为适合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshPhongMaterial(&#123;</span><br><span class="line">    color:</span><br><span class="line">    ambient: //环境光反射</span><br><span class="line">    emissive: 0xff0000 //自发光</span><br><span class="line">    specular: 0xff0000 //镜面反射系数</span><br><span class="line">    shininess: 1000 //当shininess值越大时，高光的光斑越小，默认值为30。</span><br></pre></td></tr></table></figure><p>4、 法向材质可以将材质的颜色设置为其法向量的方向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new THREE.MeshNormalMaterial()</span><br></pre></td></tr></table></figure><p>材质的颜色与照相机与该物体的角度相关<br>5、 材质纹理贴图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var texture = THREE.ImageUtils.loadTexture(&apos;../img/0.png&apos;);</span><br><span class="line">其中，THREE.ImageUtils.loadTexture现在由THREE.TextureLoader()代替</span><br><span class="line">var loader = new THREE.TextureLoader();</span><br><span class="line">var texture = loader.load(&apos;url&apos;, function() &#123;</span><br><span class="line">    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;</span><br><span class="line">    texture.repeat.set(8, 8);</span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="场景中常见的物体"><a href="#场景中常见的物体" class="headerlink" title="场景中常见的物体"></a>场景中常见的物体</h6><p>点是基础，两个点组成一条线，不在一条直线上的三个点组成一个三角形面，这种模型成为Mesh模型.<br>一条线由点，材质，和颜色组成。<br>普通的点用THREE.Vector3定义放在THREE.Geometry对象vertices数组中，<br>材质由THREE.LineBasicMaterial定义，<br>线的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var line = new THREE.Line( geometry, material, THREE.LinePieces );</span><br></pre></td></tr></table></figure><p>最常见的物体–网格，除此之外还有线段（Line）、骨骼（Bone）、粒子系统（ParticleSystem）等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mesh(geometry, material)</span><br><span class="line">通过属性进行访问mesh.material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: 0xff0000</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>具有位置，缩放，和旋转三个属性。position、scale、rotation。它们都是THREE.Vector3实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mesh.position = new THREE.Vector3(1.5, -0.5, 0);</span><br><span class="line">mesh.position.set(1.5, -0.5, 0);</span><br><span class="line">mesh.position.z = 1;</span><br></pre></td></tr></table></figure><h6 id="当当当-动画"><a href="#当当当-动画" class="headerlink" title="当当当 动画"></a>当当当 动画</h6><p>场景动起来的方式，一是物体在坐标轴里移动，摄像机不动；一种是物体不动，camera移动，用requestAnimationFrame(render)进行渲染循环<br>1、用定时器setInterval方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id = setInterval(fun, time);</span><br><span class="line">clearInterval(id);</span><br><span class="line">帧数可以通过time控制，time = 1000ms/frame</span><br></pre></td></tr></table></figure><p>2、用requestAnimationFrame方法，h5的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var requestAnimationFrame = window.requestAnimationFrame</span><br><span class="line">        || window.mozRequestAnimationFrame</span><br><span class="line">        || window.webkitRequestAnimationFrame</span><br><span class="line">        || window.msRequestAnimationFrame;</span><br><span class="line">window.requestAnimationFrame = requestAnimationFrame;</span><br><span class="line">id = requestAnimationFrame(draw);</span><br></pre></td></tr></table></figure><h6 id="支持引入外部模型"><a href="#支持引入外部模型" class="headerlink" title="支持引入外部模型"></a>支持引入外部模型</h6><p>需要加载额外的辅助函数，地址参考：<a href="https://github.com/mrdoob/three.js/tree/master/examples/js/loaders" target="_blank" rel="noopener">https://github.com/mrdoob/three.js/tree/master/examples/js/loaders</a><br>1、 例如，导入.obj格式的模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var loader = new THREE.OBJLoader();</span><br><span class="line">loader.load(&apos;../lib/port.obj&apos;, function(obj) &#123;</span><br><span class="line">  //默认情况只有正面绘制，双面绘制</span><br><span class="line">    obj.traverse(function(child) &#123;</span><br><span class="line">        if (child instanceof THREE.Mesh) &#123;</span><br><span class="line">            child.material.side = THREE.DoubleSide;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    mesh = obj;</span><br><span class="line">    scene.add(obj);//添加到场景</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2、 对于引入模型的材质设置，有两种方式：</p><ul><li>在引入模型的回调函数中设置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj.traverse(function(child) &#123;</span><br><span class="line">        if (child instanceof THREE.Mesh) &#123;</span><br><span class="line">            child.material = new THREE.MeshLambertMaterial(&#123;</span><br><span class="line">                color: 0xffff00,</span><br><span class="line">                side: THREE.DoubleSide</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>在模型软件中设置，并引用。例如，.obj的模型与.mtl的材质</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//引入js</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;MTLLoader.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;OBJMTLLoader.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">var loader = new THREE.OBJMTLLoader();</span><br><span class="line">loader.addEventListener(&apos;load&apos;, function(event) &#123;</span><br><span class="line">    var obj = event.content;</span><br><span class="line">    mesh = obj;</span><br><span class="line">    scene.add(obj);</span><br><span class="line">&#125;);</span><br><span class="line">loader.load(&apos;../lib/port.obj&apos;, &apos;../lib/port.mtl&apos;);</span><br></pre></td></tr></table></figure><h6 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h6><blockquote><p>FlyControls:飞行控制，用键盘和鼠标控制相机的移动和转动<br>OrbitControls::轨道控制器，模拟轨道中的卫星，绕某个对象旋转平移，用键盘和鼠标控制相机位置<br>PointerLockControls:指针锁定，鼠标离开画布依然能被捕捉到鼠标交互，主要用于游戏<br>TrackballControls：轨迹球控制器，通过键盘和鼠标控制前后左右平移和缩放场景<br>TransformControls:变换物体控制器，可以通过鼠标对物体的进行拖放等操作</p></blockquote><h6 id="不明觉厉着色器"><a href="#不明觉厉着色器" class="headerlink" title="不明觉厉着色器"></a>不明觉厉着色器</h6><p>WebGL基于OpenGL ES 2.0，着色器支持顶点着色器和片元着色器。<br>再战！<br>最常发生的错误就是忘记float类型和int类型不会自动转换</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一切都建立在引入Three.js后，得到的全局变量THREE。&lt;br&gt;对于页面中，存放渲染效果的元素，可以是普通的div，也可以是canvas。&lt;br&gt;对于div，渲染时添加节点：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var renderer = new THREE.WebGLRenderer();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;renderer.setSize(400, 300);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;document.getElementById(&amp;apos;test&amp;apos;).appendChild(renderer.domElement);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;renderer.setClearColor(0x000000);//清除原本所在页面颜色，并设置&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;而对于定义的canvas标签，其定义及渲染：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;canvas id=&amp;quot;mainCanvas&amp;quot; width=&amp;quot;400px&amp;quot; height=&amp;quot;300px&amp;quot; &amp;gt;&amp;lt;/canvas&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var renderer = new THREE.WebGLRenderer(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    canvas: document.getElementById(&amp;apos;mainCanvas&amp;apos;)&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;基本概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主要分为三大部分，场景（scene）、照相机（camera）、渲染器（renderer）&lt;/li&gt;
&lt;li&gt;首先定义容器渲染所在的DOM包括宽高、颜色等，利用照相机(投影方式)把作为容器的场景渲染到页面上。&lt;/li&gt;
&lt;li&gt;声明渲染器对象renderer，canvas对象的获取方法为renderer.domElement，相机也需要加到场景中去&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Three.js" scheme="https://wangyx233.github.io/tags/Three-js/"/>
    
  </entry>
  
  <entry>
    <title>hexo部署github的问题</title>
    <link href="https://wangyx233.github.io/2017/04/11/hexo%E9%83%A8%E7%BD%B2github%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://wangyx233.github.io/2017/04/11/hexo部署github的问题/</id>
    <published>2017-04-11T12:03:27.000Z</published>
    <updated>2017-06-05T12:21:43.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="用hexo搭建博客，配置直接部署到github的方法："><a href="#用hexo搭建博客，配置直接部署到github的方法：" class="headerlink" title="用hexo搭建博客，配置直接部署到github的方法："></a>用hexo搭建博客，配置直接部署到github的方法：</h5><p>1.安装 hexo-deployer-git插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>2.在hexo根目录的_config.yml中进行deploy的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: [github repository url] //eg:git@github.com:xxx.git or https://github.com/xxx.git</span><br><span class="line">    branch: master //branch name</span><br><span class="line">    message: &quot;Blog updated: &#123;&#123; now（&apos;YYYY-MM-DD&apos;）&#125;&#125;&quot; //commit message</span><br><span class="line">Ps:注意缩进和空格</span><br></pre></td></tr></table></figure><p>3.通过hexo deploy（即hexo d）命令进行部署，在此之前需要进行hexo generate（即hexo g）编译。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo-deployer-git插件的作用是生成.deploy_git文件，</span><br><span class="line">并且把hexo g编译后的public中的文件复制到.deploy_git文件夹下，</span><br><span class="line">然后进行git操作，推到远端github仓库。</span><br></pre></td></tr></table></figure><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><a id="more"></a><p>1.在用hexo d进行第一次部署时，需要将从public拷贝到.deploy_git文件夹下的所有文件进行commit操作（hexo d部署只会更新静态的html文件）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd .deploy_git</span><br><span class="line">git add --all -f</span><br><span class="line">git commit -m &quot;message&quot;</span><br><span class="line">git push origin branch</span><br></pre></td></tr></table></figure><p>2.说道部署至github，那前提是配置好github的username和password啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;用hexo搭建博客，配置直接部署到github的方法：&quot;&gt;&lt;a href=&quot;#用hexo搭建博客，配置直接部署到github的方法：&quot; class=&quot;headerlink&quot; title=&quot;用hexo搭建博客，配置直接部署到github的方法：&quot;&gt;&lt;/a&gt;用hexo搭建博客，配置直接部署到github的方法：&lt;/h5&gt;&lt;p&gt;1.安装 hexo-deployer-git插件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-deployer-git --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;2.在hexo根目录的_config.yml中进行deploy的配置&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    type: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    repo: [github repository url] //eg:git@github.com:xxx.git or https://github.com/xxx.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    branch: master //branch name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    message: &amp;quot;Blog updated: &amp;#123;&amp;#123; now（&amp;apos;YYYY-MM-DD&amp;apos;）&amp;#125;&amp;#125;&amp;quot; //commit message&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ps:注意缩进和空格&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;3.通过hexo deploy（即hexo d）命令进行部署，在此之前需要进行hexo generate（即hexo g）编译。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo-deployer-git插件的作用是生成.deploy_git文件，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;并且把hexo g编译后的public中的文件复制到.deploy_git文件夹下，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;然后进行git操作，推到远端github仓库。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;注意：&quot;&gt;&lt;a href=&quot;#注意：&quot; class=&quot;headerlink&quot; title=&quot;注意：&quot;&gt;&lt;/a&gt;注意：&lt;/h3&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://wangyx233.github.io/tags/hexo/"/>
    
      <category term="github" scheme="https://wangyx233.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wangyx233.github.io/2017/04/11/hello-world/"/>
    <id>https://wangyx233.github.io/2017/04/11/hello-world/</id>
    <published>2017-04-11T06:06:25.000Z</published>
    <updated>2017-06-05T12:13:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><a id="more"></a><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
