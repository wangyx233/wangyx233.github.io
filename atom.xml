<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangyx233.github.io/"/>
  <updated>2018-06-29T08:51:59.649Z</updated>
  <id>https://wangyx233.github.io/</id>
  
  <author>
    <name>Usaki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack学习</title>
    <link href="https://wangyx233.github.io/2018/06/15/webpack%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wangyx233.github.io/2018/06/15/webpack学习/</id>
    <published>2018-06-15T08:34:01.695Z</published>
    <updated>2018-06-29T08:51:59.649Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>postcss 配置，post.config.js，同时webpack.config.js</li>
<li>mini-css-extract-plugin 与style-loader不共存</li>
<li>注意路径和文件名，仔细，认真</li>
<li>ico图片引入，没什么区别？</li>
<li>可自动设置dist文件夹下的文件，生成文件的目录你来掌握。</li>
<li>注意图片引入的路径,使用file-loader，url-loader引入的图片需要配合require使用，才能打包。url可以指定图片大小转换成base64等。<br>若不用require，直接src，需要把图片copy到打包后的文件。</li>
<li>react-hot-loader 与webpack 自带的hot不相互兼容。只能用一个。</li>
<li>webpack 的publicpath 定义的是服务在哪个文件下启动的，content可以定义文件的目录。</li>
<li>静态文件可生成hash模式，避免缓存。</li>
<li>babel也需要相应的配置。配合babel-import-plugin可以进行ui库的部分引入。还要注意选择babel的stage</li>
<li>react route4 webpack 服务器，用BrowserRouter,historyApiFallback: true</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;postcss 配置，post.config.js，同时webpack.config.js&lt;/li&gt;
&lt;li&gt;mini-css-extract-plugin 与style-loader不共存&lt;/li&gt;
&lt;li&gt;注意路径和文件名，仔细，认真&lt;/li&gt;
&lt;li&gt;ic
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Echarts3.5.0以上世界地图nameMap变更</title>
    <link href="https://wangyx233.github.io/2017/06/27/Echarts3.5.0%E4%BB%A5%E4%B8%8A%E4%B8%96%E7%95%8C%E5%9C%B0%E5%9B%BEnameMap%E4%BF%AE%E6%94%B9/"/>
    <id>https://wangyx233.github.io/2017/06/27/Echarts3.5.0以上世界地图nameMap修改/</id>
    <published>2017-06-27T09:23:11.000Z</published>
    <updated>2017-06-27T09:29:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天发现使用Echarts，nameMap渲染的世界地图，没有显示美国的数据，美国的区域显示的为United States。经过查找发现，Echarts应该是在3.5.0版本的时候，对world.js的一些国家名称进行了变更，从而导致用官网实例提供的nameMap,无法匹配到国家，进而无法显示。<br>大致看了一下地图，修改后对应的国家信息为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var nameMap =&#123;</div><div class="line">  &apos;Central African Rep.&apos;:&apos;中非共和国&apos;,</div><div class="line">  &apos;Dem. Rep. Congo&apos;:&apos;刚果民主共和国&apos;,</div><div class="line">  &apos;Lao PDR&apos;:&apos;老挝&apos;,</div><div class="line">  &apos;W. Sahara&apos;:&apos;西撒哈拉&apos;,</div><div class="line">  &apos;Tanzania&apos;:&apos;坦桑尼亚联合共和国&apos;,</div><div class="line">  &apos;United States&apos;:&apos;美国&apos;,</div><div class="line">  &apos;Korea&apos;: &apos;韩国&apos;,</div><div class="line">  &apos;Dem. Rep. Korea&apos;: &apos;朝鲜&apos;,</div><div class="line">  &apos;Congo&apos;: &apos;刚果共和国&apos;,</div><div class="line">  &apos;Solomon Is.&apos;: &apos;所罗门群岛&apos;,</div><div class="line">  &apos;Dominican Rep.&apos;:&apos;多明尼加共和国&apos;,</div><div class="line">  &apos;S. Sudan&apos;: &apos;南苏丹&apos; ,</div><div class="line">  &quot;Côte d&apos;Ivoire&quot;: &apos;科特迪瓦&apos;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天发现使用Echarts，nameMap渲染的世界地图，没有显示美国的数据，美国的区域显示的为United States。经过查找发现，Echarts应该是在3.5.0版本的时候，对world.js的一些国家名称进行了变更，从而导致用官网实例提供的nameMap,无法匹配
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一些设计知识~</title>
    <link href="https://wangyx233.github.io/2017/06/21/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6/"/>
    <id>https://wangyx233.github.io/2017/06/21/写给大家看的设计书/</id>
    <published>2017-06-21T03:37:56.000Z</published>
    <updated>2017-06-26T10:56:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近要看的书好多，全都在排排坐，先挑了一本设计类的书籍《写给大家看的设计书》</p>
<h3 id="设计的四大原则"><a href="#设计的四大原则" class="headerlink" title="设计的四大原则"></a>设计的四大原则</h3><h6 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h6><p>对比是为页面增加视觉效果的最有效的途径,也是在不同元素之间建立一种有组织的层次结构最有效方法。要记住一个重要规则:要想实现有效的对比,对比就必须 强烈。千万不要畏畏缩缩。<br>字体的对比，颜色的对比，一定要保持强烈，差别不大的对比没有效果。<br>对比的根本目的有两个,这两个目的相辅相成,无法分开。一个目的是增强页面的效果,如果一个页面看起来很有意思,往往更有可读性。另一个目的是有助于信息的组织。读者应当能立即了解信息以何种方式组织,以及从一项到另一项的逻辑流程。对比元素不能让读者混淆,也不能错误地强调重点(即本不该是重点的元素)。</p>
<h6 id="重复-一致性"><a href="#重复-一致性" class="headerlink" title="重复-一致性"></a>重复-一致性</h6><p>设计的某些方面需要在整个作品中重复。控制读者视线，设计中视觉元素的重复可以将作品中的各部分连在一起,从而统一并增强整个作品。<br>重复的目的就是统一,并增强视觉效果。不要低估页面视觉效果的威力,如果一个作品看起来很有趣,它往往也更易于阅读。<br>要避免太多地重复一个元素,重复太多会让人讨厌。要注意对比的价值<br>可以通过字体选择、线宽、颜色、形状、大小、空间等来增加对比。 增加对比很容易,途径有很多,这可能是增加视觉效果最有意思也最让人满意的方 法了。重要的是:对比一定要强烈!</p>
<a id="more"></a>
<h6 id="对齐-统一性"><a href="#对齐-统一性" class="headerlink" title="对齐-统一性"></a>对齐-统一性</h6><p>任何元素都不能在页面上随意安放。每一项都应当与页面上的 某个内容存在某种视觉联系。<br>对齐方式的选择，左右对齐比居中对齐多了一条无形的对齐基准，效果更好。<br>不是不推荐居中，而是注意居中对齐的应用场景，让居中的效果明显一些，生动一些，比如调整位置，改变字体等。<br>在设计的最初，最好坚持，只使用一种对齐方式！<br>页面的元素不要所以摆放，确保互相有一种对齐方式，人的视觉喜欢有序的东西，并且利于信息的表达。</p>
<blockquote>
<p>绝对不要在左对齐的正文或缩进的文本上方将标题居中。如果文本没有明确的左边界和右边界,就无法区分标题是否确实居中,看起来它只是悬挂着而已。</p>
</blockquote>
<p>找到一条明确的对齐线，并且以此为标准；如果有照片或图片,让它们和一边或基线对齐，在打破规 则之前必须清楚规则是什么。<br>对齐的根本目的是使页面统一而且有条理。<br>注意：<br>要避免在页面上混合使用多种文本对齐方式(也就是说,不要将某些文本居中,而 另外一些文本右对齐)。<br>另外,要着力避免居中对齐,除非你有意识地想要创建一种比较正式、稳重(通常也更乏味)的表示。并不是完全杜绝使用居中对齐,有时可以有意地选择这种对齐方式,但是不要把它作为默认选择。</p>
<h6 id="亲密性–有组织性"><a href="#亲密性–有组织性" class="headerlink" title="亲密性–有组织性"></a>亲密性–有组织性</h6><p>将相关的项组织在一起，在一个页面上,物理位置的接近就意味着存在关联。如果多个项相互之间有很近的亲密性,它们就会成为一个视觉单元,而不是多个孤<br>立的元素。<br>布局的时候一定要注意明确元素与其所属元素是否在一起，留意无关元素。<br>善用空白，注意各个元素之间的关系，关注空间。<br>注意：<br>1、避免一个页面上有太多孤立的元素。 不要在元素之间留出同样大小的空白,除非各组同属于一个子集。<br>2、标题、子标题、图表标题、图片能否归入其相关材料?在这个问题上一定要非常清 楚(哪怕只有一点含糊都要尽量避免)。在有很近亲密性的元素之间建立关系。<br>3、不同属一组的元素之间不要建立关系!如果元素彼此无关,要把它们分开。 不要仅仅因为有空白就把元素放在角落或中央。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要看的书好多，全都在排排坐，先挑了一本设计类的书籍《写给大家看的设计书》&lt;/p&gt;
&lt;h3 id=&quot;设计的四大原则&quot;&gt;&lt;a href=&quot;#设计的四大原则&quot; class=&quot;headerlink&quot; title=&quot;设计的四大原则&quot;&gt;&lt;/a&gt;设计的四大原则&lt;/h3&gt;&lt;h6 id=&quot;对比&quot;&gt;&lt;a href=&quot;#对比&quot; class=&quot;headerlink&quot; title=&quot;对比&quot;&gt;&lt;/a&gt;对比&lt;/h6&gt;&lt;p&gt;对比是为页面增加视觉效果的最有效的途径,也是在不同元素之间建立一种有组织的层次结构最有效方法。要记住一个重要规则:要想实现有效的对比,对比就必须 强烈。千万不要畏畏缩缩。&lt;br&gt;字体的对比，颜色的对比，一定要保持强烈，差别不大的对比没有效果。&lt;br&gt;对比的根本目的有两个,这两个目的相辅相成,无法分开。一个目的是增强页面的效果,如果一个页面看起来很有意思,往往更有可读性。另一个目的是有助于信息的组织。读者应当能立即了解信息以何种方式组织,以及从一项到另一项的逻辑流程。对比元素不能让读者混淆,也不能错误地强调重点(即本不该是重点的元素)。&lt;/p&gt;
&lt;h6 id=&quot;重复-一致性&quot;&gt;&lt;a href=&quot;#重复-一致性&quot; class=&quot;headerlink&quot; title=&quot;重复-一致性&quot;&gt;&lt;/a&gt;重复-一致性&lt;/h6&gt;&lt;p&gt;设计的某些方面需要在整个作品中重复。控制读者视线，设计中视觉元素的重复可以将作品中的各部分连在一起,从而统一并增强整个作品。&lt;br&gt;重复的目的就是统一,并增强视觉效果。不要低估页面视觉效果的威力,如果一个作品看起来很有趣,它往往也更易于阅读。&lt;br&gt;要避免太多地重复一个元素,重复太多会让人讨厌。要注意对比的价值&lt;br&gt;可以通过字体选择、线宽、颜色、形状、大小、空间等来增加对比。 增加对比很容易,途径有很多,这可能是增加视觉效果最有意思也最让人满意的方 法了。重要的是:对比一定要强烈!&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>D3.js学习</title>
    <link href="https://wangyx233.github.io/2017/06/21/D3.js%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wangyx233.github.io/2017/06/21/D3.js学习/</id>
    <published>2017-06-21T02:47:53.000Z</published>
    <updated>2017-06-21T03:37:59.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>D3.js实现数据和元素的绑定<br>对于DOM结点的选择，d3.select(‘tag’)选择第一个元素,d3.selectAll(‘tag’)选择所有的元素。<br>对于数据的绑定，tag.datum()将一个数据绑定到元素上，tag.data()将数组内元素分别绑定各元素。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var body = d3.select(&apos;body&apos;);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;D3.js实现数据和元素的绑定&lt;br&gt;对于DOM结点的选择，d3.select(‘tag’)选择第一个元素,d3.selectAll(‘tag’)选择所有的元素。&lt;br&gt;对于数据的绑定，tag.datum()将一个数据绑定到元素上，tag.data()将数组内元
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Canvas学习</title>
    <link href="https://wangyx233.github.io/2017/06/12/Canvas%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wangyx233.github.io/2017/06/12/Canvas学习/</id>
    <published>2017-06-12T05:55:20.000Z</published>
    <updated>2018-05-21T12:26:01.639Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;canvas&gt;标签定义一个矩形框画布，默认没有边框和内容,默认大小为300像素×150像素(wxh)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;</div><div class="line">style=&quot;border:1px solid #000000;&quot;&gt;</div><div class="line">若浏览器不支持canvas标签，将显示这些文字</div><div class="line">&lt;/canvas&gt;</div></pre></td></tr></table></figure>
<p>在Js文件中绘制Canvas元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var c=document.getElementById(&quot;myCanvas&quot;);</div><div class="line">if(c.getContext(&apos;2d&apos;))&#123; //支持性检查</div><div class="line">  var ctx=c.getContext(&quot;2d&quot;);//获取渲染上下文，参数为上下文的格式</div><div class="line">  ctx.fillStyle=&quot;#FF0000&quot;; //填充样式，可为颜色、图案、渐变等。</div><div class="line">  ctx.fillRect(0,0,150,75);//矩形的填充方法fillRect(x,y,width,height)，矩形左上角坐标为(0,0)</div><div class="line">&#125;else &#123;</div><div class="line">  // canvas-unsupported code here</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h6><p>canvas支持一种原生的图形绘制-矩形</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fillRect(x, y, width, height) //绘制一个填充的矩形</div><div class="line">strokeRect(x, y, width, height) //绘制一个矩形的边框</div><div class="line">clearRect(x, y, width, height) //清除指定矩形区域，让清除部分完全透明</div><div class="line">rect(x, y, width, height) //绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。</div></pre></td></tr></table></figure>
<a id="more"></a>
<h6 id="画路径"><a href="#画路径" class="headerlink" title="画路径"></a>画路径</h6><p>定义开始坐标 moveTo(x,y)<br>定义结束坐标 lineTo(x,y)<br>绘制路径轮廓 stroke()<br>beginPath() 新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。<br>closePath() 闭合路径之后图形绘制命令又重新指向到上下文中。<br>.fill() 进行图形的填充，会进行路径的自动闭合<br>.stroke() 绘制轮廓，需要配合closePath进行路径的闭合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ctx.beginPath();</div><div class="line">ctx.moveTo(75,50);</div><div class="line">ctx.lineTo(100,75);</div><div class="line">ctx.lineTo(100,25);</div><div class="line">ctx.fill();</div></pre></td></tr></table></figure>
<h6 id="画圆弧"><a href="#画圆弧" class="headerlink" title="画圆弧"></a>画圆弧</h6><p>用arc()方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arc(x, y, radius, startAngle, endAngle, anticlockwise)</div><div class="line">画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。</div><div class="line">注意：arc()函数中的角度单位是弧度，不是度数。角度与弧度的js表达式:radians=(Math.PI/180)*degrees</div></pre></td></tr></table></figure>
<h6 id="画贝塞尔曲线"><a href="#画贝塞尔曲线" class="headerlink" title="画贝塞尔曲线"></a>画贝塞尔曲线</h6><p>quadraticCurveTo(cp1x, cp1y, x, y)<br>绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。<br>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)<br>绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 一颗心</div><div class="line">var heart = document.getElementById(&apos;heart&apos;);</div><div class="line">var heartx = heart.getContext(&apos;2d&apos;);</div><div class="line">heartx.beginPath();</div><div class="line">heartx.moveTo(75,40);</div><div class="line">heartx.bezierCurveTo(75,37,70,25,50,25);</div><div class="line">heartx.bezierCurveTo(20,25,20,62.5,20,62.5);</div><div class="line">heartx.bezierCurveTo(20,80,40,102,75,120);</div><div class="line">heartx.bezierCurveTo(110,102,130,80,130,62.5);</div><div class="line">heartx.bezierCurveTo(130,62.5,130,25,100,25);</div><div class="line">heartx.bezierCurveTo(85,25,75,37,75,40);</div><div class="line">heartx.fill();</div></pre></td></tr></table></figure>
<p>save()<br>restore()<br>rotate() 中心在圆点，<br>translate重新映射画布上(0,0)的位置</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;lt;canvas&amp;gt;标签定义一个矩形框画布，默认没有边框和内容,默认大小为300像素×150像素(wxh)。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;canvas id=&amp;quot;myCanvas&amp;quot; width=&amp;quot;200&amp;quot; height=&amp;quot;100&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;style=&amp;quot;border:1px solid #000000;&amp;quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;若浏览器不支持canvas标签，将显示这些文字&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/canvas&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在Js文件中绘制Canvas元素。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var c=document.getElementById(&amp;quot;myCanvas&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;if(c.getContext(&amp;apos;2d&amp;apos;))&amp;#123; //支持性检查&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  var ctx=c.getContext(&amp;quot;2d&amp;quot;);//获取渲染上下文，参数为上下文的格式&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ctx.fillStyle=&amp;quot;#FF0000&amp;quot;; //填充样式，可为颜色、图案、渐变等。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ctx.fillRect(0,0,150,75);//矩形的填充方法fillRect(x,y,width,height)，矩形左上角坐标为(0,0)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;else &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  // canvas-unsupported code here&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;画矩形&quot;&gt;&lt;a href=&quot;#画矩形&quot; class=&quot;headerlink&quot; title=&quot;画矩形&quot;&gt;&lt;/a&gt;画矩形&lt;/h6&gt;&lt;p&gt;canvas支持一种原生的图形绘制-矩形&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;fillRect(x, y, width, height) //绘制一个填充的矩形&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;strokeRect(x, y, width, height) //绘制一个矩形的边框&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;clearRect(x, y, width, height) //清除指定矩形区域，让清除部分完全透明&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;rect(x, y, width, height) //绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Three.js学习笔记</title>
    <link href="https://wangyx233.github.io/2017/06/05/three.js%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <id>https://wangyx233.github.io/2017/06/05/three.js学习指南/</id>
    <published>2017-06-05T05:59:18.000Z</published>
    <updated>2017-06-20T07:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>一切都建立在引入Three.js后，得到的全局变量THREE。<br>对于页面中，存放渲染效果的元素，可以是普通的div，也可以是canvas。<br>对于div，渲染时添加节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var renderer = new THREE.WebGLRenderer();</div><div class="line">renderer.setSize(400, 300);</div><div class="line">document.getElementById(&apos;test&apos;).appendChild(renderer.domElement);</div><div class="line">renderer.setClearColor(0x000000);//清除原本所在页面颜色，并设置</div></pre></td></tr></table></figure></p>
<p>而对于定义的canvas标签，其定义及渲染：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;canvas id=&quot;mainCanvas&quot; width=&quot;400px&quot; height=&quot;300px&quot; &gt;&lt;/canvas&gt;</div><div class="line">var renderer = new THREE.WebGLRenderer(&#123;</div><div class="line">                    canvas: document.getElementById(&apos;mainCanvas&apos;)&#125;);</div></pre></td></tr></table></figure></p>
<p>基本概念</p>
<ol>
<li>主要分为三大部分，场景（scene）、照相机（camera）、渲染器（renderer）</li>
<li>首先定义容器渲染所在的DOM包括宽高、颜色等，利用照相机(投影方式)把作为容器的场景渲染到页面上。</li>
<li>声明渲染器对象renderer，canvas对象的获取方法为renderer.domElement，相机也需要加到场景中去</li>
</ol>
<a id="more"></a>
<h5 id="3D世界"><a href="#3D世界" class="headerlink" title="3D世界"></a>3D世界</h5><p>帧数：图形处理器每秒钟能够刷新几次，通常用fps（Frames Per Second）来表示。</p>
<h6 id="最开始可以选择引入stat-js记录帧数"><a href="#最开始可以选择引入stat-js记录帧数" class="headerlink" title="最开始可以选择引入stat.js记录帧数"></a>最开始可以选择引入stat.js记录帧数</h6><p>1、new 一个stats对象，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stats = new Stats();</div></pre></td></tr></table></figure></p>
<p>2、将这个对象加入到html网页中去，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">stats.domElement.style.position = &apos;absolute&apos;;</div><div class="line">stats.domElement.style.left = &apos;0px&apos;;</div><div class="line">stats.domElement.style.top = &apos;0px&apos;;</div><div class="line">document.body.appendChild(stat.domElement);</div></pre></td></tr></table></figure></p>
<p>3、调用函数来统计时间和帧数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">stats.update();</div><div class="line">或者</div><div class="line">stats.begin();</div><div class="line">funtion()&#123;&#125;;</div><div class="line">stats.end();</div></pre></td></tr></table></figure></p>
<p>tween.js？</p>
<h6 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h6><p>相机两种，正交投影相机和透视投影相机，前者是远近的比例相同，而后者具有近大远小的特点。<br>正交投影相机：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">THREE.OrthographicCamera(left, right, top, bottom, near, far)</div><div class="line">其中，near，far代表相机的深度，为正值。在视景体（Frustum）中的物体才会渲染到页面，相机截取的是对称的</div></pre></td></tr></table></figure>
<p>透视投影相机：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">THREE.PerspectiveCamera( fov, aspect, near, far )</div><div class="line">fov 视角：视野范围的角度；aspect：横纵比 Width/Height; near:近平面的距离； far远平面的距离</div></pre></td></tr></table></figure>
<p>相机有两个重要的参数</p>
<blockquote>
<p>camera.position：控制相机在整个3D环境中的位置（取值为3维坐标对象-THREE.Vector3(x,y,z)）<br>camera.lookAt：控制相机的焦点位置，决定相机的朝向（取值为3维坐标对象-THREE.Vector3(x,y,z)）</p>
</blockquote>
<p>应用:<br>设置相机的焦点为原点或者物体的位置坐标，camera.lookAt(new THREE.Vector3(0,0,0))，改变相机的位置camera.position，可以实现围绕物体360度观看物体的效果。<br>相机lookAt与position的设置可以实现以不同视角观察物体的效果。</p>
<h6 id="要有光！"><a href="#要有光！" class="headerlink" title="要有光！"></a>要有光！</h6><p>光用THREE.Light(hex)，hex16进制的颜色表示；材质在很大程度上，是由光决定的。</p>
<ul>
<li>环境光<br>环境光没有明确的光源位置，在各处的亮度也是一致的，设定是只需指定光的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">THREE.AmbientLight(hex)</div></pre></td></tr></table></figure>
<p>环境光并不影响物体的color属性，而是ambient属性，默认值为0xffffff。所以，环境光一般设为白色或者灰色</p>
<ul>
<li>点光源<br>光源大小可以看做是一个点，照到不同物体上亮度是线性递减的。离光源越远，物体越暗。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">THREE.PointLight(hex, intensity, distance)</div><div class="line">其中，intensity是亮度，缺省值为1，表示100%亮度；distance是光源最远照射到的距离，缺省值为0。</div><div class="line">var light = new THREE.PointLight(0xffffff, 2, 100);</div><div class="line">light.position.set(0, 1.5, 2);</div><div class="line">scene.add(light);</div></pre></td></tr></table></figure>
<ul>
<li>平行光<br>对于任意平行的平面，平行光照射的亮度都是相同的，而与平面所在位置无关。而光源位置的设置异常关键。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">THREE.DirectionalLight(hex, intensity)</div><div class="line">light.position.set(2, 5, 3);</div></pre></td></tr></table></figure>
<p>光源的位置并不意味着光从(2, 5, 3)点发出，而是以矢量(-2, -5, -3)的方向照射到所有平面。因此，平面亮度与平面的位置无关，而只与平面的法向量相关。</p>
<ul>
<li>聚光灯<br>类似圆锥形的光线，类似现实中的聚光灯模型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">THREE.SpotLight(hex, intensity, distance, angle, exponent)</div><div class="line">angle是聚光灯的张角，缺省值是Math.PI / 3，最大值是Math.PI / 2；exponent是光强在偏离target的衰减指数（target需要定义，缺省值为(0, 0, 0)），缺省值是10。</div><div class="line">light.position.set(x1, y1, z1);</div><div class="line">light.target.position.set(x2, y2, z2);</div></pre></td></tr></table></figure>
<p>target还可以指定为物体，实现真正的聚光灯效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1),</div><div class="line">                    new THREE.MeshLambertMaterial(&#123;color: 0x00ff00&#125;));</div><div class="line">var light = new THREE.SpotLight(0xffff00, 1, 100, Math.PI / 6, 25);</div><div class="line">light.target = cube;</div></pre></td></tr></table></figure>
<ul>
<li>阴影<br>Three.js中，能形成阴影的光源只有THREE.DirectionalLight与THREE.SpotLight；能表现阴影效果的材质只有THREE.LambertMaterial与THREE.PhongMaterial。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 初始化，渲染器渲染阴影</div><div class="line">renderer.shadowMapEnabled = true;</div><div class="line">2. 对于要产生阴影的物体调用</div><div class="line">xxx.castShadow = true;</div><div class="line">3. 接收阴影的物体</div><div class="line">xxx.receiveShadow = true;</div></pre></td></tr></table></figure>
<p>同时，需要设置光源的阴影属性<br>1、 聚光灯，需要设置shadowCameraNear、shadowCameraFar、shadowCameraFov<br>2、 平行光，需要设置shadowCameraNear、shadowCameraFar、shadowCameraLeft、shadowCameraRight、shadowCameraTop以及shadowCameraBottom六个值，相当于正交投影照相机的六个面。只有在这六个面围成的长方体内的物体才能产生阴影效果。<br>在调试阴影效果时，可以开启相机位置：light.shadowCameraVisible = true。<br>阴影的深浅可以通过shadowDarkness设置(0,1)，值越小，阴影颜色越小。<br>另一种实现阴影的方法是Shadow Mapping，即阴影通过贴图的方式贴上来。贴图大小可通过shadowMapWidth与shadowMapHeight来设置。</p>
<h6 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h6><p>场景中的物体，由几何形状(Geometry)和材质(Material)组成，设置其name属性可以通过scene.getObjectByName(name)获取该物体对象;</p>
<ul>
<li>几何形状<br>1、立方体</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">THREE.CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)</div><div class="line">其中，后三个参数为宽，高，深度的分段</div></pre></td></tr></table></figure>
<p>2、平面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">THREE.PlaneGeometry(width, height, widthSegments, heightSegments)</div></pre></td></tr></table></figure>
<p>3、球体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">THREE.SphereGeometry(radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength)</div><div class="line">其中，各参数分别为，半径，经度分割数，纬度分割数，经度开始弧度，经度跨越弧度，纬度开始弧度，纬度跨越弧度</div></pre></td></tr></table></figure>
<p>4、圆形</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">THREE.CircleGeometry(radius, segments, thetaStart, thetaLength)</div></pre></td></tr></table></figure>
<p>5、圆柱体，圆台等参考<a href="http://www.ituring.com.cn/book/miniarticle/50172" target="_blank" rel="external">http://www.ituring.com.cn/book/miniarticle/50172</a></p>
<ul>
<li>材质<br>1、 BasicMaterial基本材质不受光照阴影等的影响。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">THREE.MeshBasicMaterial(&#123;</div><div class="line">  visible：是否可见，默认为true</div><div class="line">  side：渲染面片正面或是反面，默认为正面THREE.FrontSide，可设置为反面THREE.BackSide，或双面THREE.DoubleSide</div><div class="line">  wireframe：是否渲染线而非面，默认为false</div><div class="line">  color：十六进制RGB颜色，如红色表示为0xff0000</div><div class="line">  map：使用纹理贴图</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<p>2、 Lambert材质（MeshLambertMaterial）是符合Lambert光照模型的材质。只考虑漫反射而不考虑镜面反射的效果，因而对于金属、镜子等需要镜面反射效果的物体就不适应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">new THREE.MeshLambertMaterial(&#123;</div><div class="line">    color: //散射光反射能力</div><div class="line">    ambient: //环境光反射</div><div class="line">    emissive: 0xff0000 //自发光</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>3、 Phong材质（MeshPhongMaterial）是符合Phong光照模型的材质。和Lambert不同的是，Phong模型考虑了镜面反射的效果，因此对于金属、镜面的表现尤为适合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">new THREE.MeshPhongMaterial(&#123;</div><div class="line">    color:</div><div class="line">    ambient: //环境光反射</div><div class="line">    emissive: 0xff0000 //自发光</div><div class="line">    specular: 0xff0000 //镜面反射系数</div><div class="line">    shininess: 1000 //当shininess值越大时，高光的光斑越小，默认值为30。</div></pre></td></tr></table></figure>
<p>4、 法向材质可以将材质的颜色设置为其法向量的方向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new THREE.MeshNormalMaterial()</div></pre></td></tr></table></figure>
<p>材质的颜色与照相机与该物体的角度相关<br>5、 材质纹理贴图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var texture = THREE.ImageUtils.loadTexture(&apos;../img/0.png&apos;);</div><div class="line">其中，THREE.ImageUtils.loadTexture现在由THREE.TextureLoader()代替</div><div class="line">var loader = new THREE.TextureLoader();</div><div class="line">var texture = loader.load(&apos;url&apos;, function() &#123;</div><div class="line">    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;</div><div class="line">    texture.repeat.set(8, 8);</div><div class="line">    renderer.render(scene, camera);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h6 id="场景中常见的物体"><a href="#场景中常见的物体" class="headerlink" title="场景中常见的物体"></a>场景中常见的物体</h6><p>点是基础，两个点组成一条线，不在一条直线上的三个点组成一个三角形面，这种模型成为Mesh模型.<br>一条线由点，材质，和颜色组成。<br>普通的点用THREE.Vector3定义放在THREE.Geometry对象vertices数组中，<br>材质由THREE.LineBasicMaterial定义，<br>线的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var line = new THREE.Line( geometry, material, THREE.LinePieces );</div></pre></td></tr></table></figure></p>
<p>最常见的物体–网格，除此之外还有线段（Line）、骨骼（Bone）、粒子系统（ParticleSystem）等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Mesh(geometry, material)</div><div class="line">通过属性进行访问mesh.material = new THREE.MeshLambertMaterial(&#123;</div><div class="line">    color: 0xff0000</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>具有位置，缩放，和旋转三个属性。position、scale、rotation。它们都是THREE.Vector3实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mesh.position = new THREE.Vector3(1.5, -0.5, 0);</div><div class="line">mesh.position.set(1.5, -0.5, 0);</div><div class="line">mesh.position.z = 1;</div></pre></td></tr></table></figure>
<h6 id="当当当-动画"><a href="#当当当-动画" class="headerlink" title="当当当 动画"></a>当当当 动画</h6><p>场景动起来的方式，一是物体在坐标轴里移动，摄像机不动；一种是物体不动，camera移动，用requestAnimationFrame(render)进行渲染循环<br>1、用定时器setInterval方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id = setInterval(fun, time);</div><div class="line">clearInterval(id);</div><div class="line">帧数可以通过time控制，time = 1000ms/frame</div></pre></td></tr></table></figure>
<p>2、用requestAnimationFrame方法，h5的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var requestAnimationFrame = window.requestAnimationFrame</div><div class="line">        || window.mozRequestAnimationFrame</div><div class="line">        || window.webkitRequestAnimationFrame</div><div class="line">        || window.msRequestAnimationFrame;</div><div class="line">window.requestAnimationFrame = requestAnimationFrame;</div><div class="line">id = requestAnimationFrame(draw);</div></pre></td></tr></table></figure>
<h6 id="支持引入外部模型"><a href="#支持引入外部模型" class="headerlink" title="支持引入外部模型"></a>支持引入外部模型</h6><p>需要加载额外的辅助函数，地址参考：<a href="https://github.com/mrdoob/three.js/tree/master/examples/js/loaders" target="_blank" rel="external">https://github.com/mrdoob/three.js/tree/master/examples/js/loaders</a><br>1、 例如，导入.obj格式的模型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var loader = new THREE.OBJLoader();</div><div class="line">loader.load(&apos;../lib/port.obj&apos;, function(obj) &#123;</div><div class="line">  //默认情况只有正面绘制，双面绘制</div><div class="line">    obj.traverse(function(child) &#123;</div><div class="line">        if (child instanceof THREE.Mesh) &#123;</div><div class="line">            child.material.side = THREE.DoubleSide;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    mesh = obj;</div><div class="line">    scene.add(obj);//添加到场景</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>2、 对于引入模型的材质设置，有两种方式：</p>
<ul>
<li>在引入模型的回调函数中设置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">obj.traverse(function(child) &#123;</div><div class="line">        if (child instanceof THREE.Mesh) &#123;</div><div class="line">            child.material = new THREE.MeshLambertMaterial(&#123;</div><div class="line">                color: 0xffff00,</div><div class="line">                side: THREE.DoubleSide</div><div class="line">            &#125;);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<ul>
<li>在模型软件中设置，并引用。例如，.obj的模型与.mtl的材质</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//引入js</div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;MTLLoader.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;OBJMTLLoader.js&quot;&gt;&lt;/script&gt;</div><div class="line">var loader = new THREE.OBJMTLLoader();</div><div class="line">loader.addEventListener(&apos;load&apos;, function(event) &#123;</div><div class="line">    var obj = event.content;</div><div class="line">    mesh = obj;</div><div class="line">    scene.add(obj);</div><div class="line">&#125;);</div><div class="line">loader.load(&apos;../lib/port.obj&apos;, &apos;../lib/port.mtl&apos;);</div></pre></td></tr></table></figure>
<h6 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h6><blockquote>
<p>FlyControls:飞行控制，用键盘和鼠标控制相机的移动和转动<br>OrbitControls::轨道控制器，模拟轨道中的卫星，绕某个对象旋转平移，用键盘和鼠标控制相机位置<br>PointerLockControls:指针锁定，鼠标离开画布依然能被捕捉到鼠标交互，主要用于游戏<br>TrackballControls：轨迹球控制器，通过键盘和鼠标控制前后左右平移和缩放场景<br>TransformControls:变换物体控制器，可以通过鼠标对物体的进行拖放等操作</p>
</blockquote>
<h6 id="不明觉厉着色器"><a href="#不明觉厉着色器" class="headerlink" title="不明觉厉着色器"></a>不明觉厉着色器</h6><p>WebGL基于OpenGL ES 2.0，着色器支持顶点着色器和片元着色器。<br>再战！<br>最常发生的错误就是忘记float类型和int类型不会自动转换</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一切都建立在引入Three.js后，得到的全局变量THREE。&lt;br&gt;对于页面中，存放渲染效果的元素，可以是普通的div，也可以是canvas。&lt;br&gt;对于div，渲染时添加节点：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var renderer = new THREE.WebGLRenderer();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;renderer.setSize(400, 300);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;document.getElementById(&amp;apos;test&amp;apos;).appendChild(renderer.domElement);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;renderer.setClearColor(0x000000);//清除原本所在页面颜色，并设置&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;而对于定义的canvas标签，其定义及渲染：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;canvas id=&amp;quot;mainCanvas&amp;quot; width=&amp;quot;400px&amp;quot; height=&amp;quot;300px&amp;quot; &amp;gt;&amp;lt;/canvas&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var renderer = new THREE.WebGLRenderer(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    canvas: document.getElementById(&amp;apos;mainCanvas&amp;apos;)&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;基本概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主要分为三大部分，场景（scene）、照相机（camera）、渲染器（renderer）&lt;/li&gt;
&lt;li&gt;首先定义容器渲染所在的DOM包括宽高、颜色等，利用照相机(投影方式)把作为容器的场景渲染到页面上。&lt;/li&gt;
&lt;li&gt;声明渲染器对象renderer，canvas对象的获取方法为renderer.domElement，相机也需要加到场景中去&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Three.js" scheme="https://wangyx233.github.io/tags/Three-js/"/>
    
  </entry>
  
  <entry>
    <title>hexo部署github的问题</title>
    <link href="https://wangyx233.github.io/2017/04/11/hexo%E9%83%A8%E7%BD%B2github%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://wangyx233.github.io/2017/04/11/hexo部署github的问题/</id>
    <published>2017-04-11T12:03:27.000Z</published>
    <updated>2017-06-05T12:21:43.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="用hexo搭建博客，配置直接部署到github的方法："><a href="#用hexo搭建博客，配置直接部署到github的方法：" class="headerlink" title="用hexo搭建博客，配置直接部署到github的方法："></a>用hexo搭建博客，配置直接部署到github的方法：</h5><p>1.安装 hexo-deployer-git插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<p>2.在hexo根目录的_config.yml中进行deploy的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">    type: git</div><div class="line">    repo: [github repository url] //eg:git@github.com:xxx.git or https://github.com/xxx.git</div><div class="line">    branch: master //branch name</div><div class="line">    message: &quot;Blog updated: &#123;&#123; now（&apos;YYYY-MM-DD&apos;）&#125;&#125;&quot; //commit message</div><div class="line">Ps:注意缩进和空格</div></pre></td></tr></table></figure></p>
<p>3.通过hexo deploy（即hexo d）命令进行部署，在此之前需要进行hexo generate（即hexo g）编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo-deployer-git插件的作用是生成.deploy_git文件，</div><div class="line">并且把hexo g编译后的public中的文件复制到.deploy_git文件夹下，</div><div class="line">然后进行git操作，推到远端github仓库。</div></pre></td></tr></table></figure></p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><a id="more"></a>
<p>1.在用hexo d进行第一次部署时，需要将从public拷贝到.deploy_git文件夹下的所有文件进行commit操作（hexo d部署只会更新静态的html文件）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd .deploy_git</div><div class="line">git add --all -f</div><div class="line">git commit -m &quot;message&quot;</div><div class="line">git push origin branch</div></pre></td></tr></table></figure></p>
<p>2.说道部署至github，那前提是配置好github的username和password啦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;用hexo搭建博客，配置直接部署到github的方法：&quot;&gt;&lt;a href=&quot;#用hexo搭建博客，配置直接部署到github的方法：&quot; class=&quot;headerlink&quot; title=&quot;用hexo搭建博客，配置直接部署到github的方法：&quot;&gt;&lt;/a&gt;用hexo搭建博客，配置直接部署到github的方法：&lt;/h5&gt;&lt;p&gt;1.安装 hexo-deployer-git插件&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm install hexo-deployer-git --save&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2.在hexo根目录的_config.yml中进行deploy的配置&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;deploy:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    type: git&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    repo: [github repository url] //eg:git@github.com:xxx.git or https://github.com/xxx.git&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    branch: master //branch name&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    message: &amp;quot;Blog updated: &amp;#123;&amp;#123; now（&amp;apos;YYYY-MM-DD&amp;apos;）&amp;#125;&amp;#125;&amp;quot; //commit message&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Ps:注意缩进和空格&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3.通过hexo deploy（即hexo d）命令进行部署，在此之前需要进行hexo generate（即hexo g）编译。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;hexo-deployer-git插件的作用是生成.deploy_git文件，&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;并且把hexo g编译后的public中的文件复制到.deploy_git文件夹下，&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;然后进行git操作，推到远端github仓库。&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;注意：&quot;&gt;&lt;a href=&quot;#注意：&quot; class=&quot;headerlink&quot; title=&quot;注意：&quot;&gt;&lt;/a&gt;注意：&lt;/h3&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://wangyx233.github.io/tags/hexo/"/>
    
      <category term="github" scheme="https://wangyx233.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wangyx233.github.io/2017/04/11/hello-world/"/>
    <id>https://wangyx233.github.io/2017/04/11/hello-world/</id>
    <published>2017-04-11T06:06:25.000Z</published>
    <updated>2017-06-05T12:13:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<a id="more"></a>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo server&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
