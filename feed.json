{"title":"Hexo","description":null,"language":null,"link":"https://wangyx233.github.io","pubDate":"Tue, 13 Aug 2019 02:10:39 GMT","lastBuildDate":"Tue, 13 Aug 2019 07:35:58 GMT","generator":"hexo-generator-json-feed","webMaster":"Xuan","items":[{"title":"JS基础回顾","link":"https://wangyx233.github.io/2019/08/13/基础回顾/","description":"内置类型加上ES6新加的Symbol，共7种，分别为 String， Number， Boolean， Object， Undefined， Null。分为基本数据类型(6)和Object。对于基本数据类型，通过字面量的方式声明，类型依旧是字面量，只有在使用的时候才会转换为对应的类型。12345typeof() 特别： 函数-&gt;function, null-&gt;object。历史原因对象以000开头，而null恰好为全零通过Object.prototype.toString.call()可判断准确的类型[object Type] PS: Symbol类型(唯一的值)通过 Symbol()定义，定义后的值不相等，System.prototype.description 为定义时Symbol(‘xxx’)的标识。使用场景：作为对象的属性1234567let sym = Symbol();let a = &#123;&#125;;a[sym] = &apos;symbol&apos;;a = &#123; [sym]: &apos;symbol&apos;&#125;Object.defineProperty(a, sym, &#123;value: &apos;symbol&apos;&#125;) 注： 不能用.运算符，.运算符会直接作为字符串取值。 Symbol作为属性名，不会出现在for…in, for…of中，也不会出现在Object.keys(), Object.getOwnPropertyNames()、JSON.stringify()里。 但也不是私有属性，Object.getOwnPropertySymbols，可以获取指定对象的所有 Symbol 属性名。 新的API:Reflect.ownKeys可以返回所有类型的键名，包括常规键名和 Symbol 键名。 Symbol.for(description)若没有则会创建一个，若存在则共用一个symbol值。 Symbol.keyFor(sym)返回一个已登记即Symbol.for的 Symbol类型值的key 其他方法可在需要是再查找。 类型转换转Boolean类型。在条件判断时，除了 undefined， null， false， NaN， ‘’， 0， -0，其他所有值都转为 true，包括所有对象对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。注：‘a’ + + ‘b’ – ‘aNaN’1234x==y 比较undefined == null // true[] == true // false[] == ![] // true [].toString() -&gt; &apos;&apos;，!取反运算符的优先级会高于==， ![] -》 false undefined == null，结果是true。且它俩与所有其他值比较的结果都是false。 String == Boolean，需要两个操作数同时转为Number。 String/Boolean == Number，需要String/Boolean转为Number。 Object == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法)。","pubDate":"Tue, 13 Aug 2019 02:10:39 GMT","guid":"https://wangyx233.github.io/2019/08/13/基础回顾/","category":""},{"title":"链表","link":"https://wangyx233.github.io/2019/07/22/链表队列/","description":"what?链表是一种递归的数据结构，它或者为空，或者为一个指向结点的引用。该结点含有一个泛型元素和一个指向另一个链表的引用(next)。其中，结点是一种含有任何类型数据的抽象实体。链表表示的是一列元素。在追踪链表或其他链式结构代码的时候，可用可视化的方式表示： 用长方形表示对象 将实例变量的值写在长方形中 用指向被引用对象的箭头表示引用关系，链接实现任意插入和删除操作的标准解决方案是双向链表，其中每个结点都含有两个链接(pervious, next)，分别指向不同的方向。 特点： 可以处理任意类型的数据 所需的空间和集合的大小成正比 操作的所需要的时间总是和集合的大小无关 补充： 背包(Bag)是一种不支持从中删除元素的集合数据类型，目的就是收集元素并且迭代遍历收集到的元素，迭代的顺序不确定且元素的处理顺序不重要，可以用栈也可以用队列。 1234class Bag() &#123;&#125; add(item) isEmpty() size() 先进先出队列FIFO 12345class Queue() &#123;&#125; enqueue(item) // 添加一个元素 dequeue() // 删除最近添加的元素 isEmpty() size() 下压栈LIFO 1234567class Stack() &#123;&#125; push(item) pop() isEmpty() size()例如表达式的求值：遇到左括号忽略，操作数押入操作数的栈里，运算符押入运算符的栈里，遇到右括号运算符栈和操作数栈pop计算得到值，再押入栈中。如：(1 + ((2 + 3) * (4 * 5))) 在一些语言中，数组的长度一经定义就不可改变，并且数组的删除和添加操作需要对元素进行平移会很繁琐。JS中数组和其他的不同，它是通过对象实现的，操作方便，但是效率可能较其他语言有所不足。 123456function Node(elem) &#123; this.elem = elem; this.next = null; // this.prvious = null;&#125;// 查找，插入，删除结点","pubDate":"Mon, 22 Jul 2019 08:05:17 GMT","guid":"https://wangyx233.github.io/2019/07/22/链表队列/","category":""},{"title":"理解promise","link":"https://wangyx233.github.io/2019/01/16/理解promise/","description":"为什么?避免回调地狱有什么问题呢？代码臃肿，可读性差，耦合性差，容易产生bug，不容易维护。不容易复用。在回调里面处理问题。js特点-&gt;异步，主要是靠回调函数实现的。比如，nodejs的特点是高并发和非阻塞，主要靠异步来实现。js是事件注册机制的。函数的执行是进栈和出栈这样的，所以普通的回调函数，try catch是没有作用的。 是什么？用于异步计算，用于即将发生的事情，或者不会发生的事情。一个Promise的状态有resolved/rejected/pending/settlednew Promise 返回一个promise对象，参数是一个执行函数。执行函数有两个参数，resolve，reject12345678910new Promise((resolve, reject) =&gt; &#123; // 异步处理 处理结束后执行resolve , reject&#125;).then() //成功失败的回调，注意：then方法是异步执行的.catch() //在最外层捕获异常。promise.catch(onRejected)相当于promise.then(null, onRrejected); promise的三种状态:pending 初始化fulfilled 执行成功，调用resolverejected 失败，调用reject注意promsie状态 只能由 pending =&gt; fulfilled/rejected, 一旦修改就不能再变","pubDate":"Tue, 15 Jan 2019 16:41:34 GMT","guid":"https://wangyx233.github.io/2019/01/16/理解promise/","category":""},{"title":"webpack学习","link":"https://wangyx233.github.io/2018/06/15/webpack学习/","description":"postcss 配置，post.config.js，同时webpack.config.js mini-css-extract-plugin 与style-loader不共存 注意路径和文件名，仔细，认真 ico图片引入，没什么区别？ 可自动设置dist文件夹下的文件，生成文件的目录你来掌握。 注意图片引入的路径,使用file-loader，url-loader引入的图片需要配合require使用，才能打包。url可以指定图片大小转换成base64等。若不用require，直接src，需要把图片copy到打包后的文件。 react-hot-loader 与webpack 自带的hot不相互兼容。只能用一个。 webpack 的publicpath 定义的是服务在哪个文件下启动的，content可以定义文件的目录。 静态文件可生成hash模式，避免缓存。 babel也需要相应的配置。配合babel-import-plugin可以进行ui库的部分引入。还要注意选择babel的stage react route4 webpack 服务器，用BrowserRouter,historyApiFallback: true gulp 与 webpack的区别gulp 是任务流的，和task有关。webpack 的核心是根据模块构建项目。Webpack 的核心就是模块化地组织，模块化地依赖，然后模块化地打包。相对来上，场景局限在前端模块化打包上；虽然用 gulp + 插件的方式也能实现，但目前看 Webpack 在依赖的模块化构建上是无人能够替代的。gulp 版本号。可以在打包的时候，打入不同的文件。","pubDate":"Fri, 15 Jun 2018 08:34:01 GMT","guid":"https://wangyx233.github.io/2018/06/15/webpack学习/","category":""},{"title":"Echarts3.5.0以上世界地图nameMap变更","link":"https://wangyx233.github.io/2017/06/27/Echarts3.5.0以上世界地图nameMap修改/","description":"今天发现使用Echarts，nameMap渲染的世界地图，没有显示美国的数据，美国的区域显示的为United States。经过查找发现，Echarts应该是在3.5.0版本的时候，对world.js的一些国家名称进行了变更，从而导致用官网实例提供的nameMap,无法匹配到国家，进而无法显示。大致看了一下地图，修改后对应的国家信息为： 123456789101112131415var nameMap =&#123; &apos;Central African Rep.&apos;:&apos;中非共和国&apos;, &apos;Dem. Rep. Congo&apos;:&apos;刚果民主共和国&apos;, &apos;Lao PDR&apos;:&apos;老挝&apos;, &apos;W. Sahara&apos;:&apos;西撒哈拉&apos;, &apos;Tanzania&apos;:&apos;坦桑尼亚联合共和国&apos;, &apos;United States&apos;:&apos;美国&apos;, &apos;Korea&apos;: &apos;韩国&apos;, &apos;Dem. Rep. Korea&apos;: &apos;朝鲜&apos;, &apos;Congo&apos;: &apos;刚果共和国&apos;, &apos;Solomon Is.&apos;: &apos;所罗门群岛&apos;, &apos;Dominican Rep.&apos;:&apos;多明尼加共和国&apos;, &apos;S. Sudan&apos;: &apos;南苏丹&apos; , &quot;Côte d&apos;Ivoire&quot;: &apos;科特迪瓦&apos;,&#125;","pubDate":"Tue, 27 Jun 2017 09:23:11 GMT","guid":"https://wangyx233.github.io/2017/06/27/Echarts3.5.0以上世界地图nameMap修改/","category":""},{"title":"一些设计知识~","link":"https://wangyx233.github.io/2017/06/21/写给大家看的设计书/","description":"最近要看的书好多，全都在排排坐，先挑了一本设计类的书籍《写给大家看的设计书》 设计的四大原则对比对比是为页面增加视觉效果的最有效的途径,也是在不同元素之间建立一种有组织的层次结构最有效方法。要记住一个重要规则:要想实现有效的对比,对比就必须 强烈。千万不要畏畏缩缩。字体的对比，颜色的对比，一定要保持强烈，差别不大的对比没有效果。对比的根本目的有两个,这两个目的相辅相成,无法分开。一个目的是增强页面的效果,如果一个页面看起来很有意思,往往更有可读性。另一个目的是有助于信息的组织。读者应当能立即了解信息以何种方式组织,以及从一项到另一项的逻辑流程。对比元素不能让读者混淆,也不能错误地强调重点(即本不该是重点的元素)。 重复-一致性设计的某些方面需要在整个作品中重复。控制读者视线，设计中视觉元素的重复可以将作品中的各部分连在一起,从而统一并增强整个作品。重复的目的就是统一,并增强视觉效果。不要低估页面视觉效果的威力,如果一个作品看起来很有趣,它往往也更易于阅读。要避免太多地重复一个元素,重复太多会让人讨厌。要注意对比的价值可以通过字体选择、线宽、颜色、形状、大小、空间等来增加对比。 增加对比很容易,途径有很多,这可能是增加视觉效果最有意思也最让人满意的方 法了。重要的是:对比一定要强烈!","pubDate":"Wed, 21 Jun 2017 03:37:56 GMT","guid":"https://wangyx233.github.io/2017/06/21/写给大家看的设计书/","category":""},{"title":"D3.js学习","link":"https://wangyx233.github.io/2017/06/21/D3.js学习/","description":"D3.js实现数据和元素的绑定对于DOM结点的选择，d3.select(‘tag’)选择第一个元素,d3.selectAll(‘tag’)选择所有的元素。对于数据的绑定，tag.datum()将一个数据绑定到元素上，tag.data()将数组内元素分别绑定各元素。 1var body = d3.select(&apos;body&apos;);","pubDate":"Wed, 21 Jun 2017 02:47:53 GMT","guid":"https://wangyx233.github.io/2017/06/21/D3.js学习/","category":""},{"title":"Canvas学习","link":"https://wangyx233.github.io/2017/06/12/Canvas学习/","description":"&lt;canvas&gt;标签定义一个矩形框画布，默认没有边框和内容,默认大小为300像素×150像素(wxh)。 1234&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;style=&quot;border:1px solid #000000;&quot;&gt;若浏览器不支持canvas标签，将显示这些文字&lt;/canvas&gt; 在Js文件中绘制Canvas元素。 12345678var c=document.getElementById(&quot;myCanvas&quot;);if(c.getContext(&apos;2d&apos;))&#123; //支持性检查 var ctx=c.getContext(&quot;2d&quot;);//获取渲染上下文，参数为上下文的格式 ctx.fillStyle=&quot;#FF0000&quot;; //填充样式，可为颜色、图案、渐变等。 ctx.fillRect(0,0,150,75);//矩形的填充方法fillRect(x,y,width,height)，矩形左上角坐标为(0,0)&#125;else &#123; // canvas-unsupported code here&#125; 画矩形canvas支持一种原生的图形绘制-矩形 1234fillRect(x, y, width, height) //绘制一个填充的矩形strokeRect(x, y, width, height) //绘制一个矩形的边框clearRect(x, y, width, height) //清除指定矩形区域，让清除部分完全透明rect(x, y, width, height) //绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。","pubDate":"Mon, 12 Jun 2017 05:55:20 GMT","guid":"https://wangyx233.github.io/2017/06/12/Canvas学习/","category":""},{"title":"Three.js学习笔记","link":"https://wangyx233.github.io/2017/06/05/three.js学习指南/","description":"一切都建立在引入Three.js后，得到的全局变量THREE。对于页面中，存放渲染效果的元素，可以是普通的div，也可以是canvas。对于div，渲染时添加节点：1234var renderer = new THREE.WebGLRenderer();renderer.setSize(400, 300);document.getElementById(&apos;test&apos;).appendChild(renderer.domElement);renderer.setClearColor(0x000000);//清除原本所在页面颜色，并设置 而对于定义的canvas标签，其定义及渲染：123&lt;canvas id=&quot;mainCanvas&quot; width=&quot;400px&quot; height=&quot;300px&quot; &gt;&lt;/canvas&gt;var renderer = new THREE.WebGLRenderer(&#123; canvas: document.getElementById(&apos;mainCanvas&apos;)&#125;); 基本概念 主要分为三大部分，场景（scene）、照相机（camera）、渲染器（renderer） 首先定义容器渲染所在的DOM包括宽高、颜色等，利用照相机(投影方式)把作为容器的场景渲染到页面上。 声明渲染器对象renderer，canvas对象的获取方法为renderer.domElement，相机也需要加到场景中去","pubDate":"Mon, 05 Jun 2017 05:59:18 GMT","guid":"https://wangyx233.github.io/2017/06/05/three.js学习指南/","category":"Three.js"},{"title":"hexo部署github的问题","link":"https://wangyx233.github.io/2017/04/11/hexo部署github的问题/","description":"用hexo搭建博客，配置直接部署到github的方法：1.安装 hexo-deployer-git插件1npm install hexo-deployer-git --save 2.在hexo根目录的_config.yml中进行deploy的配置123456deploy: type: git repo: [github repository url] //eg:git@github.com:xxx.git or https://github.com/xxx.git branch: master //branch name message: &quot;Blog updated: &#123;&#123; now（&apos;YYYY-MM-DD&apos;）&#125;&#125;&quot; //commit messagePs:注意缩进和空格 3.通过hexo deploy（即hexo d）命令进行部署，在此之前需要进行hexo generate（即hexo g）编译。123hexo-deployer-git插件的作用是生成.deploy_git文件，并且把hexo g编译后的public中的文件复制到.deploy_git文件夹下，然后进行git操作，推到远端github仓库。 注意：","pubDate":"Tue, 11 Apr 2017 12:03:27 GMT","guid":"https://wangyx233.github.io/2017/04/11/hexo部署github的问题/","category":"hexo,github"},{"title":"Hello World","link":"https://wangyx233.github.io/2017/04/11/hello-world/","description":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server","pubDate":"Tue, 11 Apr 2017 06:06:25 GMT","guid":"https://wangyx233.github.io/2017/04/11/hello-world/","category":""}]}