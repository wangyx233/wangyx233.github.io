{"title":"Hexo","description":null,"language":null,"link":"https://wangyx233.github.io","pubDate":"Mon, 18 Apr 2022 21:59:07 GMT","lastBuildDate":"Mon, 18 Apr 2022 21:59:24 GMT","generator":"hexo-generator-json-feed","webMaster":"Yx","items":[{"title":"【复盘】学了又好像没学过","link":"https://wangyx233.github.io/2022/04/19/[复盘]this/","description":"基础不扎实啊，学了，又好像没学过 😭 THIS 指向 函数调用时，根据执行上下文确定的。 简单调用，严格模式是 undefined，否则绑定在全局对象 window/globa。l。 显示调用 apply/call/bind，绑定到指定的参数对象上。 对象调用，绑定在该对象上在执行函数时，如果函数中的 this 是被上一级的对象所调用，那么 this 指向的就是上一级的对象；否则指向全局环境。 构造函数 new 调用，绑定在新创建的对象上。如果构造函数中显式返回一个值，且返回的是一个对象，那么 this 就指向这个返回的对象；如果返回的不是一个对象，那么 this 仍然指向实例{}。 箭头函数的 this，由外层（全局/函数）的上下文绑定的 this 决定。箭头函数的绑定无法被修改，this 始终沿着作用域链向上找（定义时决定，而不是执行时决定）。 说明： 通过 call、apply、bind、new 对 this 绑定的情况称为显式绑定。 根据调用关系确定的 this 指向称为隐式绑定。 call、apply 的显式绑定一般来说优先级更高。 new 绑定的优先级比显式 bind 绑定更高。 const 声明的变量不会挂载到 window 全局对象当中，var 会。 QA: 严格模式都有哪些情况？ use strict 类表达式、类声明中是强制严格模式的!!! 123456789101112131415161718192021222324252627282930window.name = &apos;hello&apos;function A() &#123; this.name = 123&#125;A.prototype.getName = function () &#123; console.log(this) return this.name + 1&#125;var a = new A()var funcA = a.getNamefuncA() // &apos;hello1&apos;a.getName() // 124window.name = &apos;hello&apos;class A &#123; constructor() &#123; this.name = 123 &#125; getName = function() &#123; // Uncaught TypeError: Cannot read properties of undefined console.log(this) return this.name + 1 &#125; getName = () =&gt; &#123; // 124 console.log(this) return this.name + 1 &#125;&#125;var a = new A()var funcA = a.getNamefuncA() 如果要改变this指向有什么方法呢？ 首先想到用call,apply,bind来修改 借助对象调用 箭头函数 实现一个 bind 方法 返回一个函数，this 1234567Function.prototype.bind = Function.prototype.bind || function (context, ...args) &#123; if (typeof this !== &quot;function&quot;) throw new TypeError(&apos;need a function&apos;) const fn = this; return function (...args2) &#123; return fn.apply(context, [...args, ...args2]) &#125;&#125; 注： 边界情况 bind 返回的函数如果作为构造函数，搭配 new 关键字出现的话，我们的绑定 this 就需要“被忽略” apply 可以改为对象的隐式调用","pubDate":"Mon, 18 Apr 2022 21:59:07 GMT","guid":"https://wangyx233.github.io/2022/04/19/[复盘]this/","category":"JavaScript"},{"title":"【React】Hook系列 - useRef","link":"https://wangyx233.github.io/2022/04/14/[React]useRef/","description":"平时用函数组件进行 React 开发，hooks 想必经常用，像最长用的 useState useEffect，传[] 只渲染一次，不传每次都渲染。异步的呀 useMemo useCallback 这里先主要说一下useRef，主要的关注点是： 1const ref = useRef(initValue) 返回一个可变的 ref 对象，该对象只有个 current 属性，初始值为传入的参数( initialValue )。 返回的 ref 对象在组件的整个生命周期内保持不变，即引用不变。 并且当更新 current 值时并不会进行 re-render 一般会在useEffect，或者事件处理内使用 总结来看，useRef定义的对象，不会导致组件重新渲染。并且它的current值可以突破闭包的限制，不会因为组件更新而重置。 useRef vs createRef createRef 每次会返回新的引用，即会随着组件的更新而重新创建 日常使用 自定义一个保持之前值的 hook 12345678import &#123;useRef, useEffect&#125; from &apos;react&apos;export function usePrevious&lt;T&gt;(value: T): T | undefined &#123; const ref = useRef&lt;T | undefined&gt;() useEffect(() =&gt; &#123; ref.current = value &#125;, [value]) return ref.current&#125; 判断是不是第一次更新 123456789import &#123;useRef&#125; from &apos;react&apos;export function useIsFirstRender(): boolean &#123; const ref = useRef&lt;boolean&gt;(true) if(ref.current) &#123; ref.current = false return true &#125; return false&#125;","pubDate":"Thu, 14 Apr 2022 13:53:14 GMT","guid":"https://wangyx233.github.io/2022/04/14/[React]useRef/","category":"React"},{"title":"【JS基础】Object对象方法","link":"https://wangyx233.github.io/2022/04/14/[JS基础]Object对象/","description":"Object.getPrototypeOf() 获得参数对象原型的方法呀。是该对象的__proto__指向 1234Object.getPrototypeOf(&#123;&#125;) === Object.prototype // trueObject.getPrototypeOf(Object.prototype) === null // truefunction f() &#123;&#125;Object.getPrototypeOf(f) === Function.prototype // true Object.setPrototypeOf() Object.setPrototypeOf(obj, proto)，更改该对象的__proto__指向 12345678var F = function () &#123; this.foo = &apos;test&apos;;&#125;;var f = new F();// 等同于var f = Object.setPrototypeOf(&#123;&#125;, F.prototype);F.call(f); Object.create() 从一个实例生成另一个实例对象 1234567if (typeof Object.create !== &apos;function&apos;) &#123; Object.create = function (obj) &#123; function F() &#123;&#125; F.prototype = obj; return new F(); &#125;;&#125; 这三种生成新对象的方法是等价的 123var obj1 = Object.create(&#123;&#125;);var obj2 = Object.create(Object.prototype);var obj3 = new Object(); 1var obj = Object.create(null); obj 不具有 Object.prototype 上的属性和方法了。Object.create 必须提供对象原型，参数为空或者不是对象都会报错。 12345678910111213141516171819var obj = Object.create(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true, configurable: true, writable: true, &#125;, p2: &#123; value: &apos;abc&apos;, enumerable: true, configurable: true, writable: true, &#125;&#125;);// 等同于var obj = Object.create(&#123;&#125;);obj.p1 = 123;obj.p2 = &apos;abc&apos;; 123456function A() &#123;&#125;var a = new A();var b = Object.create(a);b.constructor === A // trueb instanceof A // true Object.prototype.isPrototypeOf() 123456var o1 = &#123;&#125;;var o2 = Object.create(o1);var o3 = Object.create(o2);o2.isPrototypeOf(o3) // trueo1.isPrototypeOf(o3) // true 1234Object.prototype.isPrototypeOf(&#123;&#125;) // trueObject.prototype.isPrototypeOf([]) // trueObject.prototype.isPrototypeOf(/xyz/) // trueObject.prototype.isPrototypeOf(Object.create(null)) // false 123456var obj = new Object();obj.__proto__ === Object.prototype// trueobj.__proto__ === obj.constructor.prototype// true 获取实例对象obj的原型对象有哪些方法？ obj.proto obj.constructor.prototype Object.getPrototypeOf(obj) 12345678var P = function () &#123;&#125;;var p = new P();var C = function () &#123;&#125;;C.prototype = p;var c = new C();c.constructor.prototype === p // false 所以，在改变原型对象时，一般要同时设置constructor属性。 12345C.prototype = p;C.prototype.constructor = C;var c = new C();c.constructor.prototype === p // true Object.getOwnPropertyNames() 对象本身包含的属性名，不包含继承的。可枚举、不可枚举的都包括如果只想获取可枚举的 Object.keys in in 运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。常用于检查一个属性是否存在。 对象的拷贝具有相同的原型，以及实例属性。 123456function copyObject(orig) &#123; return Object.create( Object.getPrototypeOf(orig), Object.getOwnPropertyDescriptors(orig) );&#125; 123456789101112131415function copyObject(orig) &#123; var copy = Object.create(Object.getPrototypeOf(orig)); copyOwnPropertiesFrom(copy, orig); return copy;&#125;function copyOwnPropertiesFrom(target, source) &#123; Object .getOwnPropertyNames(source) .forEach(function (propKey) &#123; var desc = Object.getOwnPropertyDescriptor(source, propKey); Object.defineProperty(target, propKey, desc); &#125;); return target;&#125; prototype 对象 拥有 constructor，指向改原型对象的构造函数constructor 属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改 constructor 属性，防止引用的时候出错。 instanceof 123[] instanceof Array// 等同于Array.prototype.isPrototypeOf([]) instanceof 的原理是检查右边构造函数的 prototype 属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有 null 对象。这时，instanceof 判断会失真。 PS: 判断是否是数组的方式 Array.isArray() Object.prototype.toString.call() [].constructor.name // ‘Array’ xxx instanceof Array","pubDate":"Thu, 14 Apr 2022 13:52:58 GMT","guid":"https://wangyx233.github.io/2022/04/14/[JS基础]Object对象/","category":"JavaScript"},{"title":"【JS基础】构造函数","link":"https://wangyx233.github.io/2022/04/13/[JS基础]构造函数/","description":"what？ 当然是用来构造对象的函数啦~ 当然可以简单的这样理解 构造函数（constructor），是专门用来生成实例对象的函数，描述实例对象的基本结构。为了与普通函数区别，构造函数名称的第一个字母通常大写，有自己的特征与用法。 特点： 函数内部使用this关键字，代表要生成的对象实例 生成对象的时候，要使用new命令 等等 new 是什么? 12345const Person = function (name) &#123; this.name = name&#125;const Amanda = new Person(&apos;Amanda&apos;) new 命令的作用其实是，执行构造函数，返回一个实例对象。使用new时，构造函数也可以接受参数。 如果不使用new，直接调用构造函数会怎样？ 那构造函数只能像普通函数一样执行，不会返回实例对象，函数的默认返回是 undefined 呀。这时候this指向变成另一个话题啦 如何保证构造函数必须与new 一起用呢？如果没用new，则报错，或者直接返回一个实例对象 构造函数内使用严格模式，use strict。这样的话，this不能指向全局，而是 undefined 判断this不是实例，return new Fun() 这一顿操作new到底做了什么呢？ 创建一个空对象，作为要返回的对象实例 将这个空对象的原型__proto__，指向构造函数的prototype 构造函数的this指向改为这个空对象(即这个空对象赋值给函数内部的this关键字) 构造函数执行返回 因此，构造函数之所以成为构造函数，是说这个函数的功能，是操作一个空对象，通过this，将其构造成需要的样子。 如果构造函数内部有return，需要注意： 如果return返回一个对象，则返回的实例对象是，该对象 如果不是，则忽略return的内容，返回this对象 总结实现一个new吧 123456var myNew = (constructor, ...args) =&gt; &#123; const obj = &#123;&#125; obj.__proto__ = constructor.prototype // Object.setPrototypeOf(obj, constructor.prototype) const result = constructor.apply(obj, args) return (typeof result === &apos;object&apos; &amp;&amp; result !== null) ? result : obj&#125; 123456var myNew = (constructor, ...args) =&gt; &#123; const obj = &#123;&#125; obj.__proto__ = constructor.prototype // Object.setPrototypeOf(obj, constructor.prototype) const result = constructor.apply(obj, args) return (typeof result === &apos;object&apos; &amp;&amp; result !== null) ? result : obj&#125; Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__ 12345var myNew = (constructor, ...args) =&gt; &#123; const obj = Object.create(constructor.prototype) const result = constructor.apply(obj, args) return (typeof result === &apos;object&apos; &amp;&amp; result !== null) ? result : obj&#125;","pubDate":"Wed, 13 Apr 2022 06:21:49 GMT","guid":"https://wangyx233.github.io/2022/04/13/[JS基础]构造函数/","category":"JavaScript"},{"title":"【开发】正则","link":"https://wangyx233.github.io/2022/04/08/[开发]正则/","description":"正则表达式真的属于是常看常新，不看就忘。。。🤦🏻‍♀️ JS 中使用正则，有两种方式： 字面量，如： /abc/， g 全局，i 忽略大小写，m 多行搜索 构造函数，如：new RegExp(&#39;abc&#39;, &#39;g&#39;) 基本概念： 元字符：在正则表达式中有特殊含义的非字母字符，如*,+,?,$,^,.,|,\\,(,),{,},[,] 字符集合：[abc]字符 a 或 b 或 c 归为一类，会匹配 a 或者 b 或者 c。在[^abc] 即 [^ ]是取反的意思，除了 a,b,c 之外 范围类：[0-9A-Z]，如果想匹配-，比如：[0-9-] 会匹配1- 预定义类：比如. \\d \\D \\w \\W \\s \\S d-&gt; digit，s-&gt;space，w-&gt; word。大写就是取反咯 . -&gt; [^\\r\\n] 边界：^ $ \\b \\B ，\\b 是单词边界 量词：? + * {n} {n,m} {n, } 贪婪模式：正则表达式默认是贪婪模式，即每次匹配都尽可能匹配多的字符，比如/\\d{2,5}/ /\\d{2,5}?/ 或：| 分组：() 作为一个整体，如：(test){3} 匹配 test 3 次 捕获：() 包含的表达式所匹配到的字符串会被（分组捕获），$1 $2 $3... 每次捕获的结果。如果要忽略某个分组捕获的结果(?:) ES2018(ES9) 中已经支持后瞻和命名分组。😯 exp(?=assert) 正向前瞻 exp(?!assert) 负向前瞻 RegExp 的方法： test，返回 true / false exec，返回匹配的值 1234const reg = /\\d(\\w)\\d/const str = &apos;1a2b3c&apos;reg.test(str)reg.exec(str) 注注注意呀：When a regex has the global flag set, As long as test() returns true, lastIndex will not reset—even when testing a different string! 啥？ 每次test方法如果用了g，全局匹配，如果匹配的结果是true，lastIndex 会标识结尾的值。即使匹配一个不同的字符串也不会重置，除非结果是false 12345678910111213const regex = /foo/g; // the &quot;global&quot; flag is set// regex.lastIndex is at 0regex.test(&apos;foo&apos;) // true// regex.lastIndex is now at 3regex.test(&apos;foo&apos;) // false// regex.lastIndex is at 0regex.test(&apos;barfoo&apos;) // true// regex.lastIndex is at 6regex.test(&apos;foobar&apos;) //false String 支持的方法： replace match search split","pubDate":"Fri, 08 Apr 2022 09:10:06 GMT","guid":"https://wangyx233.github.io/2022/04/08/[开发]正则/","category":"开发"},{"title":"【浏览器】Chrome v100了，版本号你还好嘛","link":"https://wangyx233.github.io/2022/04/07/[浏览器]版本号/","description":"今日重启电脑，突然发现 chrome 又又又又更新啦，正式迈入 100 大关。有一些重大的改变，比如图标更大更亮了，推荐用 User-Agent Client Hints API 代替 User-Agent 字符串，还有一些屏幕 screen 窗口的 API 等等。但是突然想起了版本号比较这个问题： ‘100’ &gt; ‘99’ true or false ??? 这个问题就要上升到两字符串比较大小，两边都是 string 类型，不会进行类型转换，而是会根据第一个不同字符的 ASCII 码值进行比较。所以 &#39;100&#39; &gt; &#39;99&#39; -&gt; false 啦，变成数字比较正常。再延伸一下像这样的版本号，可以怎样对比呢？ 12version1: 1.0.1version2: 1.1 1234567891011121314var compareVersion = function (version1, version2) &#123; const v1 = version1.split(&apos;.&apos;) const v2 = version2.split(&apos;.&apos;) const max = Math.max(v1.length, v2.length) for (let i = 0; i &lt; max; i++) &#123; let x = 0, y = 0 if (i &lt; v1.length) x = +v1[i] if (i &lt; v2.length) y = +v2[i] if (x &gt; y) return 1 if (x &lt; y) return -1 &#125; return 0&#125;;","pubDate":"Thu, 07 Apr 2022 06:35:33 GMT","guid":"https://wangyx233.github.io/2022/04/07/[浏览器]版本号/","category":"浏览器"},{"title":"【React】React 18来辣","link":"https://wangyx233.github.io/2022/04/07/[React]React18来啦/","description":"铛铛铛，React18正式发布辣 前置知识： Concurrent(并发) Concurrent 渲染是可中断的。（以前React中update是同步渲染，一旦update开启，在任务完成前都是不可中断的。 在Concurrent模式下，update开始了可以中断，结果是可以继续，也可以选择遗弃。 可中断。任务是有优先级，优先级高的比如用户交互，输入，点击…fiber的链表结构，指向改变。 可被遗弃。比如，一个操作过程，中间的可能切走，不重要或者过期了，所以可以被遗弃，只关注最后的展示。 状态复用。OffScreen，比如页面回退了，又重新进入了；或者即将要渲染的UI进行缓存准备。 总结: 并不是API之类的新特性，而是新特性的基础，包括Suspense、transitions等。 新特性createRoot123const root = createRoot(document.getElementById(&apos;root&apos;))root.render(&lt;App /&gt;)root.render(&lt;App2 /&gt;) 自动批量处理 Automatic Batching setState是同步还是异步呀，可以实现同步嘛，怎么实现，异步的原理是什么？ 18之前：都可以，同步：setTimeout，或者原生事件里同步。异步：批量处理，合成事件里，把多次的render合并起来，关键是依赖合成事件。18之后，同步可用flushSync。就不要用setTimeout，也是异步了，why？不是依靠合成事件，而是自动批量处理。 123flushSync(() =&gt; &#123; // state 变化 &#125;) Suspense加载等待，类似loading 123&lt;Suspense fallback=&#123;&lt;Spin /&gt;&#125;&gt; &lt;Component /&gt;&lt;/Suspense&gt; …_(¦3」∠)_下回再战…","pubDate":"Thu, 07 Apr 2022 01:58:48 GMT","guid":"https://wangyx233.github.io/2022/04/07/[React]React18来啦/","category":"React"},{"title":"【业务】下载导出那些事","link":"https://wangyx233.github.io/2022/04/06/[业务]导出那些事/","description":"平时业务开发中，经常会遇到数据导出的需求，说到导出可以大体概括为两大种类： 纯前端导出 有后端参与导出 纯前端导出这个需求的情况主要是，根据页面上展示的列表数据进行导出，简单的实现方式是将数据拼接，生成一个 url 地址，借助 a 标签下载，如： 1234567891011121314// data的格式 [[&apos;tr1&apos;, &apos;tr2&apos;, &apos;tr3&apos;], [&apos;td1&apos;, &apos;td2&apos;, &apos;td3&apos;]]function getDownloadUrl(data, type) &#123; const _utf = &quot;\\uFEFF&quot;; // 防止Excel中文乱码 let csvData = &apos;&apos; data.forEach(function (elem) &#123; csvData += &quot;\\&quot;&quot; + elem.join(&apos;&quot;,&quot;&apos;) + &quot;\\&quot;\\r\\n&quot;; &#125;) let option = &#123;&#125;; // &#123; type: &apos;text/csv&apos;&#125; if (type === &apos;xls&apos;) option = &#123; type: &quot;application/vnd.ms-excel;charset=utf-8&quot; &#125; const csvBlob = new Blob([_utf + csvData], option) return URL.createObjectURL(csvBlob);&#125; 也可以借用 xlsx 和 file-saver 两个插件来实现。 后端参与导出有接口层参与的导出，接口层返回的数据可能分为两种，一种是直接返回下载资源的地址，另一种是返回二进制数据。 返回一个资源地址返回地址的话，可以借用window.open(url) 或者 window.location.href = url 进行下载。 返回二进制数据这种方式是借助Blob将文件流转换为 Blob 二进制对象，利用URL.createObjectUrl生成 url 地址，利用a标签的href, download配合下载，示例如下：👇🏻 12345678910111213141516171819api.get(url, &#123; responseType: &apos;blob&apos;,&#125;).then((res) =&gt; &#123; const &#123; data, headers &#125; = res const blob = new Blob([data]) const url = URL.createObjectURL(blob) const fileName = decodeURIComponent( `$&#123;headers[&apos;content-disposition&apos;]&#125;`.split(&apos;;&apos;)[1].split(&apos;filename=&apos;)[1] // $&#123;headers[&apos;content-disposition&apos;]&#125;`.match(/filename=(.*);/)[1] ) const a = document.createElement(&apos;a&apos;) a.style.display = &apos;none&apos; a.href = url a.download = fileName document.body.appendChild(a) a.click() document.body.removeChild(a) URL.revokeObjectURL(url)&#125;) 注意： 如果要获取 Content-Disposition，跨域的情况下需要接口层配合 Access-Control-Expose-Headers: Content-Disposition（前端获取到的 header 只有默认的 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。） 请求返回的 Content-type: application/octet-stream responseType: &#39;blob&#39; 设置返回数据的类型，默认是 json 类型 除了这两种方式以外，还可以通过导出接口进行参数拼接直接下载，如window.location.href = &#39;导出接口地址&#39;?date=&#39;2022-04&#39;问题： 参数太多，可能会超过 url 长度限制，编码问题也需要注意(get 请求的)HTTP 协议不对 URI 的长度作事先的限制，服务器必须能够处理任何他们提供资源的 URI，并且应该能够处理无限长度的 URIs，这种无效长度的 URL 可能会在客户端以基于 GET 方式的请求时产生。如果服务器不能处理太长的 URI 的时候，服务器应该返回 414 状态码（此状态码代表 Request-URI 太长）不同的游览器对 URL 的长度限制是有所差异的。 鉴权问题。如果 url 是需要拼接的话，需要在 querystring 中拼接 token 信息 无法知道下载进度，下载用时 浏览器可直接浏览的文件类型是不提供下载的，如 txt、png、jpg、gif 等 总结：在开发中，我们的导出方式经历了从 window.open 到 blob 方式的替换，可以在当前页面下载，无需新开页面的过度，并且下载的过程可控。当然导出方式可以根据实际开发需求自行选择~","pubDate":"Wed, 06 Apr 2022 08:56:48 GMT","guid":"https://wangyx233.github.io/2022/04/06/[业务]导出那些事/","category":"业务"},{"title":"【网络】CDN","link":"https://wangyx233.github.io/2022/04/02/[网络]cdn/","description":"前置知识：正向代理 &amp; 反向代理 正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源。正向代理一般是客户端架设的，反向代理一般是服务器架设的。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。 正向代理中，服务器不知道真正的客户端到底是谁，以为访问自己的是真实的客户端。而在反向代理中，客户端不知道真正的服务器是谁，以为自己访问的是真实的客户端。 正向代理和反向代理的作用和目的不同。正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。 CDN(Content Delivery Network) 是一种内容分发网络，部署在应用层，利用智能分配技术，根据用户访问的地点，按照就近访问的原则分配到多个节点，来实现多点负载均衡。简单来说，用户就近访问，访问速度更快，CDN 的常见实现是有一台源站服务器，多个 CDN 节点定时从源站同步。 CDN 的缓存和回源“缓存”是说我们把资源推送一份到 CDN 服务器上这个过程，“回源”是说 CDN 发现自己没有这个资源或者资源过期了，从而去原站或者或者它的上层服务器请求这个资源的过程。 没有 CDN：用户访问域名 -&gt; 域名解析成对应的 IP(DNS 解析) -&gt; 根据 IP + 请求端口去服务器请求资源 用 CDN：用户访问域名 -&gt; DNS 解析返回配置的 CNAME -&gt; 智能调度 DNS 查询域名(CNAME)的 IP 地址(最适合的 CDN 节点) -&gt; 根据 IP 访问 CDN 节点服务器 -&gt; 有缓存返回，无则回源 Q &amp; A 所以，CDN 是正向代理还是反向代理呢？ 服务端有新的更新，如何清除 CDN 的缓存呢？","pubDate":"Sat, 02 Apr 2022 01:50:00 GMT","guid":"https://wangyx233.github.io/2022/04/02/[网络]cdn/","category":"网络"},{"title":"【网络】传输层我来了","link":"https://wangyx233.github.io/2022/03/21/[网络]传输层/","description":"UDP（User Datagram Protocol，用户数据包协议） TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 对于数据包丢失的情况，TCP 提供重传机制（Acknowledgement Number）； TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件（Sequence Number）。 一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。 建立连接。通过“三次握手”来建立客户端和服务器之间的连接。 1234 客户端 服务端 SYN_SENT -&gt; SYN = 1 seq = x SYN_RCVD &lt;- SYN = 1 ACK = 1 seq = y ack = x + 1ESTABLISHED -&gt; ACK = 1 seq = x + 1 ack = y + 1 ESTABLISHED 两次握手可以吗？ (1) 确认双方的收发能力TCP 建立连接之前，需要确认客户端与服务器双方的收包和发包的能力。 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。所以，只有三次握手才能确认双方的接收与发送能力是否正常。 (2) 序列号可靠同步如果是两次握手，服务端无法确定客户端是否已经接收到了自己发送的初始序列号，如果第二次握手报文丢失，那么客户端就无法知道服务端的初始序列号，那 TCP 的可靠性就无从谈起。 (3) 阻止重复历史连接的初始化三次握手才有足够的上下文信息来判断当前连接是否是历史连接 (4) 安全问题如果采用两次握手，就建立连接，那会放大 DDOS 攻击的。 TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而三次握手恰好可以满足以上两方面的需求！ ISN 代表什么？意义何在？ISN 是固定不变的吗？ISN 为何要动态随机？ ISN 全称是 Initial Sequence Number，是 TCP 发送方的字节数据编号的原点，告诉对方我要开始发送数据的初始化序列号 ISN 如果是固定的，攻击者很容易猜出后续的确认序号，为了安全起见，避免被第三方猜到从而发送伪造的 RST 报文，因此 ISN 是动态生成的 什么是半连接队列？ 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立连接。服务器会把这种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。 三次握手可以携带数据吗？ 第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，疯狂着重复发 SYN 报文，这会让服务器花费大量的内存空间来缓存这些报文，这样服务器就更容易被攻击了。 传输数据接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。 断开连接。“四次挥手”来保证双方都能断开连接 123456客户端 服务端FIN_WAIT_1 -&gt; FIN = 1 seq = uFIN_WAIT_2 &lt;- ACK = 1 seq = v ack = u + 1 CLOSE_WAIT &lt;- FIN = 1 seq = w ack = u + 1 LAST_ACK TIME_WAIT -&gt; ACK = 1 seq = u + 1 ack = w + 1 CLOSE CLOSE 2 MSL 为什么建立连接握手三次，关闭连接时需要是四次呢？ 其实在 TCP 握手的时候，接收端发送 SYN+ACK 的包是将一个 ACK 和一个 SYN 合并到一个包中，所以减少了一次包的发送，三次完成握手。在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 FIN 包与对客户端的 ACK 包合并发送，只能先确认 ACK，然后服务器待无需发送数据时再发送 FIN 包，所以四次挥手时必须是四次数据包的交互。 为什么 TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？ (1) MSL 指的是报文在网络中最大生存时间。在客户端发送对服务器端的 FIN 的确认包 ACK 后，这个 ACK 包是有可能不可达的，服务器端如果收不到 ACK 的话需要重新发送 FIN 包。所以客户端发送 ACK 后需要留出 2MSL 时间（ACK 到达服务器 + 服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。客户端如果等待 2MSL 时间也没有收到服务器端的重传包 FIN，说明可以确认服务器已经收到客户端发送的 ACK。(2) 在客户端发送完最后一个 ACK 报文段后，在经过 2MSL 时间，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文。避免新旧连接混淆。 总结： IP 负责把数据包送达目的主机。 网络层 UDP 负责把数据包送达具体应用。端口号 而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。","pubDate":"Mon, 21 Mar 2022 06:34:01 GMT","guid":"https://wangyx233.github.io/2022/03/21/[网络]传输层/","category":"TCP"},{"title":"碎碎念","link":"https://wangyx233.github.io/2022/03/16/碎碎念/","description":"害，还是加分号吧，减少 debug 的成本来自解构赋值的怒吼。。。","pubDate":"Wed, 16 Mar 2022 03:28:05 GMT","guid":"https://wangyx233.github.io/2022/03/16/碎碎念/","category":""},{"title":"【JS基础】数组乱序","link":"https://wangyx233.github.io/2022/03/10/[JS基础]数组乱序/","description":"最近在解决一个分布式高可用的问题，如何能够让多机的定时任务能够不重复执行，引入了 redis 的分布式锁。但一个任务列表如果都顺序遍历那每个任务的抢占可能不会那么随机，所以想让任务列表打乱顺序，就稍微了解了一下数组乱序的实现。 （其实最后用的还是 lodash 的_.shuffle() 😯 一、随机数？ 123[12,4,16,3].sort(function() &#123; return .5 - Math.random();&#125;) v8 在处理 sort 方法时，使用了插入排序和快排两种方案。当目标数组长度小于 10（不同版本有差别）时，使用插入排序；反之，使用快排。 二、Fisher–Yates shuffle 洗牌算法 123456789101112Array.prototype.shuffle = function() &#123; let array = this; let len = array.length, temp, i; while (len) &#123; i = Math.floor(Math.random() * len--); temp = array[len]; array[len] = array[i]; array[i] = temp; &#125; return array;&#125;","pubDate":"Thu, 10 Mar 2022 08:50:45 GMT","guid":"https://wangyx233.github.io/2022/03/10/[JS基础]数组乱序/","category":"JavaScript"},{"title":"【JS基础】复盘","link":"https://wangyx233.github.io/2022/03/04/[复盘]基础中的基础/","description":"基础知识要深刻，扎实，不要模棱两可，懂个大概 typeof函数的默认返回值是 undefined 呀~ 123456function sayHi () &#123; return (() =&gt; &#123; console.log(1) &#125;)()&#125;console.log(typeof sayHi()) 作用域 与 变量提升 var 声明的变量会进行变量提升 js 代码自上而下执行之前，浏览器首先会把当前上下文中所有带“var / function”关键字进行提前的声明和定义，解析到它们对应作用域开始的位置，这种预先处理的机制叫做变量提升，变量提升的意义在于创建变量前使用这个变量不报错。 变量提升也可以称之为预解析。可以理解为这是词法解析的一个环节，语法解析发生在代码执行前 JavaScript 仅提升声明，而不提升初始化 函数和变量相比，会被优先提升。（函数声明式，函数提升是整个代码块（相当于申明和初始化都提升了）提升到它所在的作用域的最开始执行，函数字面量式，这种情况和变量提升是一样的） 所以看一个变量的值，要结合作用域来判断 作用域12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function sayHi() &#123; console.log(name) console.log(age) var name = &apos;xxx&apos; let age = 18&#125;var name = &apos;outer&apos;function sayHi() &#123; console.log(name) var name = &apos;eric&apos;&#125;function sayHi(name) &#123; console.log(name) var name = &apos;eric&apos;&#125;sayHi(&apos;param&apos;)var name = &quot;world&quot;;(function()&#123; if(typeof name === &quot;undefined&quot;) &#123; var name = &quot;Jack&quot;; console.log(&quot;Hello &quot; + name); &#125; else &#123; console.log(&quot;Hello &quot; + name); &#125;&#125;())function sayHi() &#123; console.log(name) name = &apos;hi&apos;&#125;sayHi()// var a = 1function b() &#123; console.log(a) a = 2&#125;b()console.log(a)var foo=&#123;n:1&#125;;(function (foo) &#123; console.log(foo.n); foo.n = 3; var foo = &#123;n:2&#125;; console.log(foo.n);&#125;)(foo);console.log(foo.n);function f1(a)&#123; // a = 111，有默认值 console.log(a); function a()&#123;&#125; console.log(a); var a = 1; console.log(a);&#125;f1(2) 函数的参数名是按值传递的，参数类型是引用类型的话，传递的是引用的地址。 函数参数和变量的问题： 函数有形参，形参会被添加到函数的作用域中，并且形参不会被重新定义。var 声明与形参同名的变量会被忽略，即参数的优先级高于变量的提升。 ES6 的 let 和 const 会因为作用域内重复声明而报错。 如果函数内声明一个和形参同名的函数，装载顺序为 函数参数 &gt; 函数声明，而在函数声明装载时，如果函数体内有个和参数名相同的函数声明，那么这个函数就会覆盖形参。 有默认参数的，再传实参，参数值 会覆盖 函数声明。 let： let 声明的变量的作用域是块级的； let 不能重复声明已存在的变量； let 有暂时性死区，不会被提升。 this12345678910const shape = &#123; radius: 10, diameter: function() &#123; return this.radius * 2 &#125;, perimeter: () =&gt; 2 * 3.14 * this.radius&#125;console.log(shape.diameter())console.log(shape.perimeter()) undefined 的类型转换如何判断是不是 NaN window.isNaN 会先把参数转化为数字类型,再判断是不是 NaN,所以像 string 类型的会是 true; 而 Number.isNaN 会先判断参数是不是数字类型,不是就返回 false, 是数字类型再进入判断是不是 NaN 利用 NaN 是 JavaScript 之中唯一不等于自身的值 Object.is(+0, -0)，Object.is() 是 ES6 用来比较两个值是否严格相等","pubDate":"Fri, 04 Mar 2022 07:12:21 GMT","guid":"https://wangyx233.github.io/2022/03/04/[复盘]基础中的基础/","category":"JavaScript"},{"title":"【CSS】flex & grid","link":"https://wangyx233.github.io/2022/02/23/[CSS]flex copy/","description":"平时常用 flex 进行对齐和布局，习惯了 align-items 和 justify-content，也会遇到过宽度换行的情况。 flex: 1 是什么？ 2 是什么？ 10px？有单位是 flex-basis 的值，无单位的话则为 flex-grow 的值 即：一个无单位数(): 它会被当作 flex: 1 0;注：省略值和默认值不同 12345678910/* 关键字值 */flex: initial; // 0 1 auto 根据自身宽高设置尺寸，会收缩但不会伸长。适合一侧宽度固定，另一侧宽度任意，display: flex; 默认值flex: auto; // 1 1 auto 根据自身宽高，会收缩会伸长；优先扩张，适合内容动态适配flex: none; // 0 0 auto 根据自身宽高设置尺寸，不会收缩也不会伸长；适合自身不变的flex-grow: 省略时1flex-shrink: 省略时1flex-basis: 省略时0flex: 1 -&gt; 1 1 0% // 优先缩小自己的体积，充分利用剩余空间，又不侵占其他元素的位置，适合等分flex: 10px -&gt; 1 1 10px 最近有使用 grid 布局 1234display: grid;grid-template-columns: repeat(3, 1fr);grid-template-rows: repeat(3, 1fr);grid-gap: 10px;","pubDate":"Wed, 23 Feb 2022 09:41:33 GMT","guid":"https://wangyx233.github.io/2022/02/23/[CSS]flex copy/","category":"css"},{"title":"<JS基础>手写小试","link":"https://wangyx233.github.io/2022/02/16/[JS基础]手写小试/","description":"一、数组扁平化如何将一个多维数组变成一个一维数组，如： 12const arr = [1, [2, [3, [4, [5]]]]]// =&gt; [1,2,3,4,5] 看到数组扁平，第一想到的是 concat()，然后是递归，依次实现一番。 (1) 递归 1234567891011function flat(arr, depth = 1) &#123; let res = [] arr.forEach((elem) =&gt; &#123; if(!Array.isArray(elem) || !depth)&#123; res.push(elem) &#125;else &#123; res = res.concat(flat(elem, depth - 1)) &#125; &#125;) return res&#125; (2) reduce()配合 concat() 123function flat(arr, depth = 1) &#123; return depth ? arr.reduce((temp, elem) =&gt; (temp.concat(Array.isArray(elem) ? flat(elem, depth - 1) : elem)) , []) : arr&#125; (3) 内置 API，一顿操作，竟然忽略了 Js Array 的内置 api–flat()，按指定深度递归遍历数组，将所有元素与遍历的子数组中的元素合并为一个新数组返回。 12var newArray = arr.flat([depth])const res = arr.flat(Infinity); (4) 正则，另辟蹊径 12const res1 = JSON.stringify(arr).replace(/\\[|\\]/g, &apos;&apos;).split(&apos;,&apos;); // 原来数字变成了字符串const res2 = JSON.parse(`[$&#123;JSON.stringify(arr).replace(/\\[|\\]/g, &apos;&apos;)&#125;]`); (5) 迭代 1234567function flat(arr, depth = 1) &#123; while(arr.some(elem =&gt; Array.isArray(elem)) &amp;&amp; depth) &#123; arr = [].concat(...arr) depth-- &#125; return arr&#125; 二、数组去重12const arr = [1, 17, &apos;1&apos;, 17, true, true, false, false, &apos;true&apos;, &apos;a&apos;, &#123;&#125;, &#123;&#125;];// =&gt; [1, &apos;1&apos;, 17, true, false, &apos;true&apos;, &apos;a&apos;, &#123;&#125;, &#123;&#125;] 看到数组去重，首先想到的是维护一个 object 用于记录出现过的值然后去掉重复，然后想到 filter 也可以实现类似的 (1) object 方法，普通 object 的 key 都会转换成 String 类型，所以可以借助 ES6 的 Map; 1234567891011const uniq = (arr) =&gt; &#123; const map = new Map(); const res = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (!map.has(arr[i])) &#123; map.set(arr[i], true); res.push(arr[i]); &#125; &#125; return res;&#125; (2) filter，过滤得到首次出现的元素。判断元素是否出现过还可以使用 arr.indexOf(elem) === -1 或者 arr.includes(elem) 1const res = arr.filter((elem, index) =&gt; arr.indexOf(elem) === index); (3) ES6 的 Set 数据结构，特性是每个元素都是唯一的，没有重复的值 12const res = [...new Set(arr)];[...new Set(&apos;ababbc&apos;)].join(&apos;&apos;); // &apos;abc&apos; 三、深拷贝12345678910111213function cloneDeep(data, exist = new Map()) &#123; if(typeof data !== &apos;object&apos; || data === null) return data if(data instanceof Date) return new Date(data) if(data instanceof RegExp) return new RegExp(data) if(exist.has(data)) return exist.get(data) let result = Array.isArray(data) ? [] : &#123;&#125; exist.set(data, result) const keys = [...Object.keys(data), ...Object.getOwnPropertySymbols(data)] keys.forEach(key =&gt; &#123; result[key] = cloneDeep(data[key], exist) &#125;) return result&#125; // 两个有序数组[1,3,5]和[2,4,6]，写一个 mergeArr(a,b)合并两个数组，最终得到一个有序数组 _.get() 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？","pubDate":"Wed, 16 Feb 2022 06:44:26 GMT","guid":"https://wangyx233.github.io/2022/02/16/[JS基础]手写小试/","category":""},{"title":"【浏览器】从输入URL到页面展示发生了什么？","link":"https://wangyx233.github.io/2022/02/16/[浏览器]从输入URL到页面展示发生了什么/","description":"前置知识：目前浏览器都有哪些进程？ 浏览器主进程 渲染进程：默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中。 网络进程 GPU 进程 插件进程 1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程 多进程模型提升了浏览器的稳定性、流畅性和安全性。但同样不可避免地带来了一些问题，更高的资源占用，更复杂的体系架构。为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统。浏览器的主进程，渲染进程，插件进程。其他的变成基本服务，比如，网络进程、GPU 进程、Audio 进程、Video 进程、文件进程、Profile 进程、UI 进程、设备进程…内存不够的系统中，会把相关的进程都合并进主进程。 用户输入 url 并回车 浏览器进程检查 url，组装协议，构成完整的 url 浏览器进程通过进程间通信（IPC）把 url 请求发送给网络进程 网络进程接收到 url 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程 如果没有，网络进程向 web 服务器发起 http 请求（网络请求），请求流程如下： 进行 DNS 解析，获取服务器 ip 地址，端口（端口是输入的，没输入 http 80，https 443)，如果请求协议是 HTTPS，那么还需要建立 TLS 连接 利用 ip 地址和服务器建立 tcp 连接 构建请求头信息 发送请求头信息 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容 网络进程解析响应流程； 检查状态码，如果是 301/302，则需要重定向，从 Location 自动中读取地址，重新进行第 4 步 （301/302 跳转也会读取本地缓存），如果是 200，则继续处理请求。 200 响应处理：检查响应类型 Content-Type，如果是字节流类型(application/octet-stream)，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是 html 则通知浏览器进程准备渲染进程准备进行渲染。 准备渲染进程 浏览器进程检查当前 url 是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程(process-per-site-instance) 传输数据、更新状态。 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道” 渲染进程接收完数据后，向浏览器发送“确认提交” 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏 url、前进后退的历史状态、更新 web 页面 总体来说，分为网络请求和渲染两大部分，即导航流程和渲染流程。","pubDate":"Wed, 16 Feb 2022 02:04:47 GMT","guid":"https://wangyx233.github.io/2022/02/16/[浏览器]从输入URL到页面展示发生了什么/","category":"浏览器"},{"title":"【JS基础】执行","link":"https://wangyx233.github.io/2022/02/15/[JS基础]执行/","description":"JavaScript 执行主要分为两个阶段： 代码预编译阶段 代码执行阶段 代码预编译阶段 预编译阶段进行变量声明 预编译阶段变量声明进行提升，但是值为 undefined 预编译阶段所有非表达式的函数声明进行提升 12345678910111213foo(10)function foo (num) &#123; console.log(foo) foo = num; console.log(foo) var foo&#125;console.log(foo)foo = 1console.log(foo)// undefined// 10// 1 作用域在预编译阶段确定，但是作用域链是在执行上下文的创建阶段完全生成的。执行上下文包括了：变量对象、作用域链以及 this 的指向 预编译阶段创建变量对象(Variable Object, VO)，在执行阶段，变量对象转换为激活对象(Active Object)，即完成 VO -&gt; AO 正常来讲，在函数执行完毕并出栈时，函数内局部变量在下一个垃圾回收节点会被回收，该函数对应的执行上下文将会被销毁，这也正是我们在外界无法访问函数内定义的变量的原因。也就是说，只有在函数执行时，相关函数可以访问该变量，该变量在预编译阶段进行创建，在执行阶段进行激活，在函数执行完毕后，相关上下文被销毁。 闭包： 函数嵌套函数时，内层函数引用了外层函数作用域下的变量，并且内层函数在全局环境下可访问，就形成了闭包。 浏览器的垃圾清除 标记清除 引用计数","pubDate":"Tue, 15 Feb 2022 06:26:06 GMT","guid":"https://wangyx233.github.io/2022/02/15/[JS基础]执行/","category":"JavaScript"},{"title":"【读书】JavaScript高级程序设计","link":"https://wangyx233.github.io/2021/07/13/[读书]JavaScript高级程序设计/","description":"script标签defer vs async共同点：只对外部脚本有效，src=’xxx’不同： defer表明脚本立即下载，但是执行会推迟，在DOMContentLoaded之前执行。即加载无需等待，HTML5规定执行需要有序的。async表明脚本会并行下载，下载完立即执行，不保证执行的顺序。会在页面loaded执行前完成。类似 DOM 内通过createElement创建script标签(可配合rel=’preload’)。","pubDate":"Tue, 13 Jul 2021 03:21:58 GMT","guid":"https://wangyx233.github.io/2021/07/13/[读书]JavaScript高级程序设计/","category":"生活"},{"title":"浏览器の网络-HTTP","link":"https://wangyx233.github.io/2021/06/30/浏览器の网络-HTTP/","description":"HTTPHTTP是应用层协议","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/浏览器の网络-HTTP/","category":"网络"},{"title":"HTTPS","link":"https://wangyx233.github.io/2021/06/30/安全了-HTTPS/","description":"HTTP的明文传输带来的问题，可能在传输过程中信息被窃取或者篡改，伪造，容易发生中间人攻击。HTTP -&gt; 安全层（SSL/TLS） -&gt; 传输层 -&gt; 网络层，其中安全层的作用是对发送的HTTP请求进行加密操作，以及对接收到的HTTP请求进行解密操作。 对称加密，非对称加密的优缺点，得到一个对称加密和非对称加密搭配使用的方式。传输过程中使用对称加密传输数据，而对称加密所需的密钥则通过非对称加密传输。搭配数字证书，数字证书是向浏览器方明确服务器方的身份，以及提供公钥。 浏览器端向服务端发送请求，包含对称加密套件列表 + 非对称加密套件列表 + client_random 服务端接到请求后，向浏览器端发送选择的，对称加密套件 + 非对称加密套件 + service_random + 数字证书 浏览器端接到响应，先验证数字证书，然后 client_random + service_random 生成 pre_master，用公钥加密pre_master，再加浏览器确认，发送到服务端 服务端接到请求先用私钥解密，得到pre_master，服务器发送确认 开始 client_random + service_random + premaster 生成的 master secret 加密的数据进行传输。","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/安全了-HTTPS/","category":"网络"},{"title":"同源策略与Web安全","link":"https://wangyx233.github.io/2021/06/30/web安全/","description":"安全问题Web页面安全，浏览器网络安全，浏览器安全 同源策略 Same-origin policy什么是同源？ 两个URL的协议、域名、端口都相同，则这两个URL同源 12http://www.yixuanwang.cn/?article=1http://www.yixuanwang.cn/?article=0 相同源之间可以互相访问资源和操作DOM结点的，不同源之间会有一定安全策略的制约，即为同源策略。不同源之间不能对DOM对象进行读写操作，不能读取Cookie、LocalStorage等数据，也不能通过XMLHttpRequest传递数据。如果想做以上操作怎么办？ 页面引用第三方资源可能会导致XSS攻击 -&gt; CSP 内容安全策略，让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码 安全地进行数据传递，CORS跨域资源共享 安全地相互操作DOM，跨文档消息机制window.postMessage XSS攻击-Cross Site Scripting 跨站脚本是什么XSS是指攻击者向HTML，DOM中注入恶意脚本，从而在用户浏览页面时通过恶意注入的脚本对用户实施攻击。可能会获取用户的Cookies，监控用户的行为“addEventListener”，也可能通过DOM伪造假的登录窗口，也可能生成浮窗广告，影响体验。 存储型XSS，恶意脚本插入网站的数据库里，再读取的时候会进行攻击。 反射型 XSS 攻击，在请求连接里注入恶意脚本，将请求提交给Web服务器，Web服务器收到请求，又将恶意代码反射给了浏览器 基于 DOM 的 XSS 攻击，不涉及服务器，通过页面劫持等方法将恶意脚本注入页面，修改web页面 怎么办 服务器对输入数据进行转码 充分利用CSP(Content-Security-Policy)，限制其他源的资源下载，禁止向第三方域提交数据，禁止执行内联脚本和未授权的脚本，即使上报 使用 HttpOnly 属性，HTTP的响应头，set-cookied: xxxx ; HttpOnly。只能通过HTTP请求使用，无法通过document.cookie获取还可以通过添加验证码的方式防止脚本冒充用户进行提交危险操作，对于一些不信任的输入，还可以限制其输入长度 npm xss库 CSRF攻击：陌生链接不要随便点是什么CSRF(Cross-site request forgery)，跨站请求伪造。攻击者引诱用户打开恶意网站，利用用户的登录状态，发起跨站请求做坏事。 自动发起GET请求，如将请求接口隐藏在图片中： 1&lt;img src=&quot;http://www.abc.cn/sendcoin?user=xxx&amp;number=10&quot;/&gt; 自动发起POST请求，一个隐藏的表单 引诱用户点击链接 怎么办 对于响应头的Cookie设置，SameSite可以设置Strict、Lax 和 None 验证请求的来源站点，通过Origin，Referer判断 设置CSRF Token，每次请求都携带该token进行验证","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/web安全/","category":"安全"},{"title":"【读书】小狗钱钱","link":"https://wangyx233.github.io/2021/06/30/[读书]小狗钱钱/","description":"如何实现梦想 要有自信！！！（建立自信，最好每天写成功日记） 72小时法则：当你决定做一件事的时候，必须在72小时内开始行动，不然很有可能再也不会做（上升到本人，大概需要在72秒内就做吧🐶） 不要抱怨 一定要坚持！！！养成习惯 幸运是充分准备加努力工作的结果 利用碎片化时间，珍惜时间，不要等待。每天十分钟，可以带来真正的改变 要勇敢 如何赚💰","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[读书]小狗钱钱/","category":"生活"},{"title":"【网络】前端开发中的HTTP","link":"https://wangyx233.github.io/2021/06/30/[网络]http/","description":"知识点 HTTP的缓存机制！！！重要 状态码 headers Restful API 状态码 分类 1xx 服务器收到请求 2xx 请求成功 3xx 重定向 4xx 客户端错误 5xx 服务端错误 常见 200 成功 301 永久重定向（配合location新地址，浏览器自动处理，下次会直接访问新的地址） 302 临时重定向（配合location新地址，浏览器自动处理，下次还会访问旧的地址）短网址，百度之类的搜索引擎的链接，why？ 304 资源未修改，缓存 注 307 internal redirect 403 没有权限 404 not found 500 服务器错误 502 504 网关超时，服务器内部 协议规范 Restful API API设计方法，把每个URL当做唯一的资源标识。如何设计一个资源？ 尽量不用url参数，如：/api/list?page=2 -&gt; /api/list/2 用method表示操作类型，POST,PATCH/PUT,DELETE,GET HTTP Headers 常见的Request Headers Accept 浏览器可以的数据格式 Accept-Encoding 浏览器可支持的压缩算法，如：gzip Accept-Language 浏览器支持的语言 Connection: keep-alive 保持TCP连接 Cookie Host User-Agent Content-Type 发送数据格式，如：application/json Authorization token验证 常见的Response Headers Content-Type 发送数据格式，如：application/json Content-Length 返回数据的大小，多少字节 Content-Encoding 返回数据的压缩算法，如：gzip Set-Cookie 服务端改cookie 自定义headers 用于缓存的headers HTTP缓存机制什么是缓存？为什么需要缓存？哪些资源可以被缓存-&gt;js/css/img静态资源和业务数据，html不能被缓存 页面加载更快，网络请求慢，减少网络请求的体积和数量，也是不稳定的 强制缓存服务端控制什么资源可以缓存，通过Response Headers中的cache-control 控制过期时间Cache-Control的值 max-age=86400(秒) no-cache 不用强制缓存，去服务端处理 no-store 不用强制缓存，也不用服务器缓存 private 允许用户客户端做缓存 public 允许中间如cdnExpires也是做缓存过期控制的，已被Cache-Control代替，以Cache-Control为主 协商缓存(对比缓存)服务端缓存策略，服务端来判断是否用缓存，即服务端判断客户端资源是否和服务端资源一样。如果一致则返回304，否则返回200和最新资源注意：资源标识 Response Headers里Last-Modified：资源最后修改时间(精确到秒级)，Etag资源的唯一标识(优先级高，资源被重复生成而内容不变) 再次请求的时候，If-Modified-Since: Last-Modified时间(Request Headers里) Etag，If-None-Match: Etag的值(Request Headers里)两者共存会优先使用Etag，Last-Modified只能精确到秒级 整个缓存过程！ 刷新页面 正常操作：浏览器url，跳转，前进后退等。 强制缓存有效，协商缓存有效 手动刷新，F5，刷新按钮 强制缓存失效，协商缓存有效 强制刷新 强制缓存失效，协商缓存失效","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[网络]http/","category":"网络"},{"title":"【版本管理】gitの世界","link":"https://wangyx233.github.io/2021/06/30/[版本管理]git的世界/","description":"配置1234git --versiongit config --global user.name &apos;xxx&apos;git config --global user.email &apos;xxx&apos;git config --list local global system 工作区/暂存区1git add -u // 已经被管理的文件 update 重命名，git的命令类比linux的系统命令，可直接git commit 12git rm xxx // 删除git mv old new git log 123git log --onelinegit log -n // 最近几次commitgit log -all --graph// 所有分支 git branch 12git branch -v // 本地分支git branch -av .git文件夹 HEAD 指向某个commit 12git checkout -b branch git diff HEAD HEAD^^ / HEAD~n config refs heads 分支 tags 里程碑 objectsblob文件对象 tree commit三者之间的关系只要文件的内容相同，在git里就是唯一的，和文件名没有关系加入暂存区的内容，才会再objects里面有体现commit -&gt; tree -&gt; blob12git cat-file -t xxx 看文件的类型git cat-file -p xxx 看内容 分离头指针 detached HEAD 没有经过某个分支做修改git checkout commit-id 开发后切换分支易丢失，会提示创建新分支git branch name commit-id在分支上做变更 branch 清理 123git branch -vgit branch -dgit branch -D 修改commit message 12git commit --amend // 最近一次commitgit rebase -i // 变基要修改的父commit，在为同步到远端，合并commit也可以实现 diff 1234git diff --cached //暂存区和HEAD的不同git diff // 工作区和暂存区的差异，不加参数是比较所有变动git diff -- filename filename filename git diff branch_name/commit-id/ branch_name/commit-id -- filename 1234git reset HEAD // 暂存区恢复到工作区git reset HEAD -- filenamegit reset --hard/--soft commit-idgit checkout -- filename // 工作区内容恢复到暂存区一样 stash 1234git stashgit stash listgit stash pop // stash git stash apply // stash 列表内的信息还在 .gitignore 12xxx/ // xxx的文件夹会被忽略xxx // xxx的文件和文件夹都会忽略 备份 哑协议：没有协议头 xxx/xx.git，看不到传输速度，速率没有智能协议高 智能协议：带协议头 &gt; file:///xxx/xxx.git12git clone --baregit remote add xxx.git 远端操作，fast-forwards，解决冲突，集成的分支不要做变基，注意fast-forwards 1234git fetchgit mergegit pullgit push git vs svn svn需要获取批准 权限问题，效率 可以托管代码，协同合作 工作流 rerere 123456git config --local rerere.enabled truegit merge // 解决冲突git addgit commitgit resetgit rebase","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[版本管理]git的世界/","category":"git"},{"title":"【必备】开发环境 & 运行环境","link":"https://wangyx233.github.io/2021/06/30/[开发]工具/","description":"开发环境 git 调试工具 抓包 webpack babel linux gitgit show commit-id ~/.ssh 抓包 同一个局域网下 手机配电脑的代理 设置ssh代理proxy 重定向map webpack &amp; babel ES6模块化 export {aaa,bbb,ccc}; import {aaa,bbb,ccc} from ‘xxx’ export default {aaa}; import a from ‘xxx’ ES6语法 压缩，整合代码，配置 常用linux命令- ls -a - mv old new 修改文件名 - cp name copyname - cat head tail - grep 查找 - vimtutor运行环境 页面加载过程 性能优化 安全 页面加载过程 从输入url到渲染出页面的整个过程 window.onload vs DOMContentLoaded 加载资源形式 加载过程 DNS解析：域名-&gt;IP地址 浏览器根据IP地址向服务器发起http请求 服务器处理请求，并返回给浏览器 渲染过程 DOM树 CSSOM DOM + CSSOM -&gt; Render Tree 根据Render Tree渲染页面 遇到 script 则暂停渲染，优先加载js文件，执行js 代码 直到渲染完 css文件为什么要放在head中？避免重复渲染js为什么要放在body最后？不阻塞加载 load // 页面全部加载完，整个资源加载完，比如img，视频，iframe都加载完DOMContentLoaded // DOM渲染完即可执行window.load 性能优化原则 减少CPU计算量，减少网络加载耗时 多使用缓存 - 空间换时间（Chrome浏览器，简洁，每个标签页一个进程） 从何入手 加载更快 减少资源体积：压缩代码（JS，CSS，图片…）服务器端gzip，三分之一 减少访问次数：合并代码，SSR服务端渲染，缓存(文件内容不变，hash不变) 使用更快的网络，CDN 渲染更快 css放在head，js放在body最后 尽早的执行js，用DOMContentLoaded 懒加载，图片懒加载 对DOM查询进行缓存 频繁DOM操作合并一起 节流 throttle、防抖 debounce 防抖 debounce 两个事件之间的时间间隔超过time才会执行，没超过间隔的任务都会取消。即在事件结束和暂停的时候触发，间断理解 12345678910function debounce(fn, delay = 500) &#123; let timer = null; return function () &#123; if (timer) clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); timer = null; &#125;, delay); &#125;&#125; 节流 throttle 无论触发速率多快，都保持一个频率触发。比如，拖拽时间，无论拖拽的多快都会每隔100ms触发一次。 12345678910function throttle(fn, delay = 100) &#123; let timer = null; return function () &#123; if (timer) return; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); timer = null; &#125;, delay); &#125;&#125;","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[开发]工具/","category":"工具"}]}