{"title":"Hexo","description":null,"language":null,"link":"https://wangyx233.github.io","pubDate":"Tue, 28 Jul 2020 08:40:39 GMT","lastBuildDate":"Wed, 29 Jul 2020 08:47:21 GMT","generator":"hexo-generator-json-feed","webMaster":"Xuan","items":[{"title":"<重温JS>数据类型及基本转换","link":"https://wangyx233.github.io/2020/07/28/重温学习/","description":"7 种语言类型undefined 是一个变量，而并非是一个关键字。老的浏览器中会是，ES5 以后就不是了。函数内部，对象的属性现在也是可以赋值的。if(typeof str === ‘undefined’){// 如果直接用 str === undefined, str 未声明的话可能会报错 not defined}String 用于表示文本数据。String 有最大长度是 2^53 - 1，字符串的 UTF16 编码，charAt、charCodeAt、length 等方法针对的都是 UTF16 编码，其实一个 utf16 单元代表一个字符，这俩数量是对应的，0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）Number 2^64-2^53+3NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字；Infinity，无穷大；-Infinity，负无穷大。还有 +0 -0，1/x 是 Infinity 还是 -Infinity双精度浮点数，有效的检测范围-0x1fffffffffffff 至 0x1fffffffffffff，浮点数运算精度的问题比较浮点数的准确方法是：与 JS 提供的最小精度比较 Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON Symbol，非字符串 key 的集合， 可以用于迭代器，Symbol.iterator 需要有 next，next 返回一个对象包括 value 和 done 12345678910111213var o = new Objecto[Symbol.iterator] = function() &#123; var v = 0 return &#123; next: function() &#123; return &#123; value: v++, done: v &gt; 10 &#125; &#125; &#125;&#125;;for(var v of o) console.log(v); // 0 1 2 3 ... 9 StringToNumber，字符串转换为数组支持进制转换，支持科学计数法，即用 Number()转换。不建议使用 parseInt，用的时候最好传入第二个参数。parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。都会忽略字符串前后的空格 Number进行十进制的转换，若字符串中带有非数字，都会变成 NaN，数字会正常转换若 0 开头则会被忽略。如果是对象，则先调用对象的 valueOf()方法，如果为 NaN，则再调用 toString() 1234567Number(&apos;&apos;) 0Number(true) 1Number(null) 0Number(undefined) NaNNumber(&apos;123aaa&apos;) NaNNumber([]) 0 -&gt; Number(&apos;&apos;)+string parseInt(string, radix)如果字符串以数字开头，则会忽略掉后续的非数字进行类型转换，否则返回 NaN，即找到字符串中的数字进行转换，若没有则为 NaN。以’0x’开头的十六进制也会转换，浮点数是向下取整，科学计数法也是不会正常转换的radix 不填或填 0 的时候默认为 10,取值范围为 2 ～ 36,radix 超出指定范围返回 NaN，若转换的数字大于 radio，也返回 NaN。 12345parseInt(&apos;123aaa&apos;) // 123parseInt([]) // NaN[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(parseInt) -&gt; [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map((elem, index) =&gt; parseInt(elem, index)) // [1, NaN, NaN][&apos;10&apos;,&apos;10&apos;,&apos;10&apos;,&apos;10&apos;,&apos;10&apos;].map(parseInt) // [10, NaN, 2, 3, 4][&apos;1.1&apos;, &apos;2&apos;, &apos;0.3&apos;].map(parseInt) // [1, NaN, 0] 数组的 toString(),会返回一个字符串的拼接；valueOf 还是返回数组。 NumberToString，正常。 装箱装箱，是指讲基本数据类型转化为对象，会频繁产生临时对象，在一些性能要求高的情况下，尽量避免。.运算符提供了装箱操作，所以基本类型通过.可以临时创建一个对象来调用对象的方法。Object.prototype.toString.call() 是可以准确识别对象对应的基本类型的方法，它比 instanceof(constructor) 更加准确，因为 JS 中没有方法可以更改私有的 class 属性。call 本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。 拆箱拆箱是把对象转换成基本数据类型。toPrimitive对象到 Number，String 的转换都遵循“先拆箱再转换”的原则。把对象-&gt;基本类型-&gt;对应的 String/Number 通过调用 valueOf()，toString()，没有则报错 TypeError。ES6 以后可以用 Symbol.toPrimitive 自定义转换覆盖以前的 valueOf()，toString()。 通过 new Number()声明的类型和直接用 Number()声明的类型不同，object 与 number 的区别。toString()还可以传入进制进行计算。valueOf 返回数字 toFixed(), toPrecision(num)向上取整, toExponential()科学计数法 String,chartAt(index),chartCodeAt(index) PS: 实现一个 parseInt()，Number()","pubDate":"Tue, 28 Jul 2020 08:40:39 GMT","guid":"https://wangyx233.github.io/2020/07/28/重温学习/","category":""},{"title":"JS基础回顾","link":"https://wangyx233.github.io/2020/07/28/基础回顾/","description":"内置类型加上 ES6 新加的 Symbol，共 7 种，分别为 String， Number， Boolean， Object， Undefined， Null。分为基本数据类型(6)和 Object。对于基本数据类型，通过字面量的方式声明，类型依旧是字面量，只有在使用的时候才会转换为对应的类型。 123456typeof() 特别： Symbol-&gt;symbol 函数-&gt;function, null-&gt;object。历史原因对象以000开头，而null恰好为全零通过Object.prototype.toString.call()可判断准确的类型[object Type] PS: Symbol 类型(唯一的值)通过 Symbol()定义，定义后的值不相等，System.prototype.description 为定义时 Symbol(‘xxx’)的标识。使用场景：作为对象的属性 1234567let sym = Symbol();let a = &#123;&#125;;a[sym] = &apos;symbol&apos;;a = &#123; [sym]: &apos;symbol&apos;&#125;Object.defineProperty(a, sym, &#123;value: &apos;symbol&apos;&#125;) 注： 不能用.运算符，.运算符会直接作为字符串取值。 Symbol 作为属性名，不会出现在 for…in, for…of 中，也不会出现在 Object.keys(), Object.getOwnPropertyNames()、JSON.stringify()里。 但也不是私有属性，Object.getOwnPropertySymbols，可以获取指定对象的所有 Symbol 属性名。 新的 API:Reflect.ownKeys 可以返回所有类型的键名，包括常规键名和 Symbol 键名。 Symbol.for(description)若没有则会创建一个，若存在则共用一个 symbol 值。 Symbol.keyFor(sym)返回一个已登记即 Symbol.for 的 Symbol 类型值的 key 其他方法可在需要是再查找。 类型转换转 Boolean 类型。在条件判断时，除了 undefined， null， false， NaN， ‘’， 0， -0，其他所有值都转为 true，包括所有对象对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。注：‘a’ + + ‘b’ – ‘aNaN’ 1234x==y 比较undefined == null // true[] == true // false[] == ![] // true [].toString() -&gt; &apos;&apos;，!取反运算符的优先级会高于==， ![] -》 false undefined == null，结果是 true。且它俩与所有其他值比较的结果都是 false。 String == Boolean，需要两个操作数同时转为 Number。 String/Boolean == Number，需要 String/Boolean 转为 Number。 Object == Primitive，需要 Object 转为 Primitive(具体通过 valueOf 和 toString 方法)。 原型","pubDate":"Tue, 28 Jul 2020 08:40:39 GMT","guid":"https://wangyx233.github.io/2020/07/28/基础回顾/","category":""},{"title":"<Work> 实践","link":"https://wangyx233.github.io/2020/07/28/[实践]性能优化二三事/","description":"Performance gzip 告警系统/埋点 图表优化，步骤，加载 其他的通用的方式：秒开率控制，toB 的没有这么多顾虑减少 http 请求 =&gt; JS,CSS 打包，小图片用 data-uri，svg。避免大型背景图利用缓存了解整个前端加载的过程。DNS 解析 =&gt; HTTP DNSTCP 链接三次握手。HTTP/TLS HTTP 2 / HTTPS 首先得评估下现状，要配合实际情况和业务情况进行性能优化，还得设计相关的指标和标准。最后对结果进行评估，有始有终哦 Tool开发体验，提升效率工具体系构建：版本统一，避免冲突。用一套统一的过程比较方便，从 init 到 dev 再到 public。重要的是构建时间，效率 持续性构建手动，自动。代码提交到仓库，自动发布到测试环境，自动发布系统。结构扫描 phantomjs，代码扫描 jshint，数据采集通过 performance API 检测性能，window.onerror 检测问题。组件化，兼容性，适配性：ppi，dpr。PWA组件化： 三大框架，web component，css houdini，不需要任何额外的运行时支持，就能在现代浏览器环境运行，也可以跟 HTML 无缝结合。适配： PPI:Pixel Per Inch 单位英寸像素，屏幕的显示质量。文字，media query DPR:Device Pixel Ratio 设备像素比例，物理像素与逻辑像素 px 之间的关系。viewport 控制缩放比 Resolution: 分辨率，屏幕区域的宽高所占像素数。用 vw，vh 解决 单页应用","pubDate":"Tue, 28 Jul 2020 08:40:39 GMT","guid":"https://wangyx233.github.io/2020/07/28/[实践]性能优化二三事/","category":"JavaScript"},{"title":"<JS Review>对象","link":"https://wangyx233.github.io/2020/07/28/[重温JS]对象/","description":"对象是什么？ 具有唯一标识，内存地址。 具有状态，属性。 具有行为，方法。 JS 的对象具有高度的动态性，可以在运行时对对象添加状态，修改行为。JS 中 Object 的定义，用 new 构造函数()、对象字面量 构造类的函数-&gt;类的构造函数，一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。用 this 创建对象，无需重新创建一个对象再返回。创建对象的方法，字面量，构造函数 new Object()，Object.create(proto, [propertiesObject]) 12345678let a = &#123;name: &apos;xxx&apos;&#125;function Person(name) &#123; this.name = name;&#125;let b = new Person(&apos;xxx&apos;)Object.creat(&#123;name: &apos;xxx&apos;&#125;) 对象的属性类型JS 中，属性和方法其实都可以成为对象的属性。属性并不是简单的名称和值，可以用一组特征来描述属性，可分为数据属性和访问器(getter/setter)属性两类。 数据属性。这个就是常见的对象属性，具有以下特征： value writable：能否被赋值 enumerable：被 for in 枚举 configurable：被删除，或者改变特征值。false 时，writable 可从 true-&gt;false，但无法反向修改。enumerable 则不能修改，会报 TypeError: cannot redefine property。一旦设置为 false，cannot set true 访问器(getter/setter)属性。属性在读写的时候执行。 getter：get: () =&gt; {} || undifined setter: set: () =&gt; {} || undifined，两者成对出现，若不设置则为 undefined enumerable：被 for in 枚举 configurable：被删除，或者改变特征值ES5 以后：查看属性可用，Object.getOwnPropertyDescripter(object, ‘key’)设置属性的特性可用，Object.defineProperty(object, ‘key’, {})如果通过赋值的方式为属性赋值，则该属性的特征都默认为 true。但如果通过 defineProperty 赋值而不指定特性，则特征都默认为 false 123456789var o = &#123;a:1&#125;;o.b = 2;Object.getOwnPropertyDescripter(o, &apos;b&apos;);Object.defineProperty(o, &apos;c&apos;, &#123;value: 3&#125;);Object.getOwnPropertyDescripter(o, &apos;c&apos;);var o = &#123; get a() &#123; return &apos;a&apos; &#125; &#125;;Object.defineProperty(o, &apos;b&apos;, &#123;get: () =&gt; 2, set: (b) =&gt; console.log(b), configurable:true&#125;) 原型","pubDate":"Tue, 28 Jul 2020 08:40:39 GMT","guid":"https://wangyx233.github.io/2020/07/28/[重温JS]对象/","category":"JavaScript,Object,prototype"},{"title":"<CSS>Flex","link":"https://wangyx233.github.io/2020/07/22/[CSS]flex/","description":"flex: 1flex-shrinkflex-growflex-basis 标准盒模型：margin，border，padding，width(即 content area)ie 的 margin，width(border,padding , content area width) BFC(Block formatting context) 块级格式化上下文，W3C CSS2.1 规范中的一个概念。盒模型布局的 css 渲染模式，一个隔离的独立容器(独立渲染区域)通俗理解，BFC 像一个封闭的箱子，内部元素随意变换不会影响外部的布局。BFC 的形成条件：html浮动元素：float 除 none 以外的值绝对定位元素：position (absolute、fixed)display 为 inline-block、table-cells、flexoverflow 除了 visible 以外的值 (hidden、auto、scroll)解决的问题： 同一 BCF 下外边距 margin 重叠问题，不同 BFC 容器则不会重叠 用 BCF 容器清除浮动，包裹浮动的元素。(借助 overflow 触发) 阻止被浮动覆盖。(借助 overflow 触发) 用 bcf 实现两栏布局。(借助 overflow 触发)","pubDate":"Wed, 22 Jul 2020 07:22:47 GMT","guid":"https://wangyx233.github.io/2020/07/22/[CSS]flex/","category":"flex"},{"title":"<问题汇总>","link":"https://wangyx233.github.io/2020/07/22/[问题汇总]/","description":"1. cdn 是什么，干什么，哪些地方实现了加速2. 前端缓存策略，强缓存、协商缓存的优先级","pubDate":"Wed, 22 Jul 2020 07:04:52 GMT","guid":"https://wangyx233.github.io/2020/07/22/[问题汇总]/","category":"JavaScript"},{"title":"<知识点回顾>JS基础","link":"https://wangyx233.github.io/2020/07/17/[知识点回顾]/","description":"DOM 事件DOM 0 级， element.onClick = () =&gt; {};DOM 2 级，element.addEventListener(name, function(){}, capture = false) 冒泡事件事件模型分为捕获和冒泡，捕获是从 window 自上而下到目标元素，冒泡阶段是从目标元素自下而上向 window 传播。事件委托 delegation，事件冒泡到父元素，所以子元素的事件可以委托到父元素统一处理多个子元素的事件。优点是，不需要为每个子元素绑定事件，减少不必要的开销，提高性能等。且可动态处理事件。阻止默认事件，event.preventDefault()阻止冒泡，event.stopPropagationevent.target 事件触发的event.currentTarget 事件监听的元素自定义事件 12345var event = new Event(name) // 无法传达参数var event = new CustomEvent(name, params)elem.addEventListener(name, function()&#123;&#125;, false) // 监听事件elem.dispatchEvent(event) // 分发触发事件，而非浏览器触发的 观察者模式：事件手写发布-订阅模式 EventEmitter","pubDate":"Fri, 17 Jul 2020 02:59:42 GMT","guid":"https://wangyx233.github.io/2020/07/17/[知识点回顾]/","category":"JavaScript"},{"title":"<重温JS>闭包，作用域","link":"https://wangyx233.github.io/2020/07/02/[重温JS]闭包/","description":"执行上下文闭包是带执行环境的函数，本质是个函数立即执行函数表达式 IIFE，括号前要加;分隔;(function(){})(); 不然会被解析成上一行的函数调用；或者用 void function() {}() var let： for, if, switch, try/catch/finally…{}包裹的 Realm： 9.0 标准提出的，主要应用于通过 iframe 等方式创造 window 环境 函数 普通函数，用 function 定义的普通函数 function fun() {} 箭头函数，const fun = () =&gt; { } 在 class 中定义的函数，class a { fun() {} } 生成器函数，function * fun (){} 用 class 定义的类，实际也是函数 class Foo {constructor (){}} 异步函数，async function fun() {}，const fun = async ()=&gt; {}， async function fun*() {} this同一个函数调用方式不同，this 也不同，普通函数的 this 由调用函数时使用的引用决定。箭头函数不论什么引用调用都不会影响它原来的 this，即外层函数调用的 this。生成器函数、异步生成器函数和异步普通函数跟普通函数行为是一致的，异步箭头函数与箭头函数行为是一致的。 12345678910111213141516171819202122232425262728293031323334function showThis()&#123; console.log(this);&#125;var o = &#123; showThis: showThis&#125;showThis(); // globalo.showThis(); // oconst showThis = () =&gt; &#123; console.log(this);&#125;var o = &#123; showThis: showThis&#125;showThis(); // globalo.showThis(); // globalclass C &#123; showThis() &#123; console.log(this); &#125;&#125;var o = new C();var showThis = o.showThis;showThis(); // undefinedo.showThis(); // o 切换上下文：函数保存定义时上下文的私有变量[[Environment]],当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的[[Environment]] apply，call，bind 操作 this123456789101112131415161718192021var number = 5;var obj = &#123; number: 3, fn: (function () &#123; var number; this.number *= 2; number = number * 2; number = 3; return function () &#123; var num = this.number; this.number *= 2; console.log(num); number *= 3; console.log(number); &#125; &#125;)()&#125;var myFun = obj.fn;myFun.call(null);obj.fn();console.log(window.number);","pubDate":"Thu, 02 Jul 2020 08:39:03 GMT","guid":"https://wangyx233.github.io/2020/07/02/[重温JS]闭包/","category":"closure"},{"title":"<重温JS>JS中的异步","link":"https://wangyx233.github.io/2020/07/01/[重温JS]JS中的异步/","description":"一个 JavaScript 引擎会常驻内存中，自己发起的任务是微观任务，宿主环境分配的是宏观任务。宏观任务 vs 微观任务，setTimeout 是宏观任务，ES5 之后 加入了 Promise 是 JS 引擎生成的微观任务。w事件循环-&gt;宏观任务的队列，在每个宏观任务里有微观事件的队列。因此一个宏观任务中的微观任务执行后，再进行下一个宏观任务 Promise是 JS 提供的一种标准化的异步处理方式，需要进行 io，等待或者其他操作的函数，不返回真实结果，而返回一个 Promise，在合适的时候再调用函数，等待这个 Promise 的实现 1234new Promise((resolve,reject) =&gt; &#123; resolve(); reject();&#125;) 执行顺序是查看有多少个宏观任务，每个宏观任务中有多少个微观任务，根据调用次数确定宏观任务中的微观任务，然后根据宏观任务的触发规则和调用次序再依次执行 12345678function sleep(duration) &#123; return new Promise(function(resolve, reject) &#123; console.log(&quot;b&quot;); setTimeout(resolve,duration); &#125;) &#125; console.log(&quot;a&quot;); sleep(5000).then(()=&gt;console.log(&quot;c&quot;)); async/awaitES2016 新加入的特性。async 函数必定返回 Promise，异步函数，用 await 来等待一个 Promise 我们现在要实现一个红绿灯，把一个圆形 div 按照绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色 12","pubDate":"Wed, 01 Jul 2020 09:38:25 GMT","guid":"https://wangyx233.github.io/2020/07/01/[重温JS]JS中的异步/","category":"Promise,setTimeout"},{"title":"<算法基础>动态规划","link":"https://wangyx233.github.io/2020/06/01/[算法基础]动态规划/","description":"适用情况 计数：how many xxx? 多少种方法可以 blabla 求最大最小值：max，min… 求存在性：博弈，是否能 blabla，先手能不能赢，存不存在策略。 方法 确定状态。属于定海神针，相当于未知量，类似于 x,y,z。需要开一个数组 最后一步，最后一个。比如：一共有 k 个硬币，不关心 k-1 前的状态。只要保证 k-1 是最少的达到目标的 子问题。问题一样，规模变小 递归的问题，会存在大量的重复计算，效率低下。所以如何优化呢？最容易想到的是加缓存，存一下中间计算值 转移方程。问题解决了一半 初始条件，边界情况：注意边界情况处理数组不要越界，初始条件是一开始就能定下来的比如 f[0]一般是最小的，关键是用转移方程算不出来的，手动定义值。 计算顺序。一般情况是从小到大。从上到下，从左到右。原则是，算等式左边的时候，等式右边已经能算出来，用到的状态已经算到了 消除冗余，加速计算。递归的另一种优化方式。 加法原理 无重复 无遗漏 coin change 最值unique path 计数jump game 存在性常见的动态规划的类型 坐标 序列 划分 区间 背包 最长序列，最长上升子序列 博弈 综合 打印路径 了解博弈巴什博奕 Bash gameA,B 玩报数的游戏，若先报到 30 的那个人会赢，每人每次最多报 2(max) 个数，最少报 1 个数，如何保持自己的不败之地。 从简单的来思考，若报到 max + 1 即 3，则后面报数的一定会赢。就先看有多少个这个循环 30 / max + 1，若能整除则后者赢，若有余数则前者先报余数个数则必赢。每次都保证两人报的数是 1+max 个就是一个完整的循环。这是基于两人都是特别聪明的前提。1+max 的倍数","pubDate":"Mon, 01 Jun 2020 06:55:32 GMT","guid":"https://wangyx233.github.io/2020/06/01/[算法基础]动态规划/","category":""},{"title":"时间&空间复杂度","link":"https://wangyx233.github.io/2020/05/12/[算法基础]时间&空间复杂度/","description":"时间复杂度用 Big O 表示，用来表示程度运行时间维度上的趋势。所以 O 表示忽略掉不重要的部分，留下的关键关系。常见的时间复杂度有： 常数 O(1) 对数 O(logn) 线性 O(n) n 的次方 O(n^2…) 指数 O(k^n) 阶乘 O(n!)一般通过看随着 n 的改变，代码要运行多少次。n 比较小的话，其实时间复杂度都差不多，关注时间复杂度的情况一般对数据量较大时，程序的效率问题。 123456// 比如：普通递归计算斐波那契，理解递归总共执行了多少次，善用缓存，避免重复计算。或者循环const fib = (n) =&gt; &#123; if (n &lt; 2) return n; return fib(n - 1) + fib(n - 2);&#125;// O(2^k) 主定理用于进行递归程序的时间复杂度计算，一般常见的算法有： 二分查找 O(logn) 二叉树遍历 O(n) 有序二维数据查找 O(n) 归并排序 O(nlogn) 二叉树的前中后序遍历，图遍历，搜索算法 DFS,BFS，时间复杂度都是 O(n)，因为有且只经过了每个节点一次，所以是和节点数成线性相关的。 空间复杂度如果是数组，那就是数组的长度，O(n)。二维数组，O(n^2)。如果是递归的，那就是递归的深度，如果递归里面又开了数组，则是两者的最大值。","pubDate":"Tue, 12 May 2020 14:14:17 GMT","guid":"https://wangyx233.github.io/2020/05/12/[算法基础]时间&空间复杂度/","category":"Algorithm"},{"title":"<CSS>回顾伪类与伪元素","link":"https://wangyx233.github.io/2020/05/11/[CSS]回顾伪类与伪元素/","description":"在重温 CSS 选择的时候，看到伪类与伪元素有一瞬间迷惑之情，所以这次重新加深一番印象。 伪类(pseudo-classes)？伪元素(pseudo-elements)？为什么要引入伪类，伪元素？为了格式化文档树以外的信息。 伪类：用于描述已经存在的元素的某个状态，添加对应的样式。用:,如：hover,:first-child… 伪元素：用于创建一些不在文档树中的元素。多用::,如：::before,::after…，虽然用户可以看到这些内容，但事实上并不存在在文档树中。 补充：CSS 的选择器 元素选择器 * 通配符选择器 div,p,span… 元素选择器 #id .class 属性选择器 [attr] [attr=val] [attr^=val] 以 val 开头属性值的元素 [attr$=val] 以 val 结尾 [attr*=val] 属性值包含这个 val 属性值的元素 [attr~=val] 属性值为 val，或其中一个值为 val 的元素 [attr|=val] 属性值为 val，或者 val-xxx 的元素 i 不区分大小写，s 区分大小写eg. https://codepen.io/yx233/pen/abvGgad 关系选择器 后代选择器： 空格，所有后代 子选择器：&gt; 直接后代，不包括隔代元素 兄弟选择器：~ 所有兄弟结点 相邻选择气：+ 相邻兄弟结点 选择指向越准确，优先级越高。尽量减少 CSS 选择器的层数","pubDate":"Mon, 11 May 2020 06:35:48 GMT","guid":"https://wangyx233.github.io/2020/05/11/[CSS]回顾伪类与伪元素/","category":"CSS"},{"title":"<重温JS>正则从开始到结束","link":"https://wangyx233.github.io/2020/05/08/[重温JS]正则从开始到结束/","description":"正则表达式用的元字符： 1() [] &#123;&#125; | \\ ^ $ . * + ? 通过 new RegExp() 前一个要转换成字符串，不能直接用正则字面量。如元字符要进行双重转义。正则表达式的 valueOf(),返回正则表达式本身。 regexp.test(text)regexp.exec(text)","pubDate":"Fri, 08 May 2020 09:06:15 GMT","guid":"https://wangyx233.github.io/2020/05/08/[重温JS]正则从开始到结束/","category":"RegExp"},{"title":"<重温JS>时间处理二三事","link":"https://wangyx233.github.io/2020/05/08/[重温JS]时间处理二三事/","description":"const current = new Date();Date.parse(current); //turn to UTC,msDate.UTC(year, month - 1 )Date.now() // s+new Date(); .toString(),字符串；.valueOf(),数值 ms","pubDate":"Fri, 08 May 2020 08:48:01 GMT","guid":"https://wangyx233.github.io/2020/05/08/[重温JS]时间处理二三事/","category":"moment.js,Date"},{"title":"<安全>从基本安全概念到HTTPS发生了什么","link":"https://wangyx233.github.io/2020/05/08/[安全]从基本安全概念到Https/","description":"A 要给 B 发送信息 对称加密加密和解密用的密钥是相同的。 非对称加密公钥加密，私钥解密。传递公钥 中间人攻击数字签名，数字证书私钥加密，公钥解密。传递公钥数字中心 HTTPS先认证服务端，然后服务端再传递加密内容。再进行秘文交换。","pubDate":"Fri, 08 May 2020 08:23:25 GMT","guid":"https://wangyx233.github.io/2020/05/08/[安全]从基本安全概念到Https/","category":"HTTPS,对称加密,非对称加密,数字签名"},{"title":"<Algorithm>查找","link":"https://wangyx233.github.io/2020/04/27/[算法基础]查找/","description":"二分查找特点：有序列表的查找，时间复杂度 O(logN) 1234const binary_search = (list, x) =&gt; &#123; const mid = Math.ceil(list.length / 2);&#125; 回忆一下指数，对数是什么，对数是指数的逆运算，求幂的次数","pubDate":"Mon, 27 Apr 2020 08:56:53 GMT","guid":"https://wangyx233.github.io/2020/04/27/[算法基础]查找/","category":"Algorithm,search"},{"title":"<了解>浏览器是如何工作的？","link":"https://wangyx233.github.io/2020/04/27/[浏览器]浏览器是如何工作的？/","description":"在浏览器地址栏输入 URL 发生了什么？ 如果是域名，先进行 DNS 解析，根据 IP 地址去服务端请求页面； 拿到服务端返回的 HTML，解析构建成 DOM 树； 计算 DOM🌲 上的 CSS 属性； 根据 CSS 渲染每个元素，在内存中保存为位图； 进行渲染合成绘制。 整个过程是流式过程，网页是逐渐加载出来的。 HTTP 协议HTTP 协议是基于 TCP 协议的，TCP 协议是一个双向协议，而 HTTP 协议是在此基础上规定了 Requst-Response 模式，并且用来传输文本。可以理解为用 TCP 规定了一种用来传输文本的应用层协议。","pubDate":"Mon, 27 Apr 2020 08:07:25 GMT","guid":"https://wangyx233.github.io/2020/04/27/[浏览器]浏览器是如何工作的？/","category":"JavaScript"},{"title":"<JS Review>垃圾收集","link":"https://wangyx233.github.io/2020/04/24/[重温JS]垃圾收集/","description":"JS 中实现了自动垃圾回收机制，自动分配内存和释放内存。原理是：找到那些不再使用的变量，然后释放它所占的内存。然后按照固定的时间间隔执行。垃圾收集器需要跟踪变量有没有用，对没有用的变量打上标记，以便后续的回收。标识变量的策略常用的有，标记清除，引用计数。 标记清除 Mark and Sweep进入环境标记。或者维护一个进入环境的列表，一个离开环境的列表。把环境中用到的或者被其他环境内引用的变量标记去掉，剩下还有标记的都是需要删除的变量。 引用计数 Reference Count。可能会导致内存一直得不到释放，比如在函数内，两个对象相互调用 解除引用 Dereferencing,一旦不再使用，最好将他们的值置位 null。主要是全局变量，全局对象等。因为局部变量都会在离开执行环境后，直接解除引用。解除引用，是让这个值脱离执行环境，而不是立即内存回收。","pubDate":"Fri, 24 Apr 2020 08:21:39 GMT","guid":"https://wangyx233.github.io/2020/04/24/[重温JS]垃圾收集/","category":"JavaScript"},{"title":"<JS Review>类型检测","link":"https://wangyx233.github.io/2020/04/22/[重温JS]类型判断/","description":"来自 null 的拷问？我是谁，我在哪儿 [Symbol.toStringTag] 基本数据类型在内存中占用固定大小的内存空间，因此被保存在栈内存中。引用类型，保存在堆内存中。 typeoftypeof 是检测基本数据类型的利器，number，string，boolean，undefined。null，object 都只会返回 object；function 返回 function instanceofvariable instanceof constructor 判断是什么类型的对象，结果返回 true or false。基础类型判断返回 false","pubDate":"Wed, 22 Apr 2020 07:27:30 GMT","guid":"https://wangyx233.github.io/2020/04/22/[重温JS]类型判断/","category":"JavaScript,typeof,instanceof,Object.prototype.toString.call()"},{"title":"<Algorithm>树","link":"https://wangyx233.github.io/2020/04/20/[算法基础]树/","description":"基础概念何为树？ 想象一下自然界的 🌲 形态，用术语表达即为：没有闭环的无向图。几个特征可以描述为：每个节点之间有且只有一条路径相连通；如果增加一条路径，图就会连通起来；所以边的数量为节点数-1。节点和路径可以理解为 🌲 的叉。所以二叉树，就是每个节点最多有两条边，即最多有左右两个节点的树。满二叉树即为每个节点如果有子节点那左右节点都具备。如果有这个树有 n 层，那总节点数为 2 の n 次方 - 1，第 n 层的节点数为 2(n -1)。完全二叉树，则是除了最后一层其他层的节点都填满，并且如果最后一层叶子节点如果是右节点，那这个叶子节点的左边必有节点。二叉树的遍历方式：遍历的顺序为根节点在遍历中的顺序。 前序遍历：根-左-右 中序遍历：左-根-右 后序遍历：左-右-根 优先队列-堆理论说明：根节点和子节点之间的关系，以及结点数量。 如何建堆，最大堆，最小堆。 数据插入 应用场景，堆排序，第 K 大的数 时间复杂度","pubDate":"Mon, 20 Apr 2020 06:05:28 GMT","guid":"https://wangyx233.github.io/2020/04/20/[算法基础]树/","category":"Algorithm,tree,Binary tree"},{"title":"Hover&Focus Effects 简单动画示例","link":"https://wangyx233.github.io/2020/04/16/[CSS]Input Bottom Animation/","description":"登录页进行账号输入时，为了让焦点聚集在当前输入框上可能会需要配合一些动画效果，或者是某个内容的重点提醒也会在 hover 时增加醒目动画。这些设计虽然很古老，也有用到的场合。主要是借助 CSS3 的 transition 来做效果变换，示例如下：https://codepen.io/yx233/pen/YzywdJQ 普通元素 hover effects 简单的 border-color 变换。 借助伪元素实现从左-&gt;右，或从中间向两边延伸的效果。 input 的 focus::after ::before 是指元素文档树内渲染前、后的内容，input 不支持。所以需要借助额外的兄弟元素进行效果实现。 注：[:focus-within]是当一个元素或者元素的后代有[:focus]伪类时生效的一个选择器。对输入框获得焦点时，其前后左右的小图标，下滑动画等变换都有非常实用的效果。 注意：登录框前有时会配合放一些小图标，如果用把 icon 当做 input 的 background-image，同时通过定位的方式定位，需要格外注意 Chrome 记住密码情况下的展示。 123456789101112131415input[name=&apos;user&apos;] &#123; background-image: url(/login/user.svg); background-position: 12px; background-repeat: no-repeat;&#125;// 注意input:-webkit-autofill,input:-webkit-autofill:hover,input:-webkit-autofill:focus,input:-webkit-autofill:active &#123; -webkit-transition: color 9999s linear, background-color 9999s linear; -webkit-transition-delay: 9999s; background-color: XXX; color: XXX;&#125;","pubDate":"Thu, 16 Apr 2020 03:36:09 GMT","guid":"https://wangyx233.github.io/2020/04/16/[CSS]Input Bottom Animation/","category":"css"},{"title":"CSS Secrets","link":"https://wangyx233.github.io/2019/08/29/css_secret/","description":"回顾元素获取 12345function $$(selector, context) &#123; context = context || document; var elements = context.querySelectorAll(selector); return Array.prototype.slice.call(elements);&#125; 11.20 总结： 浏览器新特性总么办，加前缀是个失败的尝试。可以通过工具加前缀。不过新特性的使用任重而道远。web 标准是浏览器相关厂商，以及委员会的人共同探讨维护的。 一、CSS 编写注意技巧： 减少重复的代码，注意 style 之间的依赖关系，如 em，rem，字体和行高等。具体如何计算相互依赖关系，需要根据实际情况。代码量少，和代码容易维护不是一个概念。currentcolorinherit 相信眼睛而不紧紧关注数字。比如 垂直居中看着并不居中，圆形看着小，padding 上下左右不一致。 响应式布局 rwd。一直说响应式布局，但是 media query 不能是最好的解决方法，只能是最后的解决方法。每个媒体查询都会增加成本。每次修改 css 的时候都可能改一遍，复杂性高，经不起折腾。表现的是断点式的表现可以先从减少代码重复来入手。写相对大小 依赖关系。宽度不写具体的 px，用百分比的形式，或者和视口相关的表示如 vh。善用 max-width，min-width。替换元素 img，iframe，vedio 等也要设置 max-width： 100%；推荐弹性布局，或者 inine-block。背景图片要完整地平铺，background-size:cover 合理使用简写。对于可展开的属性。如，border，background，要贯彻减少代码重复的原则，合理使用简写或者展开。 例子： background: url(tr.png) no-repeat top right / 2em 2em, url(br.png) no-repeat bottom right / 2em 2em,url(bl.png) no-repeat bottom left / 2em 2em;其中， / 是为了避免歧义。 是否使用预处理器，如 less，sass 等。建议在项目开始用 css，无法维护时用预处理器。因为要编译就需要时间，文件体积也会变大，还会有自身的 bug，学习成本。如： 原生高级的例子。ul { –accent-color: purple; }ol { –accent-color: rebeccapurple; } li { background: var(–accent-color); } 11.21 总结：背景与边框rgba，hsla 0 红 120 绿 240 蓝 h 色调 s 饱和度 l 亮度 a 透明度","pubDate":"Thu, 29 Aug 2019 03:23:05 GMT","guid":"https://wangyx233.github.io/2019/08/29/css_secret/","category":""},{"title":"原型回顾","link":"https://wangyx233.github.io/2019/08/21/原型回顾/","description":"快来快来看一看 123456789101112131415161718function Foo() &#123; Foo.a = function() &#123; console.log(1) &#125; this.a = function() &#123; console.log(2) &#125;&#125;Foo.prototype.a = function() &#123; console.log(3)&#125;Foo.a = function() &#123; console.log(4)&#125;Foo.a();let obj = new Foo();obj.a();Foo.a();","pubDate":"Wed, 21 Aug 2019 11:43:55 GMT","guid":"https://wangyx233.github.io/2019/08/21/原型回顾/","category":""},{"title":"链表","link":"https://wangyx233.github.io/2019/07/22/链表队列/","description":"what?链表是一种递归的数据结构，它或者为空，或者为一个指向结点的引用。该结点含有一个泛型元素和一个指向另一个链表的引用(next)。其中，结点是一种含有任何类型数据的抽象实体。链表表示的是一列元素。在追踪链表或其他链式结构代码的时候，可用可视化的方式表示： 用长方形表示对象 将实例变量的值写在长方形中 用指向被引用对象的箭头表示引用关系，链接实现任意插入和删除操作的标准解决方案是双向链表，其中每个结点都含有两个链接(pervious, next)，分别指向不同的方向。 特点： 可以处理任意类型的数据 所需的空间和集合的大小成正比 操作的所需要的时间总是和集合的大小无关 补充： 背包(Bag)是一种不支持从中删除元素的集合数据类型，目的就是收集元素并且迭代遍历收集到的元素，迭代的顺序不确定且元素的处理顺序不重要，可以用栈也可以用队列。 1234class Bag() &#123;&#125; add(item) isEmpty() size() 先进先出队列 FIFO 12345class Queue() &#123;&#125; enqueue(item) // 添加一个元素 dequeue() // 删除最近添加的元素 isEmpty() size() 下压栈 LIFO 1234567class Stack() &#123;&#125; push(item) pop() isEmpty() size()例如表达式的求值：遇到左括号忽略，操作数押入操作数的栈里，运算符押入运算符的栈里，遇到右括号运算符栈和操作数栈pop计算得到值，再押入栈中。如：(1 + ((2 + 3) * (4 * 5))) 在一些语言中，数组的长度一经定义就不可改变，并且数组的删除和添加操作需要对元素进行平移会很繁琐。JS 中数组和其他的不同，它是通过对象实现的，操作方便，但是效率可能较其他语言有所不足。 123456function Node(elem) &#123; this.elem = elem; this.next = null; // this.prvious = null;&#125;// 查找，插入，删除结点 跳表 Skip List1989 前后出现的，适用于有序元素的情况。对标的是二分查找和平衡树(二叉搜索树中的平衡树 AVL Tree)。跳表是一种插入，删除，搜索复杂度都是 logn 的数据结构。如：redis，levelDB一维的数据结构要加速，一般可以升维变成二维的数据结构。空间换时间LRU 缓存 自己想个 5-10min 看有没有思路，有思路就写了，没思路就直接看题解，学会了。再自己写呦","pubDate":"Mon, 22 Jul 2019 08:05:17 GMT","guid":"https://wangyx233.github.io/2019/07/22/链表队列/","category":""},{"title":"理解promise","link":"https://wangyx233.github.io/2019/01/16/理解promise/","description":"为什么?避免回调地狱有什么问题呢？代码臃肿，可读性差，耦合性差，容易产生bug，不容易维护。不容易复用。在回调里面处理问题。js特点-&gt;异步，主要是靠回调函数实现的。比如，nodejs的特点是高并发和非阻塞，主要靠异步来实现。js是事件注册机制的。函数的执行是进栈和出栈这样的，所以普通的回调函数，try catch是没有作用的。 是什么？用于异步计算，用于即将发生的事情，或者不会发生的事情。一个Promise的状态有resolved/rejected/pending/settlednew Promise 返回一个promise对象，参数是一个执行函数。执行函数有两个参数，resolve，reject 12345678910new Promise((resolve, reject) =&gt; &#123; // 异步处理 处理结束后执行resolve , reject&#125;).then() //成功失败的回调，注意：then方法是异步执行的.catch() //在最外层捕获异常。promise.catch(onRejected)相当于promise.then(null, onRrejected); promise的三种状态:pending 初始化fulfilled 执行成功，调用resolverejected 失败，调用reject注意promsie状态 只能由 pending =&gt; fulfilled/rejected, 一旦修改就不能再变","pubDate":"Tue, 15 Jan 2019 16:41:34 GMT","guid":"https://wangyx233.github.io/2019/01/16/理解promise/","category":""}]}