{"title":"Hexo","description":null,"language":null,"link":"https://wangyx233.github.io","pubDate":"Mon, 11 May 2020 06:35:48 GMT","lastBuildDate":"Mon, 11 May 2020 15:12:43 GMT","generator":"hexo-generator-json-feed","webMaster":"Xuan","items":[{"title":"<CSS>回顾伪类与伪元素","link":"https://wangyx233.github.io/2020/05/11/[CSS]回顾伪类与伪元素/","description":"在重温 CSS 选择的时候，看到伪类与伪元素有一瞬间迷惑之情，所以这次重新加深一番印象。 伪类(pseudo-classes)？伪元素(pseudo-elements)？为什么要引入伪类，伪元素？为了格式化文档树以外的信息。 伪类：用于描述已经存在的元素的某个状态，添加对应的样式。用:,如：hover,:first-child… 伪元素：用于创建一些不在文档树中的元素。多用::,如：::before,::after…，虽然用户可以看到这些内容，但事实上并不存在在文档树中。 补充：CSS 的选择器 元素选择器 * 通配符选择器 div,p,span… 元素选择器 #id .class 属性选择器 [attr] [attr=val] [attr^=val] 以 val 开头属性值的元素 [attr$=val] 以 val 结尾 [attr*=val] 属性值包含这个 val 属性值的元素 [attr~=val] 属性值为 val，或其中一个值为 val 的元素 [attr|=val] 属性值为 val，或者 val-xxx 的元素 i 不区分大小写，s 区分大小写eg. https://codepen.io/yx233/pen/abvGgad 关系选择器 后代选择器： 空格，所有后代 子选择器：&gt; 直接后代，不包括隔代元素 兄弟选择器：~ 所有兄弟结点 相邻选择气：+ 相邻兄弟结点 选择指向越准确，优先级越高。尽量减少 CSS 选择器的层数","pubDate":"Mon, 11 May 2020 06:35:48 GMT","guid":"https://wangyx233.github.io/2020/05/11/[CSS]回顾伪类与伪元素/","category":"CSS"},{"title":"<重温JS>正则从开始到结束","link":"https://wangyx233.github.io/2020/05/08/[重温JS]正则从开始到结束/","description":"正则表达式用的元字符： 1() [] &#123;&#125; | \\ ^ $ . * + ? 通过 new RegExp() 前一个要转换成字符串，不能直接用正则字面量。如元字符要进行双重转义。正则表达式的 valueOf(),返回正则表达式本身。 regexp.test(text)regexp.exec(text)","pubDate":"Fri, 08 May 2020 09:06:15 GMT","guid":"https://wangyx233.github.io/2020/05/08/[重温JS]正则从开始到结束/","category":"RegExp"},{"title":"<重温JS>时间处理二三事","link":"https://wangyx233.github.io/2020/05/08/[重温JS]时间处理二三事/","description":"const current = new Date();Date.parse(current); //turn to UTC,msDate.UTC(year, month - 1 )Date.now() // s+new Date(); .toString(),字符串；.valueOf(),数值 ms","pubDate":"Fri, 08 May 2020 08:48:01 GMT","guid":"https://wangyx233.github.io/2020/05/08/[重温JS]时间处理二三事/","category":"moment.js,Date"},{"title":"<安全>从基本安全概念到HTTPS发生了什么","link":"https://wangyx233.github.io/2020/05/08/[安全]从基本安全概念到Https/","description":"A 要给 B 发送信息 对称加密加密和解密用的密钥是相同的。 非对称加密公钥加密，私钥解密。传递公钥 中间人攻击数字签名，数字证书私钥加密，公钥解密。传递公钥数字中心 HTTPS先认证服务端，然后服务端再传递加密内容。再进行秘文交换。","pubDate":"Fri, 08 May 2020 08:23:25 GMT","guid":"https://wangyx233.github.io/2020/05/08/[安全]从基本安全概念到Https/","category":"HTTPS,对称加密,非对称加密,数字签名"},{"title":"<Algorithm>查找","link":"https://wangyx233.github.io/2020/04/27/[算法基础]查找/","description":"二分查找特点：有序列表的查找，时间复杂度 O(logN) 1234const binary_search = (list, x) =&gt; &#123; const mid = Math.ceil(list.length / 2);&#125; 回忆一下指数，对数是什么，对数是指数的逆运算，求幂的次数","pubDate":"Mon, 27 Apr 2020 08:56:53 GMT","guid":"https://wangyx233.github.io/2020/04/27/[算法基础]查找/","category":"Algorithm,search"},{"title":"<了解>浏览器是如何工作的？","link":"https://wangyx233.github.io/2020/04/27/[浏览器]浏览器是如何工作的？/","description":"在浏览器地址栏输入 URL 发生了什么？ 如果是域名，先进行 DNS 解析，根据 IP 地址去服务端请求页面； 拿到服务端返回的 HTML，解析构建成 DOM 树； 计算 DOM🌲 上的 CSS 属性； 根据 CSS 渲染每个元素，在内存中保存为位图； 进行渲染合成绘制。 整个过程是流式过程，网页是逐渐加载出来的。 HTTP 协议HTTP 协议是基于 TCP 协议的，TCP 协议是一个双向协议，而 HTTP 协议是在此基础上规定了 Requst-Response 模式，并且用来传输文本。可以理解为用 TCP 规定了一种用来传输文本的应用层协议。","pubDate":"Mon, 27 Apr 2020 08:07:25 GMT","guid":"https://wangyx233.github.io/2020/04/27/[浏览器]浏览器是如何工作的？/","category":"JavaScript"},{"title":"<JS Review>垃圾收集","link":"https://wangyx233.github.io/2020/04/24/[重温JS]垃圾收集/","description":"JS 中实现了自动垃圾回收机制，自动分配内存和释放内存。原理是：找到那些不再使用的变量，然后释放它所占的内存。然后按照固定的时间间隔执行。垃圾收集器需要跟踪变量有没有用，对没有用的变量打上标记，以便后续的回收。标识变量的策略常用的有，标记清除，引用计数。 标记清除 Mark and Sweep进入环境标记。或者维护一个进入环境的列表，一个离开环境的列表。把环境中用到的或者被其他环境内引用的变量标记去掉，剩下还有标记的都是需要删除的变量。 引用计数 Reference Count。可能会导致内存一直得不到释放，比如在函数内，两个对象相互调用 解除引用 Dereferencing,一旦不再使用，最好将他们的值置位 null。主要是全局变量，全局对象等。因为局部变量都会在离开执行环境后，直接解除引用。解除引用，是让这个值脱离执行环境，而不是立即内存回收。","pubDate":"Fri, 24 Apr 2020 08:21:39 GMT","guid":"https://wangyx233.github.io/2020/04/24/[重温JS]垃圾收集/","category":"JavaScript"},{"title":"<JS Review>类型检测","link":"https://wangyx233.github.io/2020/04/22/[重温JS]类型判断/","description":"来自 null 的拷问？我是谁，我在哪儿 [Symbol.toStringTag] 基本数据类型在内存中占用固定大小的内存空间，因此被保存在栈内存中。引用类型，保存在堆内存中。 typeoftypeof 是检测基本数据类型的利器，number，string，boolean，undefined。null，object 都只会返回 object；function 返回 function instanceofvariable instanceof constructor 判断是什么类型的对象，结果返回 true or false。基础类型判断返回 false","pubDate":"Wed, 22 Apr 2020 07:27:30 GMT","guid":"https://wangyx233.github.io/2020/04/22/[重温JS]类型判断/","category":"JavaScript,typeof,instanceof,Object.prototype.toString.call()"},{"title":"<Algorithm>树","link":"https://wangyx233.github.io/2020/04/20/[算法基础]树/","description":"基础概念何为树？ 想象一下自然界的 🌲 形态，用术语表达即为：没有闭环的无向图。几个特征可以描述为：每个节点之间有且只有一条路径相连通；如果增加一条路径，图就会连通起来；所以边的数量为节点数-1。节点和路径可以理解为 🌲 的叉。所以二叉树，就是每个节点最多有两条边，即最多有左右两个节点的树。满二叉树即为每个节点如果有子节点那左右节点都具备。如果有这个树有 n 层，那总节点数为 2 の n 次方 - 1，第 n 层的节点数为 2(n -1)。完全二叉树，则是除了最后一层其他层的节点都填满，并且如果最后一层叶子节点如果是右节点，那这个叶子节点的左边必有节点。二叉树的遍历方式：遍历的顺序为根节点在遍历中的顺序。 前序遍历：根-左-右 中序遍历：左-根-右 后序遍历：左-右-根 优先队列-堆理论说明：根节点和子节点之间的关系，以及结点数量。 如何建堆，最大堆，最小堆。 数据插入 应用场景，堆排序，第 K 大的数 时间复杂度","pubDate":"Mon, 20 Apr 2020 06:05:28 GMT","guid":"https://wangyx233.github.io/2020/04/20/[算法基础]树/","category":"Algorithm,tree,Binary tree"},{"title":"<JS Review>对象","link":"https://wangyx233.github.io/2020/04/20/[重温JS]对象/","description":"对象是什么？ 具有唯一标识，内存地址。 具有状态，属性。 具有行为，方法。 JS 的对象具有高度的动态性，可以在运行时对对象添加状态，修改行为。JS 中 Object 的定义，用 new 构造函数()、对象字面量 对象的属性类型JS 中，属性和方法其实都可以成为对象的属性。属性并不是简单的名称和值，可以用一组特征来描述属性，可分为数据属性和访问器(getter/setter)属性两类。 数据属性。这个就是常见的对象属性，具有以下特征： value writable：能否被赋值 enumerable：被 for in 枚举 configurable：被删除，或者改变特征值。false 时，writable 可从 true-&gt;false，但无法反向修改。enumerable 则不能修改，会报 TypeError: cannot redefine property。一旦设置为 false，cannot set true 访问器(getter/setter)属性。属性在读写的时候执行。 getter：get: () =&gt; {} || undifined setter: set: () =&gt; {} || undifined，两者成对出现，若不设置则为 undefined enumerable：被 for in 枚举 configurable：被删除，或者改变特征值ES5 以后：查看属性可用，Object.getOwnPropertyDescripter(object, ‘key’)设置属性的特性可用，Object.defineProperty(object, ‘key’, {})如果通过赋值的方式为属性赋值，则该属性的特征都默认为 true。但如果通过 defineProperty 赋值而不指定特性，则特征都默认为 false 123456789var o = &#123;a:1&#125;;o.b = 2;Object.getOwnPropertyDescripter(o, &apos;b&apos;);Object.defineProperty(o, &apos;c&apos;, &#123;value: 3&#125;);Object.getOwnPropertyDescripter(o, &apos;c&apos;);var o = &#123; get a() &#123; return &apos;a&apos; &#125; &#125;;Object.defineProperty(o, &apos;b&apos;, &#123;get: () =&gt; 2, set: (b) =&gt; console.log(b), configurable:true&#125;) 原型","pubDate":"Mon, 20 Apr 2020 06:04:50 GMT","guid":"https://wangyx233.github.io/2020/04/20/[重温JS]对象/","category":"JavaScript,Object,prototype"},{"title":"Hover&Focus Effects 简单动画示例","link":"https://wangyx233.github.io/2020/04/16/[CSS]Input Bottom Animation/","description":"登录页进行账号输入时，为了让焦点聚集在当前输入框上可能会需要配合一些动画效果，或者是某个内容的重点提醒也会在 hover 时增加醒目动画。这些设计虽然很古老，也有用到的场合。主要是借助 CSS3 的 transition 来做效果变换，示例如下：https://codepen.io/yx233/pen/YzywdJQ 普通元素 hover effects 简单的 border-color 变换。 借助伪元素实现从左-&gt;右，或从中间向两边延伸的效果。 input 的 focus::after ::before 是指元素文档树内渲染前、后的内容，input 不支持。所以需要借助额外的兄弟元素进行效果实现。 注：[:focus-within]是当一个元素或者元素的后代有[:focus]伪类时生效的一个选择器。对输入框获得焦点时，其前后左右的小图标，下滑动画等变换都有非常实用的效果。 注意：登录框前有时会配合放一些小图标，如果用把 icon 当做 input 的 background-image，同时通过定位的方式定位，需要格外注意 Chrome 记住密码情况下的展示。 123456789101112131415input[name=&apos;user&apos;] &#123; background-image: url(/login/user.svg); background-position: 12px; background-repeat: no-repeat;&#125;// 注意input:-webkit-autofill,input:-webkit-autofill:hover,input:-webkit-autofill:focus,input:-webkit-autofill:active &#123; -webkit-transition: color 9999s linear, background-color 9999s linear; -webkit-transition-delay: 9999s; background-color: XXX; color: XXX;&#125;","pubDate":"Thu, 16 Apr 2020 03:36:09 GMT","guid":"https://wangyx233.github.io/2020/04/16/[CSS]Input Bottom Animation/","category":"css"},{"title":"重温","link":"https://wangyx233.github.io/2020/03/12/重温学习/","description":"7 种语言类型undefined 是一个变量，而并非是一个关键字。老的浏览器中会是，ES5 以后就不是了。函数内部，对象的属性现在也是可以赋值的。if(typeof str === ‘undefined’){// 如果直接用 str === undefined, str 未声明的话可能会报错 not defined}String 用于表示文本数据。String 有最大长度是 2^53 - 1，字符串的 UTF16 编码，charAt、charCodeAt、length 等方法针对的都是 UTF16 编码Number 2^64-2^53+3NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字；Infinity，无穷大；-Infinity，负无穷大。还有 +0 -0，1/x 是 Infinity 还是 -InfinityMath.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON Symbol 可以用于迭代器，Symbol.iterator 需要有 next 和 done，next 返回一个对象包括 value 和 done 12345678910111213var o = new Objecto[Symbol.iterator] = function() &#123; var v = 0 return &#123; next: function() &#123; return &#123; value: v++, done: v &gt; 10 &#125; &#125; &#125;&#125;;for(var v of o) console.log(v); // 0 1 2 3 ... 9 Object.prototype.toString.call() 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。装箱，是指讲基本数据类型转化为对象。拆箱是把对象转换成基本数据类型。valueOf()，toString(),或者用 Symbol.toPrimitive 自定义转换覆盖以前的。众所周知的 Symbol 数组的 toString(),会返回一个字符串的拼接；valueOf 还是返回数组。 通过 new Number()声明的类型和直接用 Number()声明的类型不同，object 与 number 的区别。toString()还可以传入进制进行计算。valueOf 返回数字 toFixed(), toPrecision(num)向上取整, toExponential()科学计数法 String,chartAt(index),chartCodeAt(index)","pubDate":"Thu, 12 Mar 2020 07:52:56 GMT","guid":"https://wangyx233.github.io/2020/03/12/重温学习/","category":""},{"title":"CSS Secrets","link":"https://wangyx233.github.io/2019/08/29/css_secret/","description":"回顾元素获取 12345function $$(selector, context) &#123; context = context || document; var elements = context.querySelectorAll(selector); return Array.prototype.slice.call(elements);&#125; 11.20 总结： 浏览器新特性总么办，加前缀是个失败的尝试。可以通过工具加前缀。不过新特性的使用任重而道远。web 标准是浏览器相关厂商，以及委员会的人共同探讨维护的。 一、CSS 编写注意技巧： 减少重复的代码，注意 style 之间的依赖关系，如 em，rem，字体和行高等。具体如何计算相互依赖关系，需要根据实际情况。代码量少，和代码容易维护不是一个概念。currentcolorinherit 相信眼睛而不紧紧关注数字。比如 垂直居中看着并不居中，圆形看着小，padding 上下左右不一致。 响应式布局 rwd。一直说响应式布局，但是 media query 不能是最好的解决方法，只能是最后的解决方法。每个媒体查询都会增加成本。每次修改 css 的时候都可能改一遍，复杂性高，经不起折腾。表现的是断点式的表现可以先从减少代码重复来入手。写相对大小 依赖关系。宽度不写具体的 px，用百分比的形式，或者和视口相关的表示如 vh。善用 max-width，min-width。替换元素 img，iframe，vedio 等也要设置 max-width： 100%；推荐弹性布局，或者 inine-block。背景图片要完整地平铺，background-size:cover 合理使用简写。对于可展开的属性。如，border，background，要贯彻减少代码重复的原则，合理使用简写或者展开。 例子： background: url(tr.png) no-repeat top right / 2em 2em, url(br.png) no-repeat bottom right / 2em 2em,url(bl.png) no-repeat bottom left / 2em 2em;其中， / 是为了避免歧义。 是否使用预处理器，如 less，sass 等。建议在项目开始用 css，无法维护时用预处理器。因为要编译就需要时间，文件体积也会变大，还会有自身的 bug，学习成本。如： 原生高级的例子。ul { –accent-color: purple; }ol { –accent-color: rebeccapurple; } li { background: var(–accent-color); } 11.21 总结：背景与边框rgba，hsla 0 红 120 绿 240 蓝 h 色调 s 饱和度 l 亮度 a 透明度","pubDate":"Thu, 29 Aug 2019 03:23:05 GMT","guid":"https://wangyx233.github.io/2019/08/29/css_secret/","category":""},{"title":"原型回顾","link":"https://wangyx233.github.io/2019/08/21/原型回顾/","description":"快来快来看一看 123456789101112131415161718function Foo() &#123; Foo.a = function() &#123; console.log(1) &#125; this.a = function() &#123; console.log(2) &#125;&#125;Foo.prototype.a = function() &#123; console.log(3)&#125;Foo.a = function() &#123; console.log(4)&#125;Foo.a();let obj = new Foo();obj.a();Foo.a();","pubDate":"Wed, 21 Aug 2019 11:43:55 GMT","guid":"https://wangyx233.github.io/2019/08/21/原型回顾/","category":""},{"title":"JS基础回顾","link":"https://wangyx233.github.io/2019/08/13/基础回顾/","description":"内置类型加上ES6新加的Symbol，共7种，分别为 String， Number， Boolean， Object， Undefined， Null。分为基本数据类型(6)和Object。对于基本数据类型，通过字面量的方式声明，类型依旧是字面量，只有在使用的时候才会转换为对应的类型。 12345typeof() 特别： 函数-&gt;function, null-&gt;object。历史原因对象以000开头，而null恰好为全零通过Object.prototype.toString.call()可判断准确的类型[object Type] PS: Symbol类型(唯一的值)通过 Symbol()定义，定义后的值不相等，System.prototype.description 为定义时Symbol(‘xxx’)的标识。使用场景：作为对象的属性 1234567let sym = Symbol();let a = &#123;&#125;;a[sym] = &apos;symbol&apos;;a = &#123; [sym]: &apos;symbol&apos;&#125;Object.defineProperty(a, sym, &#123;value: &apos;symbol&apos;&#125;) 注： 不能用.运算符，.运算符会直接作为字符串取值。 Symbol作为属性名，不会出现在for…in, for…of中，也不会出现在Object.keys(), Object.getOwnPropertyNames()、JSON.stringify()里。 但也不是私有属性，Object.getOwnPropertySymbols，可以获取指定对象的所有 Symbol 属性名。 新的API:Reflect.ownKeys可以返回所有类型的键名，包括常规键名和 Symbol 键名。 Symbol.for(description)若没有则会创建一个，若存在则共用一个symbol值。 Symbol.keyFor(sym)返回一个已登记即Symbol.for的 Symbol类型值的key 其他方法可在需要是再查找。 类型转换转Boolean类型。在条件判断时，除了 undefined， null， false， NaN， ‘’， 0， -0，其他所有值都转为 true，包括所有对象对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。注：‘a’ + + ‘b’ – ‘aNaN’ 1234x==y 比较undefined == null // true[] == true // false[] == ![] // true [].toString() -&gt; &apos;&apos;，!取反运算符的优先级会高于==， ![] -》 false undefined == null，结果是true。且它俩与所有其他值比较的结果都是false。 String == Boolean，需要两个操作数同时转为Number。 String/Boolean == Number，需要String/Boolean转为Number。 Object == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法)。 原型","pubDate":"Tue, 13 Aug 2019 02:10:39 GMT","guid":"https://wangyx233.github.io/2019/08/13/基础回顾/","category":""},{"title":"链表","link":"https://wangyx233.github.io/2019/07/22/链表队列/","description":"what?链表是一种递归的数据结构，它或者为空，或者为一个指向结点的引用。该结点含有一个泛型元素和一个指向另一个链表的引用(next)。其中，结点是一种含有任何类型数据的抽象实体。链表表示的是一列元素。在追踪链表或其他链式结构代码的时候，可用可视化的方式表示： 用长方形表示对象 将实例变量的值写在长方形中 用指向被引用对象的箭头表示引用关系，链接实现任意插入和删除操作的标准解决方案是双向链表，其中每个结点都含有两个链接(pervious, next)，分别指向不同的方向。 特点： 可以处理任意类型的数据 所需的空间和集合的大小成正比 操作的所需要的时间总是和集合的大小无关 补充： 背包(Bag)是一种不支持从中删除元素的集合数据类型，目的就是收集元素并且迭代遍历收集到的元素，迭代的顺序不确定且元素的处理顺序不重要，可以用栈也可以用队列。 1234class Bag() &#123;&#125; add(item) isEmpty() size() 先进先出队列FIFO 12345class Queue() &#123;&#125; enqueue(item) // 添加一个元素 dequeue() // 删除最近添加的元素 isEmpty() size() 下压栈LIFO 1234567class Stack() &#123;&#125; push(item) pop() isEmpty() size()例如表达式的求值：遇到左括号忽略，操作数押入操作数的栈里，运算符押入运算符的栈里，遇到右括号运算符栈和操作数栈pop计算得到值，再押入栈中。如：(1 + ((2 + 3) * (4 * 5))) 在一些语言中，数组的长度一经定义就不可改变，并且数组的删除和添加操作需要对元素进行平移会很繁琐。JS中数组和其他的不同，它是通过对象实现的，操作方便，但是效率可能较其他语言有所不足。 123456function Node(elem) &#123; this.elem = elem; this.next = null; // this.prvious = null;&#125;// 查找，插入，删除结点","pubDate":"Mon, 22 Jul 2019 08:05:17 GMT","guid":"https://wangyx233.github.io/2019/07/22/链表队列/","category":""},{"title":"理解promise","link":"https://wangyx233.github.io/2019/01/16/理解promise/","description":"为什么?避免回调地狱有什么问题呢？代码臃肿，可读性差，耦合性差，容易产生bug，不容易维护。不容易复用。在回调里面处理问题。js特点-&gt;异步，主要是靠回调函数实现的。比如，nodejs的特点是高并发和非阻塞，主要靠异步来实现。js是事件注册机制的。函数的执行是进栈和出栈这样的，所以普通的回调函数，try catch是没有作用的。 是什么？用于异步计算，用于即将发生的事情，或者不会发生的事情。一个Promise的状态有resolved/rejected/pending/settlednew Promise 返回一个promise对象，参数是一个执行函数。执行函数有两个参数，resolve，reject 12345678910new Promise((resolve, reject) =&gt; &#123; // 异步处理 处理结束后执行resolve , reject&#125;).then() //成功失败的回调，注意：then方法是异步执行的.catch() //在最外层捕获异常。promise.catch(onRejected)相当于promise.then(null, onRrejected); promise的三种状态:pending 初始化fulfilled 执行成功，调用resolverejected 失败，调用reject注意promsie状态 只能由 pending =&gt; fulfilled/rejected, 一旦修改就不能再变","pubDate":"Tue, 15 Jan 2019 16:41:34 GMT","guid":"https://wangyx233.github.io/2019/01/16/理解promise/","category":""},{"title":"webpack学习","link":"https://wangyx233.github.io/2018/06/15/webpack学习/","description":"postcss 配置，post.config.js，同时webpack.config.js mini-css-extract-plugin 与style-loader不共存 注意路径和文件名，仔细，认真 ico图片引入，没什么区别？ 可自动设置dist文件夹下的文件，生成文件的目录你来掌握。 注意图片引入的路径,使用file-loader，url-loader引入的图片需要配合require使用，才能打包。url可以指定图片大小转换成base64等。若不用require，直接src，需要把图片copy到打包后的文件。 react-hot-loader 与webpack 自带的hot不相互兼容。只能用一个。 webpack 的publicpath 定义的是服务在哪个文件下启动的，content可以定义文件的目录。 静态文件可生成hash模式，避免缓存。 babel也需要相应的配置。配合babel-import-plugin可以进行ui库的部分引入。还要注意选择babel的stage react route4 webpack 服务器，用BrowserRouter,historyApiFallback: true gulp 与 webpack的区别gulp 是任务流的，和task有关。webpack 的核心是根据模块构建项目。Webpack 的核心就是模块化地组织，模块化地依赖，然后模块化地打包。相对来上，场景局限在前端模块化打包上；虽然用 gulp + 插件的方式也能实现，但目前看 Webpack 在依赖的模块化构建上是无人能够替代的。gulp 版本号。可以在打包的时候，打入不同的文件。","pubDate":"Fri, 15 Jun 2018 08:34:01 GMT","guid":"https://wangyx233.github.io/2018/06/15/webpack学习/","category":""},{"title":"Echarts3.5.0以上世界地图nameMap变更","link":"https://wangyx233.github.io/2017/06/27/Echarts3.5.0以上世界地图nameMap修改/","description":"今天发现使用Echarts，nameMap渲染的世界地图，没有显示美国的数据，美国的区域显示的为United States。经过查找发现，Echarts应该是在3.5.0版本的时候，对world.js的一些国家名称进行了变更，从而导致用官网实例提供的nameMap,无法匹配到国家，进而无法显示。大致看了一下地图，修改后对应的国家信息为： 123456789101112131415var nameMap =&#123; &apos;Central African Rep.&apos;:&apos;中非共和国&apos;, &apos;Dem. Rep. Congo&apos;:&apos;刚果民主共和国&apos;, &apos;Lao PDR&apos;:&apos;老挝&apos;, &apos;W. Sahara&apos;:&apos;西撒哈拉&apos;, &apos;Tanzania&apos;:&apos;坦桑尼亚联合共和国&apos;, &apos;United States&apos;:&apos;美国&apos;, &apos;Korea&apos;: &apos;韩国&apos;, &apos;Dem. Rep. Korea&apos;: &apos;朝鲜&apos;, &apos;Congo&apos;: &apos;刚果共和国&apos;, &apos;Solomon Is.&apos;: &apos;所罗门群岛&apos;, &apos;Dominican Rep.&apos;:&apos;多明尼加共和国&apos;, &apos;S. Sudan&apos;: &apos;南苏丹&apos; , &quot;Côte d&apos;Ivoire&quot;: &apos;科特迪瓦&apos;,&#125;","pubDate":"Tue, 27 Jun 2017 09:23:11 GMT","guid":"https://wangyx233.github.io/2017/06/27/Echarts3.5.0以上世界地图nameMap修改/","category":""},{"title":"一些设计知识~","link":"https://wangyx233.github.io/2017/06/21/写给大家看的设计书/","description":"最近要看的书好多，全都在排排坐，先挑了一本设计类的书籍《写给大家看的设计书》 设计的四大原则对比对比是为页面增加视觉效果的最有效的途径,也是在不同元素之间建立一种有组织的层次结构最有效方法。要记住一个重要规则:要想实现有效的对比,对比就必须 强烈。千万不要畏畏缩缩。字体的对比，颜色的对比，一定要保持强烈，差别不大的对比没有效果。对比的根本目的有两个,这两个目的相辅相成,无法分开。一个目的是增强页面的效果,如果一个页面看起来很有意思,往往更有可读性。另一个目的是有助于信息的组织。读者应当能立即了解信息以何种方式组织,以及从一项到另一项的逻辑流程。对比元素不能让读者混淆,也不能错误地强调重点(即本不该是重点的元素)。 重复-一致性设计的某些方面需要在整个作品中重复。控制读者视线，设计中视觉元素的重复可以将作品中的各部分连在一起,从而统一并增强整个作品。重复的目的就是统一,并增强视觉效果。不要低估页面视觉效果的威力,如果一个作品看起来很有趣,它往往也更易于阅读。要避免太多地重复一个元素,重复太多会让人讨厌。要注意对比的价值可以通过字体选择、线宽、颜色、形状、大小、空间等来增加对比。 增加对比很容易,途径有很多,这可能是增加视觉效果最有意思也最让人满意的方 法了。重要的是:对比一定要强烈!","pubDate":"Wed, 21 Jun 2017 03:37:56 GMT","guid":"https://wangyx233.github.io/2017/06/21/写给大家看的设计书/","category":""},{"title":"D3.js学习","link":"https://wangyx233.github.io/2017/06/21/D3.js学习/","description":"D3.js实现数据和元素的绑定对于DOM结点的选择，d3.select(‘tag’)选择第一个元素,d3.selectAll(‘tag’)选择所有的元素。对于数据的绑定，tag.datum()将一个数据绑定到元素上，tag.data()将数组内元素分别绑定各元素。 1var body = d3.select(&apos;body&apos;);","pubDate":"Wed, 21 Jun 2017 02:47:53 GMT","guid":"https://wangyx233.github.io/2017/06/21/D3.js学习/","category":""},{"title":"Canvas学习","link":"https://wangyx233.github.io/2017/06/12/Canvas学习/","description":"&lt;canvas&gt;标签定义一个矩形框画布，默认没有边框和内容,默认大小为300像素×150像素(wxh)。 1234&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;style=&quot;border:1px solid #000000;&quot;&gt;若浏览器不支持canvas标签，将显示这些文字&lt;/canvas&gt; 在Js文件中绘制Canvas元素。 12345678var c=document.getElementById(&quot;myCanvas&quot;);if(c.getContext(&apos;2d&apos;))&#123; //支持性检查 var ctx=c.getContext(&quot;2d&quot;);//获取渲染上下文，参数为上下文的格式 ctx.fillStyle=&quot;#FF0000&quot;; //填充样式，可为颜色、图案、渐变等。 ctx.fillRect(0,0,150,75);//矩形的填充方法fillRect(x,y,width,height)，矩形左上角坐标为(0,0)&#125;else &#123; // canvas-unsupported code here&#125; 画矩形canvas支持一种原生的图形绘制-矩形 1234fillRect(x, y, width, height) //绘制一个填充的矩形strokeRect(x, y, width, height) //绘制一个矩形的边框clearRect(x, y, width, height) //清除指定矩形区域，让清除部分完全透明rect(x, y, width, height) //绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。","pubDate":"Mon, 12 Jun 2017 05:55:20 GMT","guid":"https://wangyx233.github.io/2017/06/12/Canvas学习/","category":""},{"title":"Three.js学习笔记","link":"https://wangyx233.github.io/2017/06/05/three.js学习指南/","description":"一切都建立在引入Three.js后，得到的全局变量THREE。对于页面中，存放渲染效果的元素，可以是普通的div，也可以是canvas。对于div，渲染时添加节点： 1234var renderer = new THREE.WebGLRenderer();renderer.setSize(400, 300);document.getElementById(&apos;test&apos;).appendChild(renderer.domElement);renderer.setClearColor(0x000000);//清除原本所在页面颜色，并设置 而对于定义的canvas标签，其定义及渲染： 123&lt;canvas id=&quot;mainCanvas&quot; width=&quot;400px&quot; height=&quot;300px&quot; &gt;&lt;/canvas&gt;var renderer = new THREE.WebGLRenderer(&#123; canvas: document.getElementById(&apos;mainCanvas&apos;)&#125;); 基本概念 主要分为三大部分，场景（scene）、照相机（camera）、渲染器（renderer） 首先定义容器渲染所在的DOM包括宽高、颜色等，利用照相机(投影方式)把作为容器的场景渲染到页面上。 声明渲染器对象renderer，canvas对象的获取方法为renderer.domElement，相机也需要加到场景中去","pubDate":"Mon, 05 Jun 2017 05:59:18 GMT","guid":"https://wangyx233.github.io/2017/06/05/three.js学习指南/","category":"Three.js"},{"title":"hexo部署github的问题","link":"https://wangyx233.github.io/2017/04/11/hexo部署github的问题/","description":"用hexo搭建博客，配置直接部署到github的方法：1.安装 hexo-deployer-git插件 1npm install hexo-deployer-git --save 2.在hexo根目录的_config.yml中进行deploy的配置 123456deploy: type: git repo: [github repository url] //eg:git@github.com:xxx.git or https://github.com/xxx.git branch: master //branch name message: &quot;Blog updated: &#123;&#123; now（&apos;YYYY-MM-DD&apos;）&#125;&#125;&quot; //commit messagePs:注意缩进和空格 3.通过hexo deploy（即hexo d）命令进行部署，在此之前需要进行hexo generate（即hexo g）编译。 123hexo-deployer-git插件的作用是生成.deploy_git文件，并且把hexo g编译后的public中的文件复制到.deploy_git文件夹下，然后进行git操作，推到远端github仓库。 注意：","pubDate":"Tue, 11 Apr 2017 12:03:27 GMT","guid":"https://wangyx233.github.io/2017/04/11/hexo部署github的问题/","category":"hexo,github"},{"title":"Hello World","link":"https://wangyx233.github.io/2017/04/11/hello-world/","description":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server","pubDate":"Tue, 11 Apr 2017 06:06:25 GMT","guid":"https://wangyx233.github.io/2017/04/11/hello-world/","category":""}]}