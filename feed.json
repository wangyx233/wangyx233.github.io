{"title":"Hexo","description":null,"language":null,"link":"https://wangyx233.github.io","pubDate":"Tue, 13 Jul 2021 03:21:58 GMT","lastBuildDate":"Tue, 13 Jul 2021 03:22:20 GMT","generator":"hexo-generator-json-feed","webMaster":"Xuan","items":[{"title":"【读书】JavaScript高级程序设计","link":"https://wangyx233.github.io/2021/07/13/[读书]JavaScript高级程序设计/","description":"script标签defer vs async共同点：只对外部脚本有效，src=’xxx’不同： defer表明脚本立即下载，但是执行会推迟，在DOMContentLoaded之前执行。即加载无需等待，HTML5规定执行需要有序的。async表明脚本会并行下载，下载完立即执行，不保证执行的顺序。会在页面loaded执行前完成。类似 DOM 内通过createElement创建script标签(可配合rel=’preload’)。","pubDate":"Tue, 13 Jul 2021 03:21:58 GMT","guid":"https://wangyx233.github.io/2021/07/13/[读书]JavaScript高级程序设计/","category":"生活"},{"title":"浏览器の网络-HTTP","link":"https://wangyx233.github.io/2021/06/30/浏览器の网络-HTTP/","description":"HTTPHTTP是应用层协议","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/浏览器の网络-HTTP/","category":"网络"},{"title":"HTTPS","link":"https://wangyx233.github.io/2021/06/30/安全了-HTTPS/","description":"HTTP的明文传输带来的问题，可能在传输过程中信息被窃取或者篡改，伪造，容易发生中间人攻击。HTTP -&gt; 安全层（SSL/TLS） -&gt; 传输层 -&gt; 网络层，其中安全层的作用是对发送的HTTP请求进行加密操作，以及对接收到的HTTP请求进行解密操作。 对称加密，非对称加密的优缺点，得到一个对称加密和非对称加密搭配使用的方式。传输过程中使用对称加密传输数据，而对称加密所需的密钥则通过非对称加密传输。搭配数字证书，数字证书是向浏览器方明确服务器方的身份，以及提供公钥。 浏览器端向服务端发送请求，包含对称加密套件列表 + 非对称加密套件列表 + client_random 服务端接到请求后，向浏览器端发送选择的，对称加密套件 + 非对称加密套件 + service_random + 数字证书 浏览器端接到响应，先验证数字证书，然后 client_random + service_random 生成 pre_master，用公钥加密pre_master，再加浏览器确认，发送到服务端 服务端接到请求先用私钥解密，得到pre_master，服务器发送确认 开始 client_random + service_random + premaster 生成的 master secret 加密的数据进行传输。","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/安全了-HTTPS/","category":"网络"},{"title":"同源策略与Web安全","link":"https://wangyx233.github.io/2021/06/30/web安全/","description":"安全问题Web页面安全，浏览器网络安全，浏览器安全 同源策略 Same-origin policy什么是同源？ 两个URL的协议、域名、端口都相同，则这两个URL同源 12http://www.yixuanwang.cn/?article=1http://www.yixuanwang.cn/?article=0 相同源之间可以互相访问资源和操作DOM结点的，不同源之间会有一定安全策略的制约，即为同源策略。不同源之间不能对DOM对象进行读写操作，不能读取Cookie、LocalStorage等数据，也不能通过XMLHttpRequest传递数据。如果想做以上操作怎么办？ 页面引用第三方资源可能会导致XSS攻击 -&gt; CSP 内容安全策略，让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码 安全地进行数据传递，CORS跨域资源共享 安全地相互操作DOM，跨文档消息机制window.postMessage XSS攻击-Cross Site Scripting 跨站脚本是什么XSS是指攻击者向HTML，DOM中注入恶意脚本，从而在用户浏览页面时通过恶意注入的脚本对用户实施攻击。可能会获取用户的Cookies，监控用户的行为“addEventListener”，也可能通过DOM伪造假的登录窗口，也可能生成浮窗广告，影响体验。 存储型XSS，恶意脚本插入网站的数据库里，再读取的时候会进行攻击。 反射型 XSS 攻击，在请求连接里注入恶意脚本，将请求提交给Web服务器，Web服务器收到请求，又将恶意代码反射给了浏览器 基于 DOM 的 XSS 攻击，不涉及服务器，通过页面劫持等方法将恶意脚本注入页面，修改web页面 怎么办 服务器对输入数据进行转码 充分利用CSP(Content-Security-Policy)，限制其他源的资源下载，禁止向第三方域提交数据，禁止执行内联脚本和未授权的脚本，即使上报 使用 HttpOnly 属性，HTTP的响应头，set-cookied: xxxx ; HttpOnly。只能通过HTTP请求使用，无法通过document.cookie获取还可以通过添加验证码的方式防止脚本冒充用户进行提交危险操作，对于一些不信任的输入，还可以限制其输入长度 npm xss库 CSRF攻击：陌生链接不要随便点是什么CSRF(Cross-site request forgery)，跨站请求伪造。攻击者引诱用户打开恶意网站，利用用户的登录状态，发起跨站请求做坏事。 自动发起GET请求，如将请求接口隐藏在图片中： 1&lt;img src=&quot;http://www.abc.cn/sendcoin?user=xxx&amp;number=10&quot;/&gt; 自动发起POST请求，一个隐藏的表单 引诱用户点击链接 怎么办 对于响应头的Cookie设置，SameSite可以设置Strict、Lax 和 None 验证请求的来源站点，通过Origin，Referer判断 设置CSRF Token，每次请求都携带该token进行验证","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/web安全/","category":"安全"},{"title":"【读书】小狗钱钱","link":"https://wangyx233.github.io/2021/06/30/[读书]小狗钱钱/","description":"如何实现梦想 要有自信！！！（建立自信，最好每天写成功日记） 72小时法则：当你决定做一件事的时候，必须在72小时内开始行动，不然很有可能再也不会做（上升到本人，大概需要在72秒内就做吧🐶） 不要抱怨 一定要坚持！！！养成习惯 幸运是充分准备加努力工作的结果 利用碎片化时间，珍惜时间，不要等待。每天十分钟，可以带来真正的改变 要勇敢 如何赚💰","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[读书]小狗钱钱/","category":"生活"},{"title":"【网络】前端开发中的HTTP","link":"https://wangyx233.github.io/2021/06/30/[网络]http/","description":"知识点 HTTP的缓存机制！！！重要 状态码 headers Restful API 状态码 分类 1xx 服务器收到请求 2xx 请求成功 3xx 重定向 4xx 客户端错误 5xx 服务端错误 常见 200 成功 301 永久重定向（配合location新地址，浏览器自动处理，下次会直接访问新的地址） 302 临时重定向（配合location新地址，浏览器自动处理，下次还会访问旧的地址）短网址，百度之类的搜索引擎的链接，why？ 304 资源未修改，缓存 注 307 internal redirect 403 没有权限 404 not found 500 服务器错误 502 504 网关超时，服务器内部 协议规范 Restful API API设计方法，把每个URL当做唯一的资源标识。如何设计一个资源？ 尽量不用url参数，如：/api/list?page=2 -&gt; /api/list/2 用method表示操作类型，POST,PATCH/PUT,DELETE,GET HTTP Headers 常见的Request Headers Accept 浏览器可以的数据格式 Accept-Encoding 浏览器可支持的压缩算法，如：gzip Accept-Language 浏览器支持的语言 Connection: keep-alive 保持TCP连接 Cookie Host User-Agent Content-Type 发送数据格式，如：application/json Authorization token验证 常见的Response Headers Content-Type 发送数据格式，如：application/json Content-Length 返回数据的大小，多少字节 Content-Encoding 返回数据的压缩算法，如：gzip Set-Cookie 服务端改cookie 自定义headers 用于缓存的headers HTTP缓存机制什么是缓存？为什么需要缓存？哪些资源可以被缓存-&gt;js/css/img静态资源和业务数据，html不能被缓存 页面加载更快，网络请求慢，减少网络请求的体积和数量，也是不稳定的 强制缓存服务端控制什么资源可以缓存，通过Response Headers中的cache-control 控制过期时间Cache-Control的值 max-age=86400(秒) no-cache 不用强制缓存，去服务端处理 no-store 不用强制缓存，也不用服务器缓存 private 允许用户客户端做缓存 public 允许中间如cdnExpires也是做缓存过期控制的，已被Cache-Control代替，以Cache-Control为主 协商缓存(对比缓存)服务端缓存策略，服务端来判断是否用缓存，即服务端判断客户端资源是否和服务端资源一样。如果一致则返回304，否则返回200和最新资源注意：资源标识 Response Headers里Last-Modified：资源最后修改时间(精确到秒级)，Etag资源的唯一标识(优先级高，资源被重复生成而内容不变) 再次请求的时候，If-Modified-Since: Last-Modified时间(Request Headers里) Etag，If-None-Match: Etag的值(Request Headers里)两者共存会优先使用Etag，Last-Modified只能精确到秒级 整个缓存过程！ 刷新页面 正常操作：浏览器url，跳转，前进后退等。 强制缓存有效，协商缓存有效 手动刷新，F5，刷新按钮 强制缓存失效，协商缓存有效 强制刷新 强制缓存失效，协商缓存失效","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[网络]http/","category":"网络"},{"title":"【版本管理】gitの世界","link":"https://wangyx233.github.io/2021/06/30/[版本管理]git的世界/","description":"配置1234git --versiongit config --global user.name &apos;xxx&apos;git config --global user.email &apos;xxx&apos;git config --list local global system 工作区/暂存区1git add -u // 已经被管理的文件 update 重命名，git的命令类比linux的系统命令，可直接git commit 12git rm xxx // 删除git mv old new git log 123git log --onelinegit log -n // 最近几次commitgit log -all --graph// 所有分支 git branch 12git branch -v // 本地分支git branch -av .git文件夹 HEAD 指向某个commit 12git checkout -b branch git diff HEAD HEAD^^ / HEAD~n config refs heads 分支 tags 里程碑 objectsblob文件对象 tree commit三者之间的关系只要文件的内容相同，在git里就是唯一的，和文件名没有关系加入暂存区的内容，才会再objects里面有体现commit -&gt; tree -&gt; blob12git cat-file -t xxx 看文件的类型git cat-file -p xxx 看内容 分离头指针 detached HEAD 没有经过某个分支做修改git checkout commit-id 开发后切换分支易丢失，会提示创建新分支git branch name commit-id在分支上做变更 branch 清理 123git branch -vgit branch -dgit branch -D 修改commit message 12git commit --amend // 最近一次commitgit rebase -i // 变基要修改的父commit，在为同步到远端，合并commit也可以实现 diff 1234git diff --cached //暂存区和HEAD的不同git diff // 工作区和暂存区的差异，不加参数是比较所有变动git diff -- filename filename filename git diff branch_name/commit-id/ branch_name/commit-id -- filename 1234git reset HEAD // 暂存区恢复到工作区git reset HEAD -- filenamegit reset --hard/--soft commit-idgit checkout -- filename // 工作区内容恢复到暂存区一样 stash 1234git stashgit stash listgit stash pop // stash git stash apply // stash 列表内的信息还在 .gitignore 12xxx/ // xxx的文件夹会被忽略xxx // xxx的文件和文件夹都会忽略 备份 哑协议：没有协议头 xxx/xx.git，看不到传输速度，速率没有智能协议高 智能协议：带协议头 &gt; file:///xxx/xxx.git12git clone --baregit remote add xxx.git 远端操作，fast-forwards，解决冲突，集成的分支不要做变基，注意fast-forwards 1234git fetchgit mergegit pullgit push git vs svn svn需要获取批准 权限问题，效率 可以托管代码，协同合作 工作流 rerere 123456git config --local rerere.enabled truegit merge // 解决冲突git addgit commitgit resetgit rebase","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[版本管理]git的世界/","category":"git"},{"title":"【必备】开发环境 & 运行环境","link":"https://wangyx233.github.io/2021/06/30/[开发]工具/","description":"开发环境 git 调试工具 抓包 webpack babel linux gitgit show commit-id ~/.ssh 抓包 同一个局域网下 手机配电脑的代理 设置ssh代理proxy 重定向map webpack &amp; babel ES6模块化 export {aaa,bbb,ccc}; import {aaa,bbb,ccc} from ‘xxx’ export default {aaa}; import a from ‘xxx’ ES6语法 压缩，整合代码，配置 常用linux命令- ls -a - mv old new 修改文件名 - cp name copyname - cat head tail - grep 查找 - vimtutor运行环境 页面加载过程 性能优化 安全 页面加载过程 从输入url到渲染出页面的整个过程 window.onload vs DOMContentLoaded 加载资源形式 加载过程 DNS解析：域名-&gt;IP地址 浏览器根据IP地址向服务器发起http请求 服务器处理请求，并返回给浏览器 渲染过程 DOM树 CSSOM DOM + CSSOM -&gt; Render Tree 根据Render Tree渲染页面 遇到 script 则暂停渲染，优先加载js文件，执行js 代码 直到渲染完 css文件为什么要放在head中？避免重复渲染js为什么要放在body最后？不阻塞加载 load // 页面全部加载完，整个资源加载完，比如img，视频，iframe都加载完DOMContentLoaded // DOM渲染完即可执行window.load 性能优化原则 减少CPU计算量，减少网络加载耗时 多使用缓存 - 空间换时间（Chrome浏览器，简洁，每个标签页一个进程） 从何入手 加载更快 减少资源体积：压缩代码（JS，CSS，图片…）服务器端gzip，三分之一 减少访问次数：合并代码，SSR服务端渲染，缓存(文件内容不变，hash不变) 使用更快的网络，CDN 渲染更快 css放在head，js放在body最后 尽早的执行js，用DOMContentLoaded 懒加载，图片懒加载 对DOM查询进行缓存 频繁DOM操作合并一起 节流 throttle、防抖 debounce 防抖 debounce 两个事件之间的时间间隔超过time才会执行，没超过间隔的任务都会取消。即在事件结束和暂停的时候触发，间断理解 12345678910function debounce(fn, delay = 500) &#123; let timer = null; return function () &#123; if (timer) clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); timer = null; &#125;, delay); &#125;&#125; 节流 throttle 无论触发速率多快，都保持一个频率触发。比如，拖拽时间，无论拖拽的多快都会每隔100ms触发一次。 12345678910function throttle(fn, delay = 100) &#123; let timer = null; return function () &#123; if (timer) return; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); timer = null; &#125;, delay); &#125;&#125;","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[开发]工具/","category":"工具"},{"title":"【工程化】Webpack","link":"https://wangyx233.github.io/2021/06/30/[工程化]Webpack/","description":"历史为什么需要 转换ES6 转换JSX 压缩混淆 CSS预处理器 图片压缩… gulp 任务打包器，文件流的概念，每一步构建的结果不会存本地磁盘，而是存在内存里，可以加快打包速度。 webpack vs gulp 社区生态丰富，配置灵活，插件化扩展，官方更新迭代快；module builder vs task runner 简介配置文件，默认：webpack.config.js可以使用 webpack –config xxx 指定配置文件 webpackwebpack-cli 核心概念 entry：模块依赖打包的入口，单页应用为字符串，多页应用为{key: value} output：将编译的文件输出到磁盘，通过filename [xxx]区别多入口多输出，输出的文件名称，为entry设置的key名 loaders！webpack开箱即用的只有js和json两种类型，所以需要通过loaders去支持其他文件类型并转成有效的模块，并且可以加到依赖图里loaders其实是个函数，接受源文件为参数，返回转换的结果。链式调用的，从右向左执行比如： babel-loader css-loader less-loader file-loader plugins，增强webpack的功能，对打包文件的优化，资源的管理，环境变量的注入。作用于整个构建过程 CommonsChunkPlugin HtmlWebpackPlugin UglifyjsWebpackPlugin mode: 指定打包的环境，production，development 12345678910111213const path = require(&apos;path&apos;);module.exports = &#123; entry: &#123; app: &apos;xxx&apos;, admin: &apos;sss&apos; &#125;, output: &#123; filename: &apos;[xxx].js&apos;, path: &apos;&apos; &#125; mode: &apos;production&apos;&#125; 文件监听的原理分析轮询地判断文件最后编辑时间是否变化，某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等aggregateTimeout 12345watchOptions: &#123; ignored: /node_modules/, aggregateTimeout: 300, // 监听到变化后，多长时间后再去执行 poll: 1000 // 1s询问多少次&#125; 热更新webpack compileHMR Server -&gt; HMR Runtime，会被注入到浏览器的bundle.js里面，浏览器里的bundle.js 就可以建立连接websocket，更新变化Bundle Server -&gt; 浏览器访问 localhost 两个阶段，启动阶段 文件系统 -&gt; webpack compile -&gt; Bundle Server 变更阶段，文件系统 -&gt; webpack compile -&gt; HMR Server -&gt; HMR Runtime （json形式） 文件指纹 - 打包后输出的文件名后缀怎样生成的？ hash，和整个项目的构建有关，只要项目文件有修改，整个项目构建的hash就会更改 chunkhash，和webpack打包的chunk有关，不同的entry会生成不同的chunkhash contenthash，根据文件内容来生成hash，文件内容不变，则contenthash不变 ps. file-loader 里面的hash也是指contenthash的意思。style-loader是将css代码插入到head中,MiniCssExtractPlugin是将css文件提取出独立的文件，二者互斥 清理构建目录 - clean-webpack-plugin css 属性前缀 - autoprefixer，postcss-loader px rem 相互转换 rem: font-size of the root element。px2rem-loader 静态资源内联，raw-loader。读取文件的内容，然后把文件的内容插入到对应的位置 多页面打包，MPA - 借助 glob glob.sync(path.join(__dirname, ‘./src/*/index.js’))动态获取entry以及HtmlWebpackPlugin source-map定位到源代码，开发环境中用，线上环境关闭cheap-source-map , inline-source-map，eval 不会有单独的map文件 提取公共资源 HtmlWebpackExternalsPlugin，放cdn的地址 SplitChunkPlugin Tree Shaking设置mode: production,是默认开启的 原理：DCE（Dead Code Elimination）代码不可到达的，不能执行；执行结果不会使用；代码只写不用 利用ES6模块的特点，只能作为模块顶部的语句出现；import的模块名只能是字符串常量；import binding是不可变的 uglify阶段删除无用代码 具有副作用的代码，tree shaking会失效 副作用：一个函数会、或者可能会对函数外部变量产生影响的行为 Scope hoisting问题： 大量函数闭包包裹代码，导致体积增大 运行代码时创建的函数作用域多，内存开销大 模块转换，一个闭包包裹；import被转换成__webpack_require 代码分割，动态import，通过JSONP实现 抽离相同代码到一个共享块 脚本懒加载，初始下载的代码更小","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[工程化]Webpack/","category":"Webpack"},{"title":"【生活】如果有购房需求","link":"https://wangyx233.github.io/2021/06/30/[人生]购房/","description":"房产经纪人-一度觉得自己可以成为 注意事项不论二手还是新房都有一些共通之处，最终要的是要多学，多看，多比较 平时买个几块钱的菜都要比来比去，怎么到了几十上百万的🏡的时候就比买白菜还随意呢？ 现在资讯无比发达，所以在下手之前可以通过各种大v，公众号，或者直播了解一些房产的基本信息。 外部因素 学区属性是否刚需 交通地铁 邻居 车位 流通性 … 内部因素 楼层，楼高 采光，遮挡 隔音，噪音，是否临街 下水，独立下水 供暖，物业 窗户 … 可以多实地看几套二手房，看房又不💰，实地感受一下各种因素的影响，以及自己的接受度 二手房尤其要注意🏡的流通性，大概率5-8年会换房，所以中介费，还有税费要注意 新房封顶以后才能批贷，这点要注意。","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[人生]购房/","category":"生活"},{"title":"【生活】如果有保险需求","link":"https://wangyx233.github.io/2021/06/30/[人生]家庭保险配置/","description":"人生中总有各种事情发生，鉴于马上要背上巨额贷款，为了一定程度上抵御风险，不得不看起了保险。基于自己浅薄的研究，总结了几大类产品： 看病(尤其是大病)： 百万医疗 重疾 GG: 寿险 意外险 如果不考虑太多的，平时缴纳的社保，以及公司的补充医疗基本能够覆盖平时的看病就医。所以保险里的医疗部分一般主要cover大病系列，百万医疗是可以报销治疗过程中的费用。而重疾则是一次性给付，确诊了就赔付，弥补无法搬砖导致的损失，支撑生活。 百万医疗，支付宝上可以入好医保6/20年版本的，年轻时刻几百左右。 重疾，是真的贵。2021/2月要执行新规，先观望吧，之前入的话，能择优理赔的更好。 意外和馅饼也不知道哪个先来。所以如果为了买个安心，用不到当然更好，这个时候就祭出了寿险。如果不小心GG，还会留下一部分💰，保证家里的继续。 寿险，选个性价比高的就行，最好用不到，所以选个自己能接受的价格，保自己想要的额度就好。目前只看了大麦2021，擎天柱5号…，如果是夫妻双方都苦苦支撑起了一个家，还有大麦甜蜜家2021这种项目。 意外，如果配置了其他的寿险，医疗啥的，也可以不用care这个。也不需要买长期的，即买即用，一年的价格也便宜，比如大护甲xxx。 如果要买保险的话，一定要仔细看下投保须知和除外责任，尽量减少踩太多坑坑坑。jin se太难了 当然一切都看开，其实无所畏惧！","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[人生]家庭保险配置/","category":"生活"},{"title":"【WebAPI】BOM","link":"https://wangyx233.github.io/2021/06/30/[WebAPI]BOM/","description":"BOM -&gt; Browser Object Model 如何识别浏览器的类型 分别拆解url各部分 知识点 navigator screen location history123456789101112131415161718// 1. navigatorconst ua = navigator.userAgent;// 2. screenconst width = screen.width;const height = screen.height;// 3. locationlocation.hreflocation.protocollocation.pathnamelocation.hashlocation.searchlocation.host// 4. historyhistory.back();history.forwards();","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[WebAPI]BOM/","category":"JavaScript"},{"title":"【React】生命周期","link":"https://wangyx233.github.io/2021/06/30/[React]生命周期/","description":"React 15 Mounting 阶段：组件的初始化渲染在组件一生中仅会发生一次。组件初始化，然后被渲染到真实的 DOM 中，完成“首次渲染”。render 不会操作真实的 DOM，真实 DOM 的渲染工作，在挂载阶段是由 ReactDOM.render 来承接的。componentDidMount 在渲染后触发，此时真实的 DOM 已经挂载，可以进行数据请求，初始化等操作。 Updating 阶段：组件的更新 父组件更新触发的更新。componentReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的 组件调用 setState 触发更新。 shouldComponentUpdate 决定组件的 re-render Unmounting 阶段：组件的卸载。 组件被移除了，或者设置了 key，在 render 过程中发现 key 改变了 React 16React 16.4","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[React]生命周期/","category":"React"},{"title":"【React】Virtual DOM","link":"https://wangyx233.github.io/2021/06/30/[React]虚拟DOM/","description":"What？Virtual DOM本质上是JS 和 DOM 之间的一个映射缓存，是能够描述DOM结构及其属性的JS对象。 虚拟DOM是JS对象 虚拟DOM是对真实DOM的描述 挂载阶段，根据JSX的描述，构建出虚拟DOM，然后通过ReactDOM.render实现虚拟DOM到真实DOM的映射更新阶段，页面的变化在作用于真实DOM之前，会先作用于虚拟DOM Why？ jQuery解决DOM API 不好使的问题。还解决浏览器兼容，链式API调用，插件扩展 模板引擎，只关心数据，不关心DOM细节。操作真实DOM的范围过大、频率过高，但思想是数据驱动视图 虚拟DOM的点不在性能。虚拟DOM有没有借鉴模板引擎无法考证，但是思想上有一定的递进关系。JSX不是模板，而是JS的一个体验像模板的扩展语法糖，然后增加了个虚拟DOM的缓存层。 差量更新。即当DOM操作比较频繁时，会将前后两次的DOM树变化进行对比diff，定位到需要更新的部分，生成一个“补丁集”，把“补丁”patch打在需要更新的那部分真实DOM上，就可以实现差量更新批量更新。batch函数处理，把短时间内的多次DOM操作合成一个次更新，即把收集的多个补丁集暂存到队列中，再讲最终结果交给渲染函数，实现DOM的集中化批量更新。 研发体验/研发效率。虚拟DOM思想是数据驱动视图，前端声明式编程。 性能不是卖点。性能还不错，性能量化不能一概而论只看一个指标，得看实际情况。DOM操作量级有关 价值？跨平台，一次编码多次应用。虚拟DOM是对实际渲染内容的一次抽象 规避xss攻击 缺点： 内存占用高，虚拟DOM，object 无法进行极致优化。如Google Earth How?调和Reconciliation 和 Diff算法 调和是将虚拟DOM映射到真实DOM的过程。Diff算法只是其中的一个小部分，深度优先遍历 React 15为代表的“栈调和”传统的递归比较两棵树结构的不同算法复杂度是O(n^3)，这个复杂度显然不能令人接受，所以React中做了什么呢，将复杂度转换成O(n) Diff算法性能突破的关键点是“分层比较”分层比较其实是分层递归比较，所以“同层级操作”是主流，只针对相同层级的节点进行比较，如果是跨层级的节点操作，其实是对应这销毁和重建的过程，尽量保持DOM节点的稳定性。 类型一致的节点才有继续Diff的必要根据主要“矛盾”类型不一致的节点，直接放弃比较，原地替换旧的节点。 key属性的设置，可以尽可能重用同一层级内的节点key主要解决的是同一层级下节点的重用问题。设置key的元素可以避免不必要的销毁和重建，只是调整顺序排列。 注：作为一个节点的唯一标识，使用key之前，保证key的唯一和稳定。大致过程可以描述为树对比、组件对比、元素对比总结：栈调和机制下的Diff算法，其实是树的深度优先遍历过程。这个过程是同步的过程，不可被打断。Stack Reconciler 需要的时间越长，意味着JS线程将霸占主线程的时间越长。进而导致会出现渲染卡死、交互无响应的现象。 React 16以来的“Fiber调和”Fiber：纤程，对渲染过程进行更加精细的控制。是Fiber树结构的节点单位，也就是React 16下的“虚拟DOM”,并且Fiber节点保存了组件需要更新的状态和副作用。 可中断 可恢复 优先级 Better？ 避免跨层级节点移动 设置唯一的key，尽量减少组件层级 设置shouldComponentUpdate 或者 React.pureComponet 减少 diff 次数","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[React]虚拟DOM/","category":"React"},{"title":"【React】源码从入门到跑路","link":"https://wangyx233.github.io/2021/06/30/[React]源码从入门到跑路/","description":"event 事件为什么需要bind(this) 对于class内普通定义的触发函数需要bind this，而使用静态方法定义则可以不用绑定class Test { constructor(props) { this.normalFun = this.normalFun.bind(this) // 只执行一次 } normalFun() {} staticFun = () =&gt; {} eventFun = event =&gt; {} // 追加的event参数 render() { return &lt;div onClick={this.staticFun}&gt;&lt;/div&gt; } } 由于this指向的问题，如果普通模式不bind this的话，此时this指向为undefined，而静态方法的this指向当前实例 如果要bind的话，bind this 的位置写在什么地方合适呢？和执行的次数有关，性能优化小点 event 参数，不是原生的event，是组合事件通过event.proto.constructor区分，React的event是组合事件(SyntheticEvent)，原生的为MouseEvent。通过nativeEvent获取原生事件event.target,event.currentTarget vs event.nativeEvent.target 触发的 event.nativeEvent.currentTarget 绑定的document，React 17之前。自定义参数，最后会追加一个参数是event 区别 vue ：原生的事件，绑定在当前元素上react：不是原生的事件，是组合事件SyntheticEvent模拟DOM事件所有能力，react 17 之前绑定在document，之后当前元素 表单 受控组件，类似双向数据绑定 非受控组件propTypes 类型检查 component.propTypes 父组件子组件通讯 传值 list = {xxx} 传函数，父组件控制数据，数据提升 cFun = {xxx} setState 不可变值 可能是异步 可能会被合并 可能是同步","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[React]源码从入门到跑路/","category":"React"},{"title":"【React】数据交互","link":"https://wangyx233.github.io/2021/06/30/[React]数据交互/","description":"React 的核心特征是“数据驱动视图” 1UI = render(data) 基于 props 的单向数据流 props：组件从概念上类似与JavaScript函数，它接受任意的入参(props)并返回用于描述页面展示内容的React元素。 所谓单向数据流，指的就是当前组件的 state 以 props 的形式流动时，只能流向组件树中比自己层级更低的组件。 比如在父-子组件这种嵌套关系中，只能由父组件传 props 给子组件，而不能反过来。 基于 props 传参这种形式，我们可以轻松实现父-子通信、子-父通信和兄弟组件通信。","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[React]数据交互/","category":"React"},{"title":"【React】性能优化","link":"https://wangyx233.github.io/2021/06/30/[React]性能优化/","description":"善用 shouldComponentUpdate PureComponent + Immutable.js 函数组件的性能优化：React.memo 和 useMemo","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[React]性能优化/","category":"React"},{"title":"【React】前端路由-React Router","link":"https://wangyx233.github.io/2021/06/30/[React]前端路由/","description":"What 切换Hash 切换PathHTML5的History API中的 pushState、replaceState，还需要在服务端配置historyApiFallback路由守卫How 路由器：BrowserRouter 和 HashRouter BrowserRouter 是使用 HTML 5 的 history API 来控制路由跳转的。 HashRouter 是通过 URL 的 hash 属性来控制路由跳转的。12345678910111213window.location.hash// 监听hash变化，点击浏览器的前进后退会触发window.addEventListener(&apos;hashchange&apos;, function(event)&#123; // 根据 hash 的变化更新内容&#125;,false)window.history.forward() // 前进到下一页window.history.back() // 后退到上一页window.history.go(2)history.pushState(data[,title][,url]); // 向浏览历史中追加一条记录history.replaceState(data[,title][,url]); // 修改（替换）当前页在浏览历史中的信息window.addEventListener(&apos;popstate&apos;, function(e) &#123; console.log(e)&#125;); go、forward 和 back 等方法的调用确实会触发 popstate，但是pushState 和 replaceState 不会。不过这一点问题不大，我们可以通过自定义事件和全局事件总线来手动触发事件。","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[React]前端路由/","category":"React"},{"title":"【React】事件系统","link":"https://wangyx233.github.io/2021/06/30/[React]事件/","description":"DOM事件流 事件捕获 目标阶段 事件冒泡 事件委托/事件代理 把多个子元素的同一类型的监听逻辑，合并到父元素上通过一个监听函数来管理的行为，就是事件委托。e.target 这个属性，指的是触发事件的具体目标，记录着事件的源头。 React事件系统合成事件 当事件在具体的DOM节点上被触发后，最终都会冒泡到document(或者ReactDOM.render绑定的元素)，document上所绑定的统一事件处理程序会将事件分发给具体的组件实例。 合成事件是React自定义的事件对象，符合W3C规范，在底层抹平了不同浏览器的差异，在上层向开发者暴露统一的，稳定的，与DOM原生事件相同的事件接口。不必关注兼容问题，专注业务开发。合成事件不是原生的事件，但是它保存了原生事件的引用，e.nativeEvent React 事件的命名采用小驼峰式（camelCase），而不是纯小写。使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault比如： 1234handleClick() &#123; console.log(&apos;this is:&apos;, this);&#125;&lt;div onClick=&#123;()=&gt;this.handleClick()&#125;&gt;&lt;/div&gt;","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[React]事件/","category":"React"},{"title":"【React】setState 同步 or 异步？","link":"https://wangyx233.github.io/2021/06/30/[React]setState/","description":"在React管控下的setState是异步，而脱离React管控的则表现为同步。","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[React]setState/","category":"React"},{"title":"【React】ReactDom.render","link":"https://wangyx233.github.io/2021/06/30/[React]ReactDOM.render/","description":"ReactDom.render 调用栈逻辑 scheduleUpdateOnFiber commitRoot 正式渲染DOM 初始化阶段 - 完成Fiber🌲基本实体的构建 render阶段 - 深度优先搜索过程 commit阶段","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[React]ReactDOM.render/","category":"React"},{"title":"【React】Why JSX?","link":"https://wangyx233.github.io/2021/06/30/[React]JSX/","description":"Question JSX 的本质是什么，它和 JS 之间到底是什么关系？ 为什么要用 JSX？不用会有什么后果？ JSX 背后的功能模块是什么，这个功能模块都做了哪些事情？","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[React]JSX/","category":"React"},{"title":"【React】React-Hooks","link":"https://wangyx233.github.io/2021/06/30/[React]React-Hooks/","description":"React-Hooks 自 React 16.8 以来才真正被推而广之 What &amp; Why类组件 Class Component vs 函数/无状态组件 所谓类组件，就是基于 ES6 Class 这种写法，通过继承 React.Component 得来的 React 组件函数组件/无状态组件，在没有Hooks加持的条件加，函数组件无法维护自己的state 二者并没有优劣，只是根据不同的场景采用不同的形式。 区别：函数组件会捕获render内部的状态。面向对象与函数式的不同。this调用的区别注：对于函数组件，props会保持渲染结果符合预期。更利于逻辑拆分与重用组件为了回归 UI = render(data)的本质，所以需要补齐函数组件所缺乏的的类组件的能力，React Hooks应运而生。即一套能够使函数组件更强大、更灵活的“钩子”ex. useState() 为函数组件引入了state，const [state, setState] = useState(initialState) useEffect() 允许函数执行副作用操作，即弥补了生命周期的缺失，比如componentDidMount、componentDidUpdate和componentWillUnmount。操作DOM、订阅事件、调用外部API。useEffect(callBack, []) callback 是否有return,决定是否在卸载阶段执行。有return则会在挂载执行return之前的内容，卸载阶段执行return的函数。即useEffect回调中返回了一个函数，那它会被作为清除函数处理。 [],判断是否每次页面渲染后都执行。如果 []不为空，React会在每次渲染前对比前后两次的渲染，查看数组内部是否有变量发生了更新。注意引用类型的比较可能因为变化导致判断结果不同。 useLayoutEffect() 同useEffect都是用来处理副作用的，底层函数签名也是一致的，都是mountEffectImpl，在使用上也没有什么区别。但useEffect是异步调用的，useLayoutEffect则是在DOM变更后同步调用，主要避免页面闪烁、调整样式、处理DOM，但正是由于同步操作，所以避免在useLayoutEffect中做计算量大耗时的任务，以免出现阻塞。Hooks 开发需要抛弃生命周期的思考模式，以 effects 的角度重新思考 所以 Why? 告别难以理解的Class，this和生命周期，降低学习成本。 更好的进行逻辑拆分，避免重复冗余的代码。 状态复用 HOC（高阶组件） 函数补齐能力还需继续完善，声明周期还有未纳入Hooks中的 常量声明 原则 只在React函数中调用Hook 不要在循环，条件和嵌套中用Hook。why？eslint-plugin-react-hooks 以setState为例， mountState，初始化hook，将hook相关的所有信息都收敛在一个hook对象里，hook对象之间以单向链表的形式相互串联。 updateState，按顺序去遍历之前构造好的链表，然后取相应的数据进行渲染。重点：按“顺序”去修改！ PS:心智模型：引用唐纳德·诺曼，是指用户头脑中对一个产品应该具有的概念和行为的知识。这个知识可能来源于用户以前使用类似产品的沉淀，或者用户根据使用该产品要达到的目标而对产品概念和行为的一种期望。 Q&amp;A: 如何设计React的组件？ 展示组件的复用性更强，灵巧组件则更专注与业务本身 展示组件： 无状态组件，只做展示，独立运行 代理组件 样式组件 布局组件 灵巧组件： 有状态组件，主要进行业务逻辑和数据状态处理 容器组件 高阶组件 逻辑复用 链式调用 渲染劫持 缺陷：丢失静态函数，refs属性不能透传","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[React]React-Hooks/","category":"React"},{"title":"【JS基础】浏览器中JavaScript执行机制","link":"https://wangyx233.github.io/2021/06/30/[JS基础]浏览器中JavaScript的执行机制/","description":"变量提升（Hoisting）What? JavaScript代码执行过程中，JS引擎会把变量声明和函数声明部分提升到代码的开头，并不是物理性的移动，实际中代码并没有改变，而是JS引擎在编译阶段放进内存的。一段JS代码在执行时，先经过编译，编译完成后，再进入执行阶段。编译后的内容分为两部分：执行上下文（Execution context）和可执行代码。 12345678910111213141516showName()console.log(myname)var myname = &apos;xxx&apos;function showName() &#123; console.log(&apos;函数showName被执行&apos;);&#125;// 编译var myname;function showName() &#123; //函数定义放到堆中，变量环境中showName指向该函数 console.log(&apos;函数showName被执行&apos;);&#125;// 执行showName()console.log(myname)myname = &apos;xxx&apos; QA 代码中相同的变量和函数如何处理？12345678function showName() &#123; console.log(&apos;aaa&apos;);&#125;showName();function showName() &#123; console.log(&apos;bbb&apos;);&#125;showName();","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[JS基础]浏览器中JavaScript的执行机制/","category":"JavaScript"},{"title":"【JS基础】异步","link":"https://wangyx233.github.io/2021/06/30/[JS基础]异步/","description":"思考 同步和异步的区别 手写Promise 前端异步的场景 event loop（事件循环）的机制，画图 async/await Promise的三种状态，then，catch的连接 123456789console.log(1)setTimeout(() =&gt; &#123; console.log(2)&#125;, 1000);console.log(3)setTimeout(() =&gt; &#123; console.log(4)&#125;, 0);console.log(5)","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[JS基础]异步/","category":"JavaScript"}]}