{"title":"Hexo","description":null,"language":null,"link":"https://wangyx233.github.io","pubDate":"Mon, 21 Mar 2022 06:34:01 GMT","lastBuildDate":"Fri, 25 Mar 2022 01:57:18 GMT","generator":"hexo-generator-json-feed","webMaster":"Yx","items":[{"title":"【网络】传输层我来了","link":"https://wangyx233.github.io/2022/03/21/[网络]传输层/","description":"UDP（User Datagram Protocol，用户数据包协议） TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 对于数据包丢失的情况，TCP 提供重传机制（Acknowledgement Number）； TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件（Sequence Number）。 一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。 建立连接。通过“三次握手”来建立客户端和服务器之间的连接。 1234 客户端 服务端 SYN_SENT -&gt; SYN = 1 seq = x SYN_RCVD &lt;- SYN = 1 ACK = 1 seq = y ack = x + 1ESTABLISHED -&gt; ACK = 1 seq = x + 1 ack = y + 1 ESTABLISHED 两次握手可以吗？ (1) 确认双方的收发能力TCP 建立连接之前，需要确认客户端与服务器双方的收包和发包的能力。 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。所以，只有三次握手才能确认双方的接收与发送能力是否正常。 (2) 序列号可靠同步如果是两次握手，服务端无法确定客户端是否已经接收到了自己发送的初始序列号，如果第二次握手报文丢失，那么客户端就无法知道服务端的初始序列号，那 TCP 的可靠性就无从谈起。 (3) 阻止重复历史连接的初始化三次握手才有足够的上下文信息来判断当前连接是否是历史连接 (4) 安全问题如果采用两次握手，就建立连接，那会放大 DDOS 攻击的。 TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而三次握手恰好可以满足以上两方面的需求！ ISN 代表什么？意义何在？ISN 是固定不变的吗？ISN 为何要动态随机？ ISN 全称是 Initial Sequence Number，是 TCP 发送方的字节数据编号的原点，告诉对方我要开始发送数据的初始化序列号 ISN 如果是固定的，攻击者很容易猜出后续的确认序号，为了安全起见，避免被第三方猜到从而发送伪造的 RST 报文，因此 ISN 是动态生成的 什么是半连接队列？ 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立连接。服务器会把这种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。 三次握手可以携带数据吗？ 第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，疯狂着重复发 SYN 报文，这会让服务器花费大量的内存空间来缓存这些报文，这样服务器就更容易被攻击了。 传输数据接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。 断开连接。“四次挥手”来保证双方都能断开连接 123456客户端 服务端FIN_WAIT_1 -&gt; FIN = 1 seq = uFIN_WAIT_2 &lt;- ACK = 1 seq = v ack = u + 1 CLOSE_WAIT &lt;- FIN = 1 seq = w ack = u + 1 LAST_ACK TIME_WAIT -&gt; ACK = 1 seq = u + 1 ack = w + 1 CLOSE CLOSE 2 MSL 为什么建立连接握手三次，关闭连接时需要是四次呢？ 其实在 TCP 握手的时候，接收端发送 SYN+ACK 的包是将一个 ACK 和一个 SYN 合并到一个包中，所以减少了一次包的发送，三次完成握手。在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 FIN 包与对客户端的 ACK 包合并发送，只能先确认 ACK，然后服务器待无需发送数据时再发送 FIN 包，所以四次挥手时必须是四次数据包的交互。 为什么 TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？ (1) MSL 指的是报文在网络中最大生存时间。在客户端发送对服务器端的 FIN 的确认包 ACK 后，这个 ACK 包是有可能不可达的，服务器端如果收不到 ACK 的话需要重新发送 FIN 包。所以客户端发送 ACK 后需要留出 2MSL 时间（ACK 到达服务器 + 服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。客户端如果等待 2MSL 时间也没有收到服务器端的重传包 FIN，说明可以确认服务器已经收到客户端发送的 ACK。(2) 在客户端发送完最后一个 ACK 报文段后，在经过 2MSL 时间，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文。避免新旧连接混淆。 总结： IP 负责把数据包送达目的主机。 网络层 UDP 负责把数据包送达具体应用。端口号 而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。","pubDate":"Mon, 21 Mar 2022 06:34:01 GMT","guid":"https://wangyx233.github.io/2022/03/21/[网络]传输层/","category":"TCP"},{"title":"碎碎念","link":"https://wangyx233.github.io/2022/03/16/碎碎念/","description":"害，还是加分号吧，减少 debug 的成本来自解构赋值的怒吼。。。","pubDate":"Wed, 16 Mar 2022 03:28:05 GMT","guid":"https://wangyx233.github.io/2022/03/16/碎碎念/","category":""},{"title":"【JS基础】数组乱序","link":"https://wangyx233.github.io/2022/03/10/[JS基础]数组乱序/","description":"最近在解决一个分布式高可用的问题，如何能够让多机的定时任务能够不重复执行，引入了 redis 的分布式锁。但一个任务列表如果都顺序遍历那每个任务的抢占可能不会那么随机，所以想让任务列表打乱顺序，就稍微了解了一下数组乱序的实现。 （其实最后用的还是 lodash 的_.shuffle() 😯 一、随机数？ 123[12,4,16,3].sort(function() &#123; return .5 - Math.random();&#125;) v8 在处理 sort 方法时，使用了插入排序和快排两种方案。当目标数组长度小于 10（不同版本有差别）时，使用插入排序；反之，使用快排。 二、Fisher–Yates shuffle 洗牌算法 123456789101112Array.prototype.shuffle = function() &#123; let array = this; let len = array.length, temp, i; while (len) &#123; i = Math.floor(Math.random() * len--); temp = array[len]; array[len] = array[i]; array[i] = temp; &#125; return array;&#125;","pubDate":"Thu, 10 Mar 2022 08:50:45 GMT","guid":"https://wangyx233.github.io/2022/03/10/[JS基础]数组乱序/","category":"JavaScript"},{"title":"【JS基础】复盘","link":"https://wangyx233.github.io/2022/03/04/[复盘]基础中的基础/","description":"基础知识要深刻，扎实，不要模棱两可，懂个大概 typeof函数的默认返回值是 undefined 呀~ 123456function sayHi () &#123; return (() =&gt; &#123; console.log(1) &#125;)()&#125;console.log(typeof sayHi()) 作用域 与 变量提升 var 声明的变量会进行变量提升 js 代码自上而下执行之前，浏览器首先会把当前上下文中所有带“var / function”关键字进行提前的声明和定义，解析到它们对应作用域开始的位置，这种预先处理的机制叫做变量提升，变量提升的意义在于创建变量前使用这个变量不报错。 变量提升也可以称之为预解析。可以理解为这是词法解析的一个环节，语法解析发生在代码执行前 JavaScript 仅提升声明，而不提升初始化 函数和变量相比，会被优先提升。（函数声明式，函数提升是整个代码块（相当于申明和初始化都提升了）提升到它所在的作用域的最开始执行，函数字面量式，这种情况和变量提升是一样的） 所以看一个变量的值，要结合作用域来判断 作用域12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function sayHi() &#123; console.log(name) console.log(age) var name = &apos;xxx&apos; let age = 18&#125;var name = &apos;outer&apos;function sayHi() &#123; console.log(name) var name = &apos;eric&apos;&#125;function sayHi(name) &#123; console.log(name) var name = &apos;eric&apos;&#125;sayHi(&apos;param&apos;)var name = &quot;world&quot;;(function()&#123; if(typeof name === &quot;undefined&quot;) &#123; var name = &quot;Jack&quot;; console.log(&quot;Hello &quot; + name); &#125; else &#123; console.log(&quot;Hello &quot; + name); &#125;&#125;())function sayHi() &#123; console.log(name) name = &apos;hi&apos;&#125;sayHi()// var a = 1function b() &#123; console.log(a) a = 2&#125;b()console.log(a)var foo=&#123;n:1&#125;;(function (foo) &#123; console.log(foo.n); foo.n = 3; var foo = &#123;n:2&#125;; console.log(foo.n);&#125;)(foo);console.log(foo.n);function f1(a)&#123; // a = 111，有默认值 console.log(a); function a()&#123;&#125; console.log(a); var a = 1; console.log(a);&#125;f1(2) 函数的参数名是按值传递的，参数类型是引用类型的话，传递的是引用的地址。 函数参数和变量的问题： 函数有形参，形参会被添加到函数的作用域中，并且形参不会被重新定义。var 声明与形参同名的变量会被忽略，即参数的优先级高于变量的提升。 ES6 的 let 和 const 会因为作用域内重复声明而报错。 如果函数内声明一个和形参同名的函数，装载顺序为 函数参数 &gt; 函数声明，而在函数声明装载时，如果函数体内有个和参数名相同的函数声明，那么这个函数就会覆盖形参。 有默认参数的，再传实参，参数值 会覆盖 函数声明。 let： let 声明的变量的作用域是块级的； let 不能重复声明已存在的变量； let 有暂时性死区，不会被提升。 this12345678910const shape = &#123; radius: 10, diameter: function() &#123; return this.radius * 2 &#125;, perimeter: () =&gt; 2 * 3.14 * this.radius&#125;console.log(shape.diameter())console.log(shape.perimeter()) undefined 的类型转换如何判断是不是 NaN window.isNaN 会先把参数转化为数字类型,再判断是不是 NaN,所以像 string 类型的会是 true; 而 Number.isNaN 会先判断参数是不是数字类型,不是就返回 false, 是数字类型再进入判断是不是 NaN 利用 NaN 是 JavaScript 之中唯一不等于自身的值 Object.is(+0, -0)，Object.is() 是 ES6 用来比较两个值是否严格相等","pubDate":"Fri, 04 Mar 2022 07:12:21 GMT","guid":"https://wangyx233.github.io/2022/03/04/[复盘]基础中的基础/","category":"JavaScript"},{"title":"【CSS】flex & grid","link":"https://wangyx233.github.io/2022/02/23/[CSS]flex copy/","description":"平时常用 flex 进行对齐和布局，习惯了 align-items 和 justify-content，也会遇到过宽度换行的情况。 flex: 1 是什么？ 2 是什么？ 10px？有单位是 flex-basis 的值，无单位的话则为 flex-grow 的值 即：一个无单位数(): 它会被当作 flex: 1 0;注：省略值和默认值不同 12345678910/* 关键字值 */flex: initial; // 0 1 auto 根据自身宽高设置尺寸，会收缩但不会伸长。适合一侧宽度固定，另一侧宽度任意，display: flex; 默认值flex: auto; // 1 1 auto 根据自身宽高，会收缩会伸长；优先扩张，适合内容动态适配flex: none; // 0 0 auto 根据自身宽高设置尺寸，不会收缩也不会伸长；适合自身不变的flex-grow: 省略时1flex-shrink: 省略时1flex-basis: 省略时0flex: 1 -&gt; 1 1 0% // 优先缩小自己的体积，充分利用剩余空间，又不侵占其他元素的位置，适合等分flex: 10px -&gt; 1 1 10px 最近有使用 grid 布局 1234display: grid;grid-template-columns: repeat(3, 1fr);grid-template-rows: repeat(3, 1fr);grid-gap: 10px;","pubDate":"Wed, 23 Feb 2022 09:41:33 GMT","guid":"https://wangyx233.github.io/2022/02/23/[CSS]flex copy/","category":"css"},{"title":"<JS基础>手写小试","link":"https://wangyx233.github.io/2022/02/16/[JS基础]手写小试/","description":"一、数组扁平化如何将一个多维数组变成一个一维数组，如： 12const arr = [1, [2, [3, [4, [5]]]]]// =&gt; [1,2,3,4,5] 看到数组扁平，第一想到的是 concat()，然后是递归，依次实现一番。 (1) 递归 1234567891011function flat(arr, depth = 1) &#123; let res = [] arr.forEach((elem) =&gt; &#123; if(!Array.isArray(elem) || !depth)&#123; res.push(elem) &#125;else &#123; res = res.concat(flat(elem, depth - 1)) &#125; &#125;) return res&#125; (2) reduce()配合 concat() 123function flat(arr, depth = 1) &#123; return depth ? arr.reduce((temp, elem) =&gt; (temp.concat(Array.isArray(elem) ? flat(elem, depth - 1) : elem)) , []) : arr&#125; (3) 内置 API，一顿操作，竟然忽略了 Js Array 的内置 api–flat()，按指定深度递归遍历数组，将所有元素与遍历的子数组中的元素合并为一个新数组返回。 12var newArray = arr.flat([depth])const res = arr.flat(Infinity); (4) 正则，另辟蹊径 12const res1 = JSON.stringify(arr).replace(/\\[|\\]/g, &apos;&apos;).split(&apos;,&apos;); // 原来数字变成了字符串const res2 = JSON.parse(`[$&#123;JSON.stringify(arr).replace(/\\[|\\]/g, &apos;&apos;)&#125;]`); (5) 迭代 1234567function flat(arr, depth = 1) &#123; while(arr.some(elem =&gt; Array.isArray(elem)) &amp;&amp; depth) &#123; arr = [].concat(...arr) depth-- &#125; return arr&#125; 二、数组去重12const arr = [1, 17, &apos;1&apos;, 17, true, true, false, false, &apos;true&apos;, &apos;a&apos;, &#123;&#125;, &#123;&#125;];// =&gt; [1, &apos;1&apos;, 17, true, false, &apos;true&apos;, &apos;a&apos;, &#123;&#125;, &#123;&#125;] 看到数组去重，首先想到的是维护一个 object 用于记录出现过的值然后去掉重复，然后想到 filter 也可以实现类似的 (1) object 方法，普通 object 的 key 都会转换成 String 类型，所以可以借助 ES6 的 Map; 1234567891011const uniq = (arr) =&gt; &#123; const map = new Map(); const res = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (!map.has(arr[i])) &#123; map.set(arr[i], true); res.push(arr[i]); &#125; &#125; return res;&#125; (2) filter，过滤得到首次出现的元素。判断元素是否出现过还可以使用 arr.indexOf(elem) === -1 或者 arr.includes(elem) 1const res = arr.filter((elem, index) =&gt; arr.indexOf(elem) === index); (3) ES6 的 Set 数据结构，特性是每个元素都是唯一的，没有重复的值 12const res = [...new Set(arr)];[...new Set(&apos;ababbc&apos;)].join(&apos;&apos;); // &apos;abc&apos; 三、深拷贝12345678910111213function cloneDeep(data, exist = new Map()) &#123; if(typeof data !== &apos;object&apos; || data === null) return data if(data instanceof Date) return new Date(data) if(data instanceof RegExp) return new RegExp(data) if(exist.has(data)) return exist.get(data) let result = Array.isArray(data) ? [] : &#123;&#125; exist.set(data, result) const keys = [...Object.keys(data), ...Object.getOwnPropertySymbols(data)] keys.forEach(key =&gt; &#123; result[key] = cloneDeep(data[key], exist) &#125;) return result&#125; // 两个有序数组[1,3,5]和[2,4,6]，写一个 mergeArr(a,b)合并两个数组，最终得到一个有序数组 _.get() 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？","pubDate":"Wed, 16 Feb 2022 06:44:26 GMT","guid":"https://wangyx233.github.io/2022/02/16/[JS基础]手写小试/","category":""},{"title":"【浏览器】从输入URL到页面展示发生了什么？","link":"https://wangyx233.github.io/2022/02/16/[浏览器]从输入URL到页面展示发生了什么/","description":"前置知识：目前浏览器都有哪些进程？ 浏览器主进程 渲染进程：默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中。 网络进程 GPU 进程 插件进程 1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程 多进程模型提升了浏览器的稳定性、流畅性和安全性。但同样不可避免地带来了一些问题，更高的资源占用，更复杂的体系架构。为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统。浏览器的主进程，渲染进程，插件进程。其他的变成基本服务，比如，网络进程、GPU 进程、Audio 进程、Video 进程、文件进程、Profile 进程、UI 进程、设备进程…内存不够的系统中，会把相关的进程都合并进主进程。 用户输入 url 并回车 浏览器进程检查 url，组装协议，构成完整的 url 浏览器进程通过进程间通信（IPC）把 url 请求发送给网络进程 网络进程接收到 url 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程 如果没有，网络进程向 web 服务器发起 http 请求（网络请求），请求流程如下： 进行 DNS 解析，获取服务器 ip 地址，端口（端口是输入的，没输入 http 80，https 443)，如果请求协议是 HTTPS，那么还需要建立 TLS 连接 利用 ip 地址和服务器建立 tcp 连接 构建请求头信息 发送请求头信息 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容 网络进程解析响应流程； 检查状态码，如果是 301/302，则需要重定向，从 Location 自动中读取地址，重新进行第 4 步 （301/302 跳转也会读取本地缓存），如果是 200，则继续处理请求。 200 响应处理：检查响应类型 Content-Type，如果是字节流类型(application/octet-stream)，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是 html 则通知浏览器进程准备渲染进程准备进行渲染。 准备渲染进程 浏览器进程检查当前 url 是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程(process-per-site-instance) 传输数据、更新状态。 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道” 渲染进程接收完数据后，向浏览器发送“确认提交” 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏 url、前进后退的历史状态、更新 web 页面 总体来说，分为网络请求和渲染两大部分，即导航流程和渲染流程。","pubDate":"Wed, 16 Feb 2022 02:04:47 GMT","guid":"https://wangyx233.github.io/2022/02/16/[浏览器]从输入URL到页面展示发生了什么/","category":"浏览器"},{"title":"【JS基础】执行","link":"https://wangyx233.github.io/2022/02/15/[JS基础]执行/","description":"JavaScript 执行主要分为两个阶段： 代码预编译阶段 代码执行阶段 代码预编译阶段 预编译阶段进行变量声明 预编译阶段变量声明进行提升，但是值为 undefined 预编译阶段所有非表达式的函数声明进行提升 12345678910111213foo(10)function foo (num) &#123; console.log(foo) foo = num; console.log(foo) var foo&#125;console.log(foo)foo = 1console.log(foo)// undefined// 10// 1 作用域在预编译阶段确定，但是作用域链是在执行上下文的创建阶段完全生成的。执行上下文包括了：变量对象、作用域链以及 this 的指向 预编译阶段创建变量对象(Variable Object, VO)，在执行阶段，变量对象转换为激活对象(Active Object)，即完成 VO -&gt; AO 正常来讲，在函数执行完毕并出栈时，函数内局部变量在下一个垃圾回收节点会被回收，该函数对应的执行上下文将会被销毁，这也正是我们在外界无法访问函数内定义的变量的原因。也就是说，只有在函数执行时，相关函数可以访问该变量，该变量在预编译阶段进行创建，在执行阶段进行激活，在函数执行完毕后，相关上下文被销毁。 闭包： 函数嵌套函数时，内层函数引用了外层函数作用域下的变量，并且内层函数在全局环境下可访问，就形成了闭包。 浏览器的垃圾清除 标记清除 引用计数","pubDate":"Tue, 15 Feb 2022 06:26:06 GMT","guid":"https://wangyx233.github.io/2022/02/15/[JS基础]执行/","category":"JavaScript"},{"title":"【读书】JavaScript高级程序设计","link":"https://wangyx233.github.io/2021/07/13/[读书]JavaScript高级程序设计/","description":"script标签defer vs async共同点：只对外部脚本有效，src=’xxx’不同： defer表明脚本立即下载，但是执行会推迟，在DOMContentLoaded之前执行。即加载无需等待，HTML5规定执行需要有序的。async表明脚本会并行下载，下载完立即执行，不保证执行的顺序。会在页面loaded执行前完成。类似 DOM 内通过createElement创建script标签(可配合rel=’preload’)。","pubDate":"Tue, 13 Jul 2021 03:21:58 GMT","guid":"https://wangyx233.github.io/2021/07/13/[读书]JavaScript高级程序设计/","category":"生活"},{"title":"浏览器の网络-HTTP","link":"https://wangyx233.github.io/2021/06/30/浏览器の网络-HTTP/","description":"HTTPHTTP是应用层协议","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/浏览器の网络-HTTP/","category":"网络"},{"title":"HTTPS","link":"https://wangyx233.github.io/2021/06/30/安全了-HTTPS/","description":"HTTP的明文传输带来的问题，可能在传输过程中信息被窃取或者篡改，伪造，容易发生中间人攻击。HTTP -&gt; 安全层（SSL/TLS） -&gt; 传输层 -&gt; 网络层，其中安全层的作用是对发送的HTTP请求进行加密操作，以及对接收到的HTTP请求进行解密操作。 对称加密，非对称加密的优缺点，得到一个对称加密和非对称加密搭配使用的方式。传输过程中使用对称加密传输数据，而对称加密所需的密钥则通过非对称加密传输。搭配数字证书，数字证书是向浏览器方明确服务器方的身份，以及提供公钥。 浏览器端向服务端发送请求，包含对称加密套件列表 + 非对称加密套件列表 + client_random 服务端接到请求后，向浏览器端发送选择的，对称加密套件 + 非对称加密套件 + service_random + 数字证书 浏览器端接到响应，先验证数字证书，然后 client_random + service_random 生成 pre_master，用公钥加密pre_master，再加浏览器确认，发送到服务端 服务端接到请求先用私钥解密，得到pre_master，服务器发送确认 开始 client_random + service_random + premaster 生成的 master secret 加密的数据进行传输。","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/安全了-HTTPS/","category":"网络"},{"title":"同源策略与Web安全","link":"https://wangyx233.github.io/2021/06/30/web安全/","description":"安全问题Web页面安全，浏览器网络安全，浏览器安全 同源策略 Same-origin policy什么是同源？ 两个URL的协议、域名、端口都相同，则这两个URL同源 12http://www.yixuanwang.cn/?article=1http://www.yixuanwang.cn/?article=0 相同源之间可以互相访问资源和操作DOM结点的，不同源之间会有一定安全策略的制约，即为同源策略。不同源之间不能对DOM对象进行读写操作，不能读取Cookie、LocalStorage等数据，也不能通过XMLHttpRequest传递数据。如果想做以上操作怎么办？ 页面引用第三方资源可能会导致XSS攻击 -&gt; CSP 内容安全策略，让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码 安全地进行数据传递，CORS跨域资源共享 安全地相互操作DOM，跨文档消息机制window.postMessage XSS攻击-Cross Site Scripting 跨站脚本是什么XSS是指攻击者向HTML，DOM中注入恶意脚本，从而在用户浏览页面时通过恶意注入的脚本对用户实施攻击。可能会获取用户的Cookies，监控用户的行为“addEventListener”，也可能通过DOM伪造假的登录窗口，也可能生成浮窗广告，影响体验。 存储型XSS，恶意脚本插入网站的数据库里，再读取的时候会进行攻击。 反射型 XSS 攻击，在请求连接里注入恶意脚本，将请求提交给Web服务器，Web服务器收到请求，又将恶意代码反射给了浏览器 基于 DOM 的 XSS 攻击，不涉及服务器，通过页面劫持等方法将恶意脚本注入页面，修改web页面 怎么办 服务器对输入数据进行转码 充分利用CSP(Content-Security-Policy)，限制其他源的资源下载，禁止向第三方域提交数据，禁止执行内联脚本和未授权的脚本，即使上报 使用 HttpOnly 属性，HTTP的响应头，set-cookied: xxxx ; HttpOnly。只能通过HTTP请求使用，无法通过document.cookie获取还可以通过添加验证码的方式防止脚本冒充用户进行提交危险操作，对于一些不信任的输入，还可以限制其输入长度 npm xss库 CSRF攻击：陌生链接不要随便点是什么CSRF(Cross-site request forgery)，跨站请求伪造。攻击者引诱用户打开恶意网站，利用用户的登录状态，发起跨站请求做坏事。 自动发起GET请求，如将请求接口隐藏在图片中： 1&lt;img src=&quot;http://www.abc.cn/sendcoin?user=xxx&amp;number=10&quot;/&gt; 自动发起POST请求，一个隐藏的表单 引诱用户点击链接 怎么办 对于响应头的Cookie设置，SameSite可以设置Strict、Lax 和 None 验证请求的来源站点，通过Origin，Referer判断 设置CSRF Token，每次请求都携带该token进行验证","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/web安全/","category":"安全"},{"title":"【读书】小狗钱钱","link":"https://wangyx233.github.io/2021/06/30/[读书]小狗钱钱/","description":"如何实现梦想 要有自信！！！（建立自信，最好每天写成功日记） 72小时法则：当你决定做一件事的时候，必须在72小时内开始行动，不然很有可能再也不会做（上升到本人，大概需要在72秒内就做吧🐶） 不要抱怨 一定要坚持！！！养成习惯 幸运是充分准备加努力工作的结果 利用碎片化时间，珍惜时间，不要等待。每天十分钟，可以带来真正的改变 要勇敢 如何赚💰","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[读书]小狗钱钱/","category":"生活"},{"title":"【网络】前端开发中的HTTP","link":"https://wangyx233.github.io/2021/06/30/[网络]http/","description":"知识点 HTTP的缓存机制！！！重要 状态码 headers Restful API 状态码 分类 1xx 服务器收到请求 2xx 请求成功 3xx 重定向 4xx 客户端错误 5xx 服务端错误 常见 200 成功 301 永久重定向（配合location新地址，浏览器自动处理，下次会直接访问新的地址） 302 临时重定向（配合location新地址，浏览器自动处理，下次还会访问旧的地址）短网址，百度之类的搜索引擎的链接，why？ 304 资源未修改，缓存 注 307 internal redirect 403 没有权限 404 not found 500 服务器错误 502 504 网关超时，服务器内部 协议规范 Restful API API设计方法，把每个URL当做唯一的资源标识。如何设计一个资源？ 尽量不用url参数，如：/api/list?page=2 -&gt; /api/list/2 用method表示操作类型，POST,PATCH/PUT,DELETE,GET HTTP Headers 常见的Request Headers Accept 浏览器可以的数据格式 Accept-Encoding 浏览器可支持的压缩算法，如：gzip Accept-Language 浏览器支持的语言 Connection: keep-alive 保持TCP连接 Cookie Host User-Agent Content-Type 发送数据格式，如：application/json Authorization token验证 常见的Response Headers Content-Type 发送数据格式，如：application/json Content-Length 返回数据的大小，多少字节 Content-Encoding 返回数据的压缩算法，如：gzip Set-Cookie 服务端改cookie 自定义headers 用于缓存的headers HTTP缓存机制什么是缓存？为什么需要缓存？哪些资源可以被缓存-&gt;js/css/img静态资源和业务数据，html不能被缓存 页面加载更快，网络请求慢，减少网络请求的体积和数量，也是不稳定的 强制缓存服务端控制什么资源可以缓存，通过Response Headers中的cache-control 控制过期时间Cache-Control的值 max-age=86400(秒) no-cache 不用强制缓存，去服务端处理 no-store 不用强制缓存，也不用服务器缓存 private 允许用户客户端做缓存 public 允许中间如cdnExpires也是做缓存过期控制的，已被Cache-Control代替，以Cache-Control为主 协商缓存(对比缓存)服务端缓存策略，服务端来判断是否用缓存，即服务端判断客户端资源是否和服务端资源一样。如果一致则返回304，否则返回200和最新资源注意：资源标识 Response Headers里Last-Modified：资源最后修改时间(精确到秒级)，Etag资源的唯一标识(优先级高，资源被重复生成而内容不变) 再次请求的时候，If-Modified-Since: Last-Modified时间(Request Headers里) Etag，If-None-Match: Etag的值(Request Headers里)两者共存会优先使用Etag，Last-Modified只能精确到秒级 整个缓存过程！ 刷新页面 正常操作：浏览器url，跳转，前进后退等。 强制缓存有效，协商缓存有效 手动刷新，F5，刷新按钮 强制缓存失效，协商缓存有效 强制刷新 强制缓存失效，协商缓存失效","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[网络]http/","category":"网络"},{"title":"【版本管理】gitの世界","link":"https://wangyx233.github.io/2021/06/30/[版本管理]git的世界/","description":"配置1234git --versiongit config --global user.name &apos;xxx&apos;git config --global user.email &apos;xxx&apos;git config --list local global system 工作区/暂存区1git add -u // 已经被管理的文件 update 重命名，git的命令类比linux的系统命令，可直接git commit 12git rm xxx // 删除git mv old new git log 123git log --onelinegit log -n // 最近几次commitgit log -all --graph// 所有分支 git branch 12git branch -v // 本地分支git branch -av .git文件夹 HEAD 指向某个commit 12git checkout -b branch git diff HEAD HEAD^^ / HEAD~n config refs heads 分支 tags 里程碑 objectsblob文件对象 tree commit三者之间的关系只要文件的内容相同，在git里就是唯一的，和文件名没有关系加入暂存区的内容，才会再objects里面有体现commit -&gt; tree -&gt; blob12git cat-file -t xxx 看文件的类型git cat-file -p xxx 看内容 分离头指针 detached HEAD 没有经过某个分支做修改git checkout commit-id 开发后切换分支易丢失，会提示创建新分支git branch name commit-id在分支上做变更 branch 清理 123git branch -vgit branch -dgit branch -D 修改commit message 12git commit --amend // 最近一次commitgit rebase -i // 变基要修改的父commit，在为同步到远端，合并commit也可以实现 diff 1234git diff --cached //暂存区和HEAD的不同git diff // 工作区和暂存区的差异，不加参数是比较所有变动git diff -- filename filename filename git diff branch_name/commit-id/ branch_name/commit-id -- filename 1234git reset HEAD // 暂存区恢复到工作区git reset HEAD -- filenamegit reset --hard/--soft commit-idgit checkout -- filename // 工作区内容恢复到暂存区一样 stash 1234git stashgit stash listgit stash pop // stash git stash apply // stash 列表内的信息还在 .gitignore 12xxx/ // xxx的文件夹会被忽略xxx // xxx的文件和文件夹都会忽略 备份 哑协议：没有协议头 xxx/xx.git，看不到传输速度，速率没有智能协议高 智能协议：带协议头 &gt; file:///xxx/xxx.git12git clone --baregit remote add xxx.git 远端操作，fast-forwards，解决冲突，集成的分支不要做变基，注意fast-forwards 1234git fetchgit mergegit pullgit push git vs svn svn需要获取批准 权限问题，效率 可以托管代码，协同合作 工作流 rerere 123456git config --local rerere.enabled truegit merge // 解决冲突git addgit commitgit resetgit rebase","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[版本管理]git的世界/","category":"git"},{"title":"【必备】开发环境 & 运行环境","link":"https://wangyx233.github.io/2021/06/30/[开发]工具/","description":"开发环境 git 调试工具 抓包 webpack babel linux gitgit show commit-id ~/.ssh 抓包 同一个局域网下 手机配电脑的代理 设置ssh代理proxy 重定向map webpack &amp; babel ES6模块化 export {aaa,bbb,ccc}; import {aaa,bbb,ccc} from ‘xxx’ export default {aaa}; import a from ‘xxx’ ES6语法 压缩，整合代码，配置 常用linux命令- ls -a - mv old new 修改文件名 - cp name copyname - cat head tail - grep 查找 - vimtutor运行环境 页面加载过程 性能优化 安全 页面加载过程 从输入url到渲染出页面的整个过程 window.onload vs DOMContentLoaded 加载资源形式 加载过程 DNS解析：域名-&gt;IP地址 浏览器根据IP地址向服务器发起http请求 服务器处理请求，并返回给浏览器 渲染过程 DOM树 CSSOM DOM + CSSOM -&gt; Render Tree 根据Render Tree渲染页面 遇到 script 则暂停渲染，优先加载js文件，执行js 代码 直到渲染完 css文件为什么要放在head中？避免重复渲染js为什么要放在body最后？不阻塞加载 load // 页面全部加载完，整个资源加载完，比如img，视频，iframe都加载完DOMContentLoaded // DOM渲染完即可执行window.load 性能优化原则 减少CPU计算量，减少网络加载耗时 多使用缓存 - 空间换时间（Chrome浏览器，简洁，每个标签页一个进程） 从何入手 加载更快 减少资源体积：压缩代码（JS，CSS，图片…）服务器端gzip，三分之一 减少访问次数：合并代码，SSR服务端渲染，缓存(文件内容不变，hash不变) 使用更快的网络，CDN 渲染更快 css放在head，js放在body最后 尽早的执行js，用DOMContentLoaded 懒加载，图片懒加载 对DOM查询进行缓存 频繁DOM操作合并一起 节流 throttle、防抖 debounce 防抖 debounce 两个事件之间的时间间隔超过time才会执行，没超过间隔的任务都会取消。即在事件结束和暂停的时候触发，间断理解 12345678910function debounce(fn, delay = 500) &#123; let timer = null; return function () &#123; if (timer) clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); timer = null; &#125;, delay); &#125;&#125; 节流 throttle 无论触发速率多快，都保持一个频率触发。比如，拖拽时间，无论拖拽的多快都会每隔100ms触发一次。 12345678910function throttle(fn, delay = 100) &#123; let timer = null; return function () &#123; if (timer) return; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); timer = null; &#125;, delay); &#125;&#125;","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[开发]工具/","category":"工具"},{"title":"【工程化】Webpack","link":"https://wangyx233.github.io/2021/06/30/[工程化]Webpack/","description":"历史为什么需要 转换ES6 转换JSX 压缩混淆 CSS预处理器 图片压缩… gulp 任务打包器，文件流的概念，每一步构建的结果不会存本地磁盘，而是存在内存里，可以加快打包速度。 webpack vs gulp 社区生态丰富，配置灵活，插件化扩展，官方更新迭代快；module builder vs task runner 简介配置文件，默认：webpack.config.js可以使用 webpack –config xxx 指定配置文件 webpackwebpack-cli 核心概念 entry：模块依赖打包的入口，单页应用为字符串，多页应用为{key: value} output：将编译的文件输出到磁盘，通过filename [xxx]区别多入口多输出，输出的文件名称，为entry设置的key名 loaders！webpack开箱即用的只有js和json两种类型，所以需要通过loaders去支持其他文件类型并转成有效的模块，并且可以加到依赖图里loaders其实是个函数，接受源文件为参数，返回转换的结果。链式调用的，从右向左执行比如： babel-loader css-loader less-loader file-loader plugins，增强webpack的功能，对打包文件的优化，资源的管理，环境变量的注入。作用于整个构建过程 CommonsChunkPlugin HtmlWebpackPlugin UglifyjsWebpackPlugin mode: 指定打包的环境，production，development 12345678910111213const path = require(&apos;path&apos;);module.exports = &#123; entry: &#123; app: &apos;xxx&apos;, admin: &apos;sss&apos; &#125;, output: &#123; filename: &apos;[xxx].js&apos;, path: &apos;&apos; &#125; mode: &apos;production&apos;&#125; 文件监听的原理分析轮询地判断文件最后编辑时间是否变化，某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等aggregateTimeout 12345watchOptions: &#123; ignored: /node_modules/, aggregateTimeout: 300, // 监听到变化后，多长时间后再去执行 poll: 1000 // 1s询问多少次&#125; 热更新webpack compileHMR Server -&gt; HMR Runtime，会被注入到浏览器的bundle.js里面，浏览器里的bundle.js 就可以建立连接websocket，更新变化Bundle Server -&gt; 浏览器访问 localhost 两个阶段，启动阶段 文件系统 -&gt; webpack compile -&gt; Bundle Server 变更阶段，文件系统 -&gt; webpack compile -&gt; HMR Server -&gt; HMR Runtime （json形式） 文件指纹 - 打包后输出的文件名后缀怎样生成的？ hash，和整个项目的构建有关，只要项目文件有修改，整个项目构建的hash就会更改 chunkhash，和webpack打包的chunk有关，不同的entry会生成不同的chunkhash contenthash，根据文件内容来生成hash，文件内容不变，则contenthash不变 ps. file-loader 里面的hash也是指contenthash的意思。style-loader是将css代码插入到head中,MiniCssExtractPlugin是将css文件提取出独立的文件，二者互斥 清理构建目录 - clean-webpack-plugin css 属性前缀 - autoprefixer，postcss-loader px rem 相互转换 rem: font-size of the root element。px2rem-loader 静态资源内联，raw-loader。读取文件的内容，然后把文件的内容插入到对应的位置 多页面打包，MPA - 借助 glob glob.sync(path.join(__dirname, ‘./src/*/index.js’))动态获取entry以及HtmlWebpackPlugin source-map定位到源代码，开发环境中用，线上环境关闭cheap-source-map , inline-source-map，eval 不会有单独的map文件 提取公共资源 HtmlWebpackExternalsPlugin，放cdn的地址 SplitChunkPlugin Tree Shaking设置mode: production,是默认开启的 原理：DCE（Dead Code Elimination）代码不可到达的，不能执行；执行结果不会使用；代码只写不用 利用ES6模块的特点，只能作为模块顶部的语句出现；import的模块名只能是字符串常量；import binding是不可变的 uglify阶段删除无用代码 具有副作用的代码，tree shaking会失效 副作用：一个函数会、或者可能会对函数外部变量产生影响的行为 Scope hoisting问题： 大量函数闭包包裹代码，导致体积增大 运行代码时创建的函数作用域多，内存开销大 模块转换，一个闭包包裹；import被转换成__webpack_require 代码分割，动态import，通过JSONP实现 抽离相同代码到一个共享块 脚本懒加载，初始下载的代码更小","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[工程化]Webpack/","category":"Webpack"},{"title":"【生活】如果有购房需求","link":"https://wangyx233.github.io/2021/06/30/[人生]购房/","description":"房产经纪人-一度觉得自己可以成为 注意事项不论二手还是新房都有一些共通之处，最终要的是要多学，多看，多比较 平时买个几块钱的菜都要比来比去，怎么到了几十上百万的🏡的时候就比买白菜还随意呢？ 现在资讯无比发达，所以在下手之前可以通过各种大v，公众号，或者直播了解一些房产的基本信息。 外部因素 学区属性是否刚需 交通地铁 邻居 车位 流通性 … 内部因素 楼层，楼高 采光，遮挡 隔音，噪音，是否临街 下水，独立下水 供暖，物业 窗户 … 可以多实地看几套二手房，看房又不💰，实地感受一下各种因素的影响，以及自己的接受度 二手房尤其要注意🏡的流通性，大概率5-8年会换房，所以中介费，还有税费要注意 新房封顶以后才能批贷，这点要注意。","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[人生]购房/","category":"生活"},{"title":"【生活】如果有保险需求","link":"https://wangyx233.github.io/2021/06/30/[人生]家庭保险配置/","description":"人生中总有各种事情发生，鉴于马上要背上巨额贷款，为了一定程度上抵御风险，不得不看起了保险。基于自己浅薄的研究，总结了几大类产品： 看病(尤其是大病)： 百万医疗 重疾 GG: 寿险 意外险 如果不考虑太多的，平时缴纳的社保，以及公司的补充医疗基本能够覆盖平时的看病就医。所以保险里的医疗部分一般主要cover大病系列，百万医疗是可以报销治疗过程中的费用。而重疾则是一次性给付，确诊了就赔付，弥补无法搬砖导致的损失，支撑生活。 百万医疗，支付宝上可以入好医保6/20年版本的，年轻时刻几百左右。 重疾，是真的贵。2021/2月要执行新规，先观望吧，之前入的话，能择优理赔的更好。 意外和馅饼也不知道哪个先来。所以如果为了买个安心，用不到当然更好，这个时候就祭出了寿险。如果不小心GG，还会留下一部分💰，保证家里的继续。 寿险，选个性价比高的就行，最好用不到，所以选个自己能接受的价格，保自己想要的额度就好。目前只看了大麦2021，擎天柱5号…，如果是夫妻双方都苦苦支撑起了一个家，还有大麦甜蜜家2021这种项目。 意外，如果配置了其他的寿险，医疗啥的，也可以不用care这个。也不需要买长期的，即买即用，一年的价格也便宜，比如大护甲xxx。 如果要买保险的话，一定要仔细看下投保须知和除外责任，尽量减少踩太多坑坑坑。jin se太难了 当然一切都看开，其实无所畏惧！","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[人生]家庭保险配置/","category":"生活"},{"title":"【WebAPI】BOM","link":"https://wangyx233.github.io/2021/06/30/[WebAPI]BOM/","description":"BOM -&gt; Browser Object Model 如何识别浏览器的类型 分别拆解url各部分 知识点 navigator screen location history123456789101112131415161718// 1. navigatorconst ua = navigator.userAgent;// 2. screenconst width = screen.width;const height = screen.height;// 3. locationlocation.hreflocation.protocollocation.pathnamelocation.hashlocation.searchlocation.host// 4. historyhistory.back();history.forwards();","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[WebAPI]BOM/","category":"JavaScript"},{"title":"【React】Virtual DOM","link":"https://wangyx233.github.io/2021/06/30/[React]虚拟DOM/","description":"What？Virtual DOM本质上是JS 和 DOM 之间的一个映射缓存，是能够描述DOM结构及其属性的JS对象。 虚拟DOM是JS对象 虚拟DOM是对真实DOM的描述 挂载阶段，根据JSX的描述，构建出虚拟DOM，然后通过ReactDOM.render实现虚拟DOM到真实DOM的映射更新阶段，页面的变化在作用于真实DOM之前，会先作用于虚拟DOM Why？ jQuery解决DOM API 不好使的问题。还解决浏览器兼容，链式API调用，插件扩展 模板引擎，只关心数据，不关心DOM细节。操作真实DOM的范围过大、频率过高，但思想是数据驱动视图 虚拟DOM的点不在性能。虚拟DOM有没有借鉴模板引擎无法考证，但是思想上有一定的递进关系。JSX不是模板，而是JS的一个体验像模板的扩展语法糖，然后增加了个虚拟DOM的缓存层。 差量更新。即当DOM操作比较频繁时，会将前后两次的DOM树变化进行对比diff，定位到需要更新的部分，生成一个“补丁集”，把“补丁”patch打在需要更新的那部分真实DOM上，就可以实现差量更新批量更新。batch函数处理，把短时间内的多次DOM操作合成一个次更新，即把收集的多个补丁集暂存到队列中，再讲最终结果交给渲染函数，实现DOM的集中化批量更新。 研发体验/研发效率。虚拟DOM思想是数据驱动视图，前端声明式编程。 性能不是卖点。性能还不错，性能量化不能一概而论只看一个指标，得看实际情况。DOM操作量级有关 价值？跨平台，一次编码多次应用。虚拟DOM是对实际渲染内容的一次抽象 规避xss攻击 缺点： 内存占用高，虚拟DOM，object 无法进行极致优化。如Google Earth How?调和Reconciliation 和 Diff算法 调和是将虚拟DOM映射到真实DOM的过程。Diff算法只是其中的一个小部分，深度优先遍历 React 15为代表的“栈调和”传统的递归比较两棵树结构的不同算法复杂度是O(n^3)，这个复杂度显然不能令人接受，所以React中做了什么呢，将复杂度转换成O(n) Diff算法性能突破的关键点是“分层比较”分层比较其实是分层递归比较，所以“同层级操作”是主流，只针对相同层级的节点进行比较，如果是跨层级的节点操作，其实是对应这销毁和重建的过程，尽量保持DOM节点的稳定性。 类型一致的节点才有继续Diff的必要根据主要“矛盾”类型不一致的节点，直接放弃比较，原地替换旧的节点。 key属性的设置，可以尽可能重用同一层级内的节点key主要解决的是同一层级下节点的重用问题。设置key的元素可以避免不必要的销毁和重建，只是调整顺序排列。 注：作为一个节点的唯一标识，使用key之前，保证key的唯一和稳定。大致过程可以描述为树对比、组件对比、元素对比总结：栈调和机制下的Diff算法，其实是树的深度优先遍历过程。这个过程是同步的过程，不可被打断。Stack Reconciler 需要的时间越长，意味着JS线程将霸占主线程的时间越长。进而导致会出现渲染卡死、交互无响应的现象。 React 16以来的“Fiber调和”Fiber：纤程，对渲染过程进行更加精细的控制。是Fiber树结构的节点单位，也就是React 16下的“虚拟DOM”,并且Fiber节点保存了组件需要更新的状态和副作用。 可中断 可恢复 优先级 Better？ 避免跨层级节点移动 设置唯一的key，尽量减少组件层级 设置shouldComponentUpdate 或者 React.pureComponet 减少 diff 次数","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[React]虚拟DOM/","category":"React"},{"title":"【React】生命周期","link":"https://wangyx233.github.io/2021/06/30/[React]生命周期/","description":"React 15 Mounting 阶段：组件的初始化渲染在组件一生中仅会发生一次。组件初始化，然后被渲染到真实的 DOM 中，完成“首次渲染”。render 不会操作真实的 DOM，真实 DOM 的渲染工作，在挂载阶段是由 ReactDOM.render 来承接的。componentDidMount 在渲染后触发，此时真实的 DOM 已经挂载，可以进行数据请求，初始化等操作。 Updating 阶段：组件的更新 父组件更新触发的更新。componentReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的 组件调用 setState 触发更新。 shouldComponentUpdate 决定组件的 re-render Unmounting 阶段：组件的卸载。 组件被移除了，或者设置了 key，在 render 过程中发现 key 改变了 React 16React 16.4","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[React]生命周期/","category":"React"},{"title":"【React】源码从入门到跑路","link":"https://wangyx233.github.io/2021/06/30/[React]源码从入门到跑路/","description":"event 事件为什么需要bind(this) 对于class内普通定义的触发函数需要bind this，而使用静态方法定义则可以不用绑定class Test { constructor(props) { this.normalFun = this.normalFun.bind(this) // 只执行一次 } normalFun() {} staticFun = () =&gt; {} eventFun = event =&gt; {} // 追加的event参数 render() { return &lt;div onClick={this.staticFun}&gt;&lt;/div&gt; } } 由于this指向的问题，如果普通模式不bind this的话，此时this指向为undefined，而静态方法的this指向当前实例 如果要bind的话，bind this 的位置写在什么地方合适呢？和执行的次数有关，性能优化小点 event 参数，不是原生的event，是组合事件通过event.proto.constructor区分，React的event是组合事件(SyntheticEvent)，原生的为MouseEvent。通过nativeEvent获取原生事件event.target,event.currentTarget vs event.nativeEvent.target 触发的 event.nativeEvent.currentTarget 绑定的document，React 17之前。自定义参数，最后会追加一个参数是event 区别 vue ：原生的事件，绑定在当前元素上react：不是原生的事件，是组合事件SyntheticEvent模拟DOM事件所有能力，react 17 之前绑定在document，之后当前元素 表单 受控组件，类似双向数据绑定 非受控组件propTypes 类型检查 component.propTypes 父组件子组件通讯 传值 list = {xxx} 传函数，父组件控制数据，数据提升 cFun = {xxx} setState 不可变值 可能是异步 可能会被合并 可能是同步","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[React]源码从入门到跑路/","category":"React"},{"title":"【React】数据交互","link":"https://wangyx233.github.io/2021/06/30/[React]数据交互/","description":"React 的核心特征是“数据驱动视图” 1UI = render(data) 基于 props 的单向数据流 props：组件从概念上类似与 JavaScript 函数，它接受任意的入参(props)并返回用于描述页面展示内容的 React 元素。 所谓单向数据流，指的就是当前组件的 state 以 props 的形式流动时，只能流向组件树中比自己层级更低的组件。 比如在父-子组件这种嵌套关系中，只能由父组件传 props 给子组件，而不能反过来。 基于 props 传参这种形式，我们可以轻松实现父-子通信、子-父通信和兄弟组件通信。","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[React]数据交互/","category":"React"},{"title":"【React】事件系统","link":"https://wangyx233.github.io/2021/06/30/[React]事件/","description":"DOM事件流 事件捕获 目标阶段 事件冒泡 事件委托/事件代理 把多个子元素的同一类型的监听逻辑，合并到父元素上通过一个监听函数来管理的行为，就是事件委托。e.target 这个属性，指的是触发事件的具体目标，记录着事件的源头。 React事件系统合成事件 当事件在具体的DOM节点上被触发后，最终都会冒泡到document(或者ReactDOM.render绑定的元素)，document上所绑定的统一事件处理程序会将事件分发给具体的组件实例。 合成事件是React自定义的事件对象，符合W3C规范，在底层抹平了不同浏览器的差异，在上层向开发者暴露统一的，稳定的，与DOM原生事件相同的事件接口。不必关注兼容问题，专注业务开发。合成事件不是原生的事件，但是它保存了原生事件的引用，e.nativeEvent React 事件的命名采用小驼峰式（camelCase），而不是纯小写。使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault比如： 1234handleClick() &#123; console.log(&apos;this is:&apos;, this);&#125;&lt;div onClick=&#123;()=&gt;this.handleClick()&#125;&gt;&lt;/div&gt;","pubDate":"Wed, 30 Jun 2021 02:45:57 GMT","guid":"https://wangyx233.github.io/2021/06/30/[React]事件/","category":"React"}]}