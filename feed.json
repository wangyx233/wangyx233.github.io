{"title":"Hexo","description":null,"language":null,"link":"https://wangyx233.github.io","pubDate":"Wed, 18 Nov 2020 05:39:16 GMT","lastBuildDate":"Wed, 30 Jun 2021 02:27:02 GMT","generator":"hexo-generator-json-feed","webMaster":"Xuan","items":[{"title":"<浏览器>浏览器原理初识","link":"https://wangyx233.github.io/2020/11/18/[浏览器]浏览器原理初识/","description":"线程VS进程一个进程就是一个程序的运行实例。启动一个程序时，浏览器会开辟一块内存用于存放代码，数据和执行任务的主线程。 进程与线程之间的关系，对于一个进程，其中的线程可以共享进程中的数据，但是一个线程抛出错误，会影响整体进程。对于操作系统中的进程来言，每个进程之间是相互隔离的，每个进程只能访问自己占有的数据，如果一个进程崩溃了或者挂起了，不会影响其他进程。当一个进程关闭时，操作系统会收回它所有占用的内存。 浏览器变更历史：单线程-&gt;多线程-&gt;SOA形式（Services Oriented Architecture，面向服务架构）单线程浏览器：不稳定，不安全，不流畅，主要是插件和页面脚本，崩溃的心情多线程：以Chrome浏览器为例子，一个浏览器主线程，一个GPU进程，一个网络进程，多个渲染进程Render Process和多个插件进程Plugin Process。会导致资源占用高，复杂的体系结构 网络TCPTCP协议，保证页面文件被完整的送达浏览器FP First Paint，页面加载到首次开始绘制的时间。网络加载速度用户数据包协议（User Datagram Protocol）”传输层，UDP头，端口号。UDP协议不能知道发送的数据能否到达目的地，但是传输速度快，不那么严格关注数据严格性的领域可以用，如在线视频IP(Internet Protocol)协议，访问任何网站都是从一台计算机向另一台请求信息。数据当然通过网络层进行传输了，IP头地址和数据信息。TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 对于数据丢失的问题，TCP提供了重传机制。 TCP引入了数据包排序机制，可以把乱序的数据包合成一个完整的文件。TCP头不仅包含了目的端口号，源端口号，还包含了排序的序列号。一个完整的TCP连接的生命周期包括，“建立连接”、“传输数据”、“断开连接”三个阶段。即三次握手建立连接，数据包校验机制，四次挥手断开连接。 从发送第一个数据包开始，在一定时间没有接收到服务端的反馈则即为丢包，触发重发机制。并且别分成的小数据包，通过TCP头的序列号进行排序得到完整的数据。 HTTP请求流程允许浏览器向服务端发起请求的一种协议，让我们来看一下浏览器端发送HTTP请求的流程。 构建请求 查找缓存 准备IP和端口，DNS解析 TCP链接，Chrome同一个域名最多只能建6个TCP连接 HTTP请求Connection: Keep-Alive，会保持TCP连接，省去下次请求时建立连接的时间，提升加载速度 服务器端 返回请求 断开连接 重定向，重定向的地址在Location里面 为什么很多站点第二次打开速度很快 DNS缓存 浏览器资源缓存Cache-Control: Max-age=2000(s)如果资源过期了，浏览器会继续发出请求，并且在Http的请求头中加入：If-None-Match:”实体标签”ETag，If-Modified-Since:Date可以和Last-Modified服务器响应首部配合工作服务器会根据这个值判断资源是否有更新新鲜度校验，如果没有更新，则返回304，告诉浏览器这个资源可以继续使用登录状态，可以用Cookie实现，或者header头里的Authorization PS: 3xx状态码 300 Multiple Choices。内容协商，客户端协商，服务端协商，透明协商。中英文网站切换 301 Moved Permanently。永久重定向Cache-Control: no-cache，与服务器进行新鲜度验证前不使用缓存内容。Cache-Control: no-store，删除缓存的文档","pubDate":"Wed, 18 Nov 2020 05:39:16 GMT","guid":"https://wangyx233.github.io/2020/11/18/[浏览器]浏览器原理初识/","category":"JavaScript,浏览器"},{"title":"JS基础回顾","link":"https://wangyx233.github.io/2020/10/16/基础回顾/","description":"内置类型加上 ES6 新加的 Symbol，共 7 种，分别为 String， Number， Boolean， Object， Undefined， Null。分为基本数据类型(6)和 Object。对于基本数据类型，通过字面量的方式声明，类型依旧是字面量，只有在使用的时候才会转换为对应的类型。 123456typeof() 特别： Symbol-&gt;symbol 函数-&gt;function, null-&gt;object。历史原因对象以000开头，而null恰好为全零通过Object.prototype.toString.call()可判断准确的类型[object Type] PS: Symbol 类型(唯一的值)通过 Symbol()定义，定义后的值不相等，System.prototype.description 为定义时 Symbol(‘xxx’)的标识。使用场景：作为对象的属性 1234567let sym = Symbol();let a = &#123;&#125;;a[sym] = &apos;symbol&apos;;a = &#123; [sym]: &apos;symbol&apos;&#125;Object.defineProperty(a, sym, &#123;value: &apos;symbol&apos;&#125;) 注： 不能用.运算符，.运算符会直接作为字符串取值。 Symbol 作为属性名，不会出现在 for…in, for…of 中，也不会出现在 Object.keys(), Object.getOwnPropertyNames()、JSON.stringify()里。 但也不是私有属性，Object.getOwnPropertySymbols，可以获取指定对象的所有 Symbol 属性名。 新的 API:Reflect.ownKeys 可以返回所有类型的键名，包括常规键名和 Symbol 键名。 Symbol.for(description)若没有则会创建一个，若存在则共用一个 symbol 值。 Symbol.keyFor(sym)返回一个已登记即 Symbol.for 的 Symbol 类型值的 key 其他方法可在需要是再查找。 类型转换转 Boolean 类型。在条件判断时，除了 undefined， null， false， NaN， ‘’， 0， -0，其他所有值都转为 true，包括所有对象对象在转换基本类型时，首先优先级最高的是，Symbol.toPrimitive，然后会调用 valueOf 然后调用 toString。注：‘a’ + + ‘b’ – ‘aNaN’ 1234x==y 比较undefined == null // true[] == true // false[] == ![] // true [].toString() -&gt; &apos;&apos;，!取反运算符的优先级会高于==， ![] -》 false undefined == null，结果是 true。且它俩与所有其他值比较的结果都是 false。 String == Boolean，需要两个操作数同时转为 Number。 String/Boolean == Number，需要 String/Boolean 转为 Number。 Object == Primitive，需要 Object 转为 Primitive(具体通过 valueOf 和 toString 方法)。 原型","pubDate":"Fri, 16 Oct 2020 02:03:15 GMT","guid":"https://wangyx233.github.io/2020/10/16/基础回顾/","category":""},{"title":"<JS Review>类型检测","link":"https://wangyx233.github.io/2020/10/16/[重温JS]类型判断/","description":"来自 null 的拷问？我是谁，我在哪儿 [Symbol.toStringTag] 基本数据类型在内存中占用固定大小的内存空间，因此被保存在栈内存中。引用类型，保存在堆内存中。 typeof说明确什么能够检测，什么不太行。typeof 是检测基本数据类型的利器，number，string，boolean，undefined。null，object 都只会返回 object；function 返回 function instanceof通过原型链来判断：variable instanceof constructor 判断是什么类型的对象，结果返回 true or false。基础类型判断返回 false 12345class PrimitiveString &#123; static [Symbol.hasInstance](x) &#123; return typeof x === &apos;string&apos; &#125;&#125;","pubDate":"Fri, 16 Oct 2020 02:03:15 GMT","guid":"https://wangyx233.github.io/2020/10/16/[重温JS]类型判断/","category":"JavaScript,typeof,instanceof,Object.prototype.toString.call()"},{"title":"<Linux>自动化部署从入门到放弃","link":"https://wangyx233.github.io/2020/09/25/[Linux]自动化部署从入门到放弃/","description":"node 安装，全局使用 yarn 安装 nginx 配置 vue 打包配置 github action Q&amp;A 查看服务器绑定域名，查 dns 用服务器 IP 反向解析域名 &gt; dig -x ip | nslookup WEB 服务器“一键”装机 1yum install git -y 123456789101112$ wget -c xxxxxxx$ tar -xvf xxxxxxx// 修改 ~/.profile# NodejsVERSION=v12.18.4DISTRO=linux-x64export PATH=/usr/local/lib/nodejs/node-$VERSION-$DISTRO/bin:\\$PATH. ~/.profile 1curl -o- -L https://yarnpkg.com/install.sh | bash 查找文件 find . -name ‘xxx’","pubDate":"Fri, 25 Sep 2020 07:15:54 GMT","guid":"https://wangyx233.github.io/2020/09/25/[Linux]自动化部署从入门到放弃/","category":"CI/CD"},{"title":"<重温JS>JS题目小试","link":"https://wangyx233.github.io/2020/09/25/[重温JS]JS题目小试/","description":"一、数组扁平化如何将一个多维数组变成一个一维数组，如： 12const arr = [1, [2, [3, [4, [5]]]]]// =&gt; [1,2,3,4,5] 看到数组扁平，第一想到的是 concat()，然后是递归，依次实现一番。 (1) 递归 1234567891011const res = [];const flat = arr =&gt; &#123; for (let i = 0; i &lt; arr.length; i++) &#123; if (Array.isArray(arr[i])) &#123; flat(arr[i]); &#125; else &#123; res.push(arr[i]); &#125; &#125;&#125;flat(arr); (2) reduce()配合 concat() 12const flat = arr =&gt; arr.reduce((temp, elem) =&gt; temp.concat(Array.isArray(elem) ? flat(elem) : elem), [])const res = flat(arr); (3) 内置 API，一顿操作，竟然忽略了 Js Array 的内置 api–flat()，按指定深度递归遍历数组，将所有元素与遍历的子数组中的元素合并为一个新数组返回。 12var newArray = arr.flat([depth])const res = arr.flat(Infinity); (4) 正则，另辟蹊径 12const res1 = JSON.stringify(arr).replace(/\\[|\\]/g, &apos;&apos;).split(&apos;,&apos;); // 原来数字变成了字符串const res2 = JSON.parse(`[$&#123;JSON.stringify(arr).replace(/\\[|\\]/g, &apos;&apos;)&#125;]`); 二、数组去重12const arr = [1, 17, &apos;1&apos;, 17, true, true, false, false, &apos;true&apos;, &apos;a&apos;, &#123;&#125;, &#123;&#125;];// =&gt; [1, &apos;1&apos;, 17, true, false, &apos;true&apos;, &apos;a&apos;, &#123;&#125;, &#123;&#125;] 看到数组去重，首先想到的是维护一个 object 用于记录出现过的值然后去掉重复，然后想到 filter 也可以实现类似的 (1) object 方法，普通 object 的 key 都会转换成 String 类型，所以可以借助 ES6 的 Map; 1234567891011const uniq = (arr) =&gt; &#123; const map = new Map(); const res = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (!map.has(arr[i])) &#123; map.set(arr[i], true); res.push(arr[i]); &#125; &#125; return res;&#125; (2) filter，过滤得到首次出现的元素。判断元素是否出现过还可以使用 arr.indexOf(elem) === -1 或者 arr.includes(elem) 1const res = arr.filter((elem, index) =&gt; arr.indexOf(elem) === index); (3) ES6 的 Set 数据结构，特性是每个元素都是唯一的，没有重复的值 12const res = [...new Set(arr)];[...new Set(&apos;ababbc&apos;)].join(&apos;&apos;); // &apos;abc&apos; // 两个有序数组[1,3,5]和[2,4,6]，写一个 mergeArr(a,b)合并两个数组，最终得到一个有序数组 _.get() 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？","pubDate":"Fri, 25 Sep 2020 03:23:35 GMT","guid":"https://wangyx233.github.io/2020/09/25/[重温JS]JS题目小试/","category":""},{"title":"<重温JS>数据类型及基本转换","link":"https://wangyx233.github.io/2020/07/28/重温学习/","description":"7 种语言类型undefined 是一个变量，而并非是一个关键字。老的浏览器中会是，ES5 以后就不是了。函数内部，对象的属性现在也是可以赋值的。if(typeof str === ‘undefined’){// 如果直接用 str === undefined, str 未声明的话可能会报错 not defined}String 用于表示文本数据。String 有最大长度是 2^53 - 1，字符串的 UTF16 编码，charAt、charCodeAt、length 等方法针对的都是 UTF16 编码，其实一个 utf16 单元代表一个字符，这俩数量是对应的，0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）Number 2^64-2^53+3NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字；Infinity，无穷大；-Infinity，负无穷大。还有 +0 -0，1/x 是 Infinity 还是 -Infinity双精度浮点数，有效的检测范围-0x1fffffffffffff 至 0x1fffffffffffff，浮点数运算精度的问题比较浮点数的准确方法是：与 JS 提供的最小精度比较 Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON Symbol，非字符串 key 的集合， 可以用于迭代器，Symbol.iterator 需要有 next，next 返回一个对象包括 value 和 done 12345678910111213var o = new Objecto[Symbol.iterator] = function() &#123; var v = 0 return &#123; next: function() &#123; return &#123; value: v++, done: v &gt; 10 &#125; &#125; &#125;&#125;;for(var v of o) console.log(v); // 0 1 2 3 ... 9 StringToNumber，字符串转换为数组支持进制转换，支持科学计数法，即用 Number()转换。不建议使用 parseInt，用的时候最好传入第二个参数。parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。都会忽略字符串前后的空格 Number进行十进制的转换，若字符串中带有非数字，都会变成 NaN，数字会正常转换若 0 开头则会被忽略。如果是对象，则先调用对象的 valueOf()方法，如果为 NaN，则再调用 toString() 1234567Number(&apos;&apos;) 0Number(true) 1Number(null) 0Number(undefined) NaNNumber(&apos;123aaa&apos;) NaNNumber([]) 0 -&gt; Number(&apos;&apos;)+string parseInt(string, radix)如果字符串以数字开头，则会忽略掉后续的非数字进行类型转换，否则返回 NaN，即找到字符串中的数字进行转换，若没有则为 NaN。以’0x’开头的十六进制也会转换，浮点数是向下取整，科学计数法也是不会正常转换的radix 不填或填 0 的时候默认为 10,取值范围为 2 ～ 36,radix 超出指定范围返回 NaN，若转换的数字大于 radio，也返回 NaN。 12345parseInt(&apos;123aaa&apos;) // 123parseInt([]) // NaN[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(parseInt) -&gt; [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map((elem, index) =&gt; parseInt(elem, index)) // [1, NaN, NaN][&apos;10&apos;,&apos;10&apos;,&apos;10&apos;,&apos;10&apos;,&apos;10&apos;].map(parseInt) // [10, NaN, 2, 3, 4][&apos;1.1&apos;, &apos;2&apos;, &apos;0.3&apos;].map(parseInt) // [1, NaN, 0] 数组的 toString(),会返回一个字符串的拼接；valueOf 还是返回数组。 NumberToString，正常。 装箱装箱，是指讲基本数据类型转化为对象，会频繁产生临时对象，在一些性能要求高的情况下，尽量避免。.运算符提供了装箱操作，所以基本类型通过.可以临时创建一个对象来调用对象的方法。Object.prototype.toString.call() 是可以准确识别对象对应的基本类型的方法，它比 instanceof(constructor) 更加准确，因为 JS 中没有方法可以更改私有的 class 属性。call 本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。 拆箱拆箱是把对象转换成基本数据类型。toPrimitive对象到 Number，String 的转换都遵循“先拆箱再转换”的原则。把对象-&gt;基本类型-&gt;对应的 String/Number 通过调用 valueOf()，toString()，没有则报错 TypeError。ES6 以后可以用 Symbol.toPrimitive 自定义转换覆盖以前的 valueOf()，toString()。 通过 new Number()声明的类型和直接用 Number()声明的类型不同，object 与 number 的区别。toString()还可以传入进制进行计算。valueOf 返回数字 toFixed(), toPrecision(num)向上取整, toExponential()科学计数法 String,chartAt(index),chartCodeAt(index) PS: 实现一个 parseInt()，Number()","pubDate":"Tue, 28 Jul 2020 08:40:39 GMT","guid":"https://wangyx233.github.io/2020/07/28/重温学习/","category":""},{"title":"<Work> 实践","link":"https://wangyx233.github.io/2020/07/28/[实践]性能优化二三事/","description":"Performance gzip 告警系统/埋点 图表优化，步骤，加载 其他的通用的方式：秒开率控制，toB 的没有这么多顾虑减少 http 请求 =&gt; JS,CSS 打包，小图片用 data-uri，svg。避免大型背景图利用缓存了解整个前端加载的过程。DNS 解析 =&gt; HTTP DNSTCP 链接三次握手。HTTP/TLS HTTP 2 / HTTPS 首先得评估下现状，要配合实际情况和业务情况进行性能优化，还得设计相关的指标和标准。最后对结果进行评估，有始有终哦 Tool开发体验，提升效率工具体系构建：版本统一，避免冲突。用一套统一的过程比较方便，从 init 到 dev 再到 public。重要的是构建时间，效率 持续性构建手动，自动。代码提交到仓库，自动发布到测试环境，自动发布系统。结构扫描 phantomjs，代码扫描 jshint，数据采集通过 performance API 检测性能，window.onerror 检测问题。组件化，兼容性，适配性：ppi，dpr。PWA组件化： 三大框架，web component，css houdini，不需要任何额外的运行时支持，就能在现代浏览器环境运行，也可以跟 HTML 无缝结合。适配： PPI:Pixel Per Inch 单位英寸像素，屏幕的显示质量。文字，media query DPR:Device Pixel Ratio 设备像素比例，物理像素与逻辑像素 px 之间的关系。viewport 控制缩放比 Resolution: 分辨率，屏幕区域的宽高所占像素数。用 vw，vh 解决 单页应用","pubDate":"Tue, 28 Jul 2020 08:40:39 GMT","guid":"https://wangyx233.github.io/2020/07/28/[实践]性能优化二三事/","category":"JavaScript"},{"title":"<JS Review>对象","link":"https://wangyx233.github.io/2020/07/28/[重温JS]对象/","description":"对象是什么？ 具有唯一标识，内存地址。 具有状态，属性。 具有行为，方法。 JS 的对象具有高度的动态性，可以在运行时对对象添加状态，修改行为。JS 中 Object 的定义，用 new 构造函数()、对象字面量 构造类的函数-&gt;类的构造函数，一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。用 this 创建对象，无需重新创建一个对象再返回。创建对象的方法，字面量，构造函数 new Object()，Object.create(proto, [propertiesObject])构造函数以大写字母开头，不需要借助 return，通过 this 对象配合 new 实现 12345678let a = &#123;name: &apos;xxx&apos;&#125;function Person(name) &#123; this.name = name;&#125;let b = new Person(&apos;xxx&apos;)Object.creat(&#123;name: &apos;xxx&apos;&#125;) 对象的属性类型JS 中，属性和方法其实都可以成为对象的属性。属性并不是简单的名称和值，可以用一组特征来描述属性，可分为数据属性和访问器(getter/setter)属性两类。 数据属性。这个就是常见的对象属性，具有以下特征： value writable：能否被赋值 enumerable：被 for in 枚举 configurable：被删除，或者改变特征值。false 时，writable 可从 true-&gt;false，但无法反向修改。enumerable 则不能修改，会报 TypeError: cannot redefine property。一旦设置为 false，cannot set true 访问器(getter/setter)属性。属性在读写的时候执行。 getter：get: () =&gt; {} || undifined setter: set: () =&gt; {} || undifined，两者成对出现，若不设置则为 undefined enumerable：被 for in 枚举 configurable：被删除，或者改变特征值ES5 以后：查看属性可用，Object.getOwnPropertyDescripter(object, ‘key’)设置属性的特性可用，Object.defineProperty(object, ‘key’, {})如果通过赋值的方式为属性赋值，则该属性的特征都默认为 true。但如果通过 defineProperty 赋值而不指定特性，则特征都默认为 false 123456789var o = &#123;a:1&#125;;o.b = 2;Object.getOwnPropertyDescripter(o, &apos;b&apos;);Object.defineProperty(o, &apos;c&apos;, &#123;value: 3&#125;);Object.getOwnPropertyDescripter(o, &apos;c&apos;);var o = &#123; get a() &#123; return &apos;a&apos; &#125; &#125;;Object.defineProperty(o, &apos;b&apos;, &#123;get: () =&gt; 2, set: (b) =&gt; console.log(b), configurable:true&#125;) 原型","pubDate":"Tue, 28 Jul 2020 08:40:39 GMT","guid":"https://wangyx233.github.io/2020/07/28/[重温JS]对象/","category":"JavaScript,Object,prototype"},{"title":"<CSS>Flex","link":"https://wangyx233.github.io/2020/07/22/[CSS]flex/","description":"flex: 1flex-shrinkflex-growflex-basis 标准盒模型：margin，border，padding，width(即 content area)ie 的 margin，width(border,padding , content area width) BFC(Block formatting context) 块级格式化上下文，W3C CSS2.1 规范中的一个概念。盒模型布局的 css 渲染模式，一个隔离的独立容器(独立渲染区域)通俗理解，BFC 像一个封闭的箱子，内部元素随意变换不会影响外部的布局。BFC 的形成条件：html浮动元素：float 除 none 以外的值绝对定位元素：position (absolute、fixed)display 为 inline-block、table-cells、flexoverflow 除了 visible 以外的值 (hidden、auto、scroll)解决的问题： 同一 BCF 下外边距 margin 重叠问题，不同 BFC 容器则不会重叠 用 BCF 容器清除浮动，包裹浮动的元素。(借助 overflow 触发) 阻止被浮动覆盖。(借助 overflow 触发) 用 bcf 实现两栏布局。(借助 overflow 触发)","pubDate":"Wed, 22 Jul 2020 07:22:47 GMT","guid":"https://wangyx233.github.io/2020/07/22/[CSS]flex/","category":"flex"},{"title":"<问题汇总>","link":"https://wangyx233.github.io/2020/07/22/[问题汇总]/","description":"1. cdn 是什么，干什么，哪些地方实现了加速2. 前端缓存策略，强缓存、协商缓存的优先级","pubDate":"Wed, 22 Jul 2020 07:04:52 GMT","guid":"https://wangyx233.github.io/2020/07/22/[问题汇总]/","category":"JavaScript"},{"title":"<知识点回顾>JS基础","link":"https://wangyx233.github.io/2020/07/17/[知识点回顾]/","description":"DOM 事件DOM 0 级， element.onClick = () =&gt; {};DOM 2 级，element.addEventListener(name, function(){}, capture = false) 冒泡事件事件模型分为捕获和冒泡，捕获是从 window 自上而下到目标元素，冒泡阶段是从目标元素自下而上向 window 传播。事件委托 delegation，事件冒泡到父元素，所以子元素的事件可以委托到父元素统一处理多个子元素的事件。优点是，不需要为每个子元素绑定事件，减少不必要的开销，提高性能等。且可动态处理事件。阻止默认事件，event.preventDefault()阻止冒泡，event.stopPropagationevent.target 事件触发的event.currentTarget 事件监听的元素自定义事件 12345var event = new Event(name) // 无法传达参数var event = new CustomEvent(name, params)elem.addEventListener(name, function()&#123;&#125;, false) // 监听事件elem.dispatchEvent(event) // 分发触发事件，而非浏览器触发的 观察者模式：事件手写发布-订阅模式 EventEmitter","pubDate":"Fri, 17 Jul 2020 02:59:42 GMT","guid":"https://wangyx233.github.io/2020/07/17/[知识点回顾]/","category":"JavaScript"},{"title":"<重温JS>闭包，作用域","link":"https://wangyx233.github.io/2020/07/02/[重温JS]闭包/","description":"执行上下文闭包是带执行环境的函数，本质是个函数立即执行函数表达式 IIFE，括号前要加;分隔;(function(){})(); 不然会被解析成上一行的函数调用；或者用 void function() {}() var let： for, if, switch, try/catch/finally…{}包裹的 Realm： 9.0 标准提出的，主要应用于通过 iframe 等方式创造 window 环境 函数 普通函数，用 function 定义的普通函数 function fun() {} 箭头函数，const fun = () =&gt; { } 在 class 中定义的函数，class a { fun() {} } 生成器函数，function * fun (){} 用 class 定义的类，实际也是函数 class Foo {constructor (){}} 异步函数，async function fun() {}，const fun = async ()=&gt; {}， async function fun*() {} this同一个函数调用方式不同，this 也不同，普通函数的 this 由调用函数时使用的引用决定。箭头函数不论什么引用调用都不会影响它原来的 this，即外层函数调用的 this。生成器函数、异步生成器函数和异步普通函数跟普通函数行为是一致的，异步箭头函数与箭头函数行为是一致的。 12345678910111213141516171819202122232425262728293031323334function showThis()&#123; console.log(this);&#125;var o = &#123; showThis: showThis&#125;showThis(); // globalo.showThis(); // oconst showThis = () =&gt; &#123; console.log(this);&#125;var o = &#123; showThis: showThis&#125;showThis(); // globalo.showThis(); // globalclass C &#123; showThis() &#123; console.log(this); &#125;&#125;var o = new C();var showThis = o.showThis;showThis(); // undefinedo.showThis(); // o 切换上下文：函数保存定义时上下文的私有变量[[Environment]],当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的[[Environment]] apply，call，bind 操作 this123456789101112131415161718192021var number = 5;var obj = &#123; number: 3, fn: (function () &#123; var number; this.number *= 2; number = number * 2; number = 3; return function () &#123; var num = this.number; this.number *= 2; console.log(num); number *= 3; console.log(number); &#125; &#125;)()&#125;var myFun = obj.fn;myFun.call(null);obj.fn();console.log(window.number);","pubDate":"Thu, 02 Jul 2020 08:39:03 GMT","guid":"https://wangyx233.github.io/2020/07/02/[重温JS]闭包/","category":"closure"},{"title":"<重温JS>JS中的异步","link":"https://wangyx233.github.io/2020/07/01/[重温JS]JS中的异步/","description":"一个 JavaScript 引擎会常驻内存中，自己发起的任务是微观任务，宿主环境分配的是宏观任务。宏观任务 vs 微观任务，setTimeout 是宏观任务，ES5 之后 加入了 Promise 是 JS 引擎生成的微观任务。w事件循环-&gt;宏观任务的队列，在每个宏观任务里有微观事件的队列。因此一个宏观任务中的微观任务执行后，再进行下一个宏观任务 Promise是 JS 提供的一种标准化的异步处理方式，需要进行 io，等待或者其他操作的函数，不返回真实结果，而返回一个 Promise，在合适的时候再调用函数，等待这个 Promise 的实现 1234new Promise((resolve,reject) =&gt; &#123; resolve(); reject();&#125;) 执行顺序是查看有多少个宏观任务，每个宏观任务中有多少个微观任务，根据调用次数确定宏观任务中的微观任务，然后根据宏观任务的触发规则和调用次序再依次执行 12345678function sleep(duration) &#123; return new Promise(function(resolve, reject) &#123; console.log(&quot;b&quot;); setTimeout(resolve,duration); &#125;) &#125; console.log(&quot;a&quot;); sleep(5000).then(()=&gt;console.log(&quot;c&quot;)); async/awaitES2016 新加入的特性。async 函数必定返回 Promise，异步函数，用 await 来等待一个 Promise 我们现在要实现一个红绿灯，把一个圆形 div 按照绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色 12","pubDate":"Wed, 01 Jul 2020 09:38:25 GMT","guid":"https://wangyx233.github.io/2020/07/01/[重温JS]JS中的异步/","category":"Promise,setTimeout"},{"title":"<算法基础>动态规划","link":"https://wangyx233.github.io/2020/06/01/[算法基础]动态规划/","description":"适用情况 计数：how many xxx? 多少种方法可以 blabla 求最大最小值：max，min… 求存在性：博弈，是否能 blabla，先手能不能赢，存不存在策略。 方法 确定状态。属于定海神针，相当于未知量，类似于 x,y,z。需要开一个数组 最后一步，最后一个。比如：一共有 k 个硬币，不关心 k-1 前的状态。只要保证 k-1 是最少的达到目标的 子问题。问题一样，规模变小 递归的问题，会存在大量的重复计算，效率低下。所以如何优化呢？最容易想到的是加缓存，存一下中间计算值 转移方程。问题解决了一半 初始条件，边界情况：注意边界情况处理数组不要越界，初始条件是一开始就能定下来的比如 f[0]一般是最小的，关键是用转移方程算不出来的，手动定义值。 计算顺序。一般情况是从小到大。从上到下，从左到右。原则是，算等式左边的时候，等式右边已经能算出来，用到的状态已经算到了 消除冗余，加速计算。递归的另一种优化方式。 加法原理 无重复 无遗漏 coin change 最值unique path 计数jump game 存在性常见的动态规划的类型 坐标 序列 划分 区间 背包 最长序列，最长上升子序列 博弈 综合 打印路径 了解博弈巴什博奕 Bash gameA,B 玩报数的游戏，若先报到 30 的那个人会赢，每人每次最多报 2(max) 个数，最少报 1 个数，如何保持自己的不败之地。 从简单的来思考，若报到 max + 1 即 3，则后面报数的一定会赢。就先看有多少个这个循环 30 / max + 1，若能整除则后者赢，若有余数则前者先报余数个数则必赢。每次都保证两人报的数是 1+max 个就是一个完整的循环。这是基于两人都是特别聪明的前提。1+max 的倍数","pubDate":"Mon, 01 Jun 2020 06:55:32 GMT","guid":"https://wangyx233.github.io/2020/06/01/[算法基础]动态规划/","category":""},{"title":"时间&空间复杂度","link":"https://wangyx233.github.io/2020/05/12/[算法基础]时间&空间复杂度/","description":"时间复杂度用 Big O 表示，用来表示程度运行时间维度上的趋势。所以 O 表示忽略掉不重要的部分，留下的关键关系。常见的时间复杂度有： 常数 O(1) 对数 O(logn) 线性 O(n) n 的次方 O(n^2…) 指数 O(k^n) 阶乘 O(n!)一般通过看随着 n 的改变，代码要运行多少次。n 比较小的话，其实时间复杂度都差不多，关注时间复杂度的情况一般对数据量较大时，程序的效率问题。 123456// 比如：普通递归计算斐波那契，理解递归总共执行了多少次，善用缓存，避免重复计算。或者循环const fib = (n) =&gt; &#123; if (n &lt; 2) return n; return fib(n - 1) + fib(n - 2);&#125;// O(2^k) 主定理用于进行递归程序的时间复杂度计算，一般常见的算法有： 二分查找 O(logn) 二叉树遍历 O(n) 有序二维数据查找 O(n) 归并排序 O(nlogn) 二叉树的前中后序遍历，图遍历，搜索算法 DFS,BFS，时间复杂度都是 O(n)，因为有且只经过了每个节点一次，所以是和节点数成线性相关的。 空间复杂度如果是数组，那就是数组的长度，O(n)。二维数组，O(n^2)。如果是递归的，那就是递归的深度，如果递归里面又开了数组，则是两者的最大值。","pubDate":"Tue, 12 May 2020 14:14:17 GMT","guid":"https://wangyx233.github.io/2020/05/12/[算法基础]时间&空间复杂度/","category":"Algorithm"},{"title":"<CSS>回顾伪类与伪元素","link":"https://wangyx233.github.io/2020/05/11/[CSS]回顾伪类与伪元素/","description":"在重温 CSS 选择的时候，看到伪类与伪元素有一瞬间迷惑之情，所以这次重新加深一番印象。 伪类(pseudo-classes)？伪元素(pseudo-elements)？为什么要引入伪类，伪元素？为了格式化文档树以外的信息。 伪类：用于描述已经存在的元素的某个状态，添加对应的样式。用:,如：hover,:first-child… 伪元素：用于创建一些不在文档树中的元素。多用::,如：::before,::after…，虽然用户可以看到这些内容，但事实上并不存在在文档树中。 补充：CSS 的选择器 元素选择器 * 通配符选择器 div,p,span… 元素选择器 #id .class 属性选择器 [attr] [attr=val] [attr^=val] 以 val 开头属性值的元素 [attr$=val] 以 val 结尾 [attr*=val] 属性值包含这个 val 属性值的元素 [attr~=val] 属性值为 val，或其中一个值为 val 的元素 [attr|=val] 属性值为 val，或者 val-xxx 的元素 i 不区分大小写，s 区分大小写eg. https://codepen.io/yx233/pen/abvGgad 关系选择器 后代选择器： 空格，所有后代 子选择器：&gt; 直接后代，不包括隔代元素 兄弟选择器：~ 所有兄弟结点 相邻选择气：+ 相邻兄弟结点 选择指向越准确，优先级越高。尽量减少 CSS 选择器的层数","pubDate":"Mon, 11 May 2020 06:35:48 GMT","guid":"https://wangyx233.github.io/2020/05/11/[CSS]回顾伪类与伪元素/","category":"CSS"},{"title":"<重温JS>正则从开始到结束","link":"https://wangyx233.github.io/2020/05/08/[重温JS]正则从开始到结束/","description":"正则表达式用的元字符： 1() [] &#123;&#125; | \\ ^ $ . * + ? 通过 new RegExp() 前一个要转换成字符串，不能直接用正则字面量。如元字符要进行双重转义。正则表达式的 valueOf(),返回正则表达式本身。 regexp.test(text)regexp.exec(text)","pubDate":"Fri, 08 May 2020 09:06:15 GMT","guid":"https://wangyx233.github.io/2020/05/08/[重温JS]正则从开始到结束/","category":"RegExp"},{"title":"<重温JS>时间处理二三事","link":"https://wangyx233.github.io/2020/05/08/[重温JS]时间处理二三事/","description":"const current = new Date();Date.parse(current); //turn to UTC,msDate.UTC(year, month - 1 )Date.now() // s+new Date(); .toString(),字符串；.valueOf(),数值 ms","pubDate":"Fri, 08 May 2020 08:48:01 GMT","guid":"https://wangyx233.github.io/2020/05/08/[重温JS]时间处理二三事/","category":"moment.js,Date"},{"title":"<安全>从基本安全概念到HTTPS发生了什么","link":"https://wangyx233.github.io/2020/05/08/[安全]从基本安全概念到Https/","description":"A 要给 B 发送信息 对称加密加密和解密用的密钥是相同的。 非对称加密公钥加密，私钥解密。传递公钥 中间人攻击数字签名，数字证书私钥加密，公钥解密。传递公钥数字中心 HTTPS先认证服务端，然后服务端再传递加密内容。再进行秘文交换。","pubDate":"Fri, 08 May 2020 08:23:25 GMT","guid":"https://wangyx233.github.io/2020/05/08/[安全]从基本安全概念到Https/","category":"HTTPS,对称加密,非对称加密,数字签名"},{"title":"<Algorithm>查找","link":"https://wangyx233.github.io/2020/04/27/[算法基础]查找/","description":"二分查找特点：有序列表的查找，时间复杂度 O(logN) 1234const binary_search = (list, x) =&gt; &#123; const mid = Math.ceil(list.length / 2);&#125; 回忆一下指数，对数是什么，对数是指数的逆运算，求幂的次数","pubDate":"Mon, 27 Apr 2020 08:56:53 GMT","guid":"https://wangyx233.github.io/2020/04/27/[算法基础]查找/","category":"Algorithm,search"},{"title":"<了解>浏览器是如何工作的？","link":"https://wangyx233.github.io/2020/04/27/[浏览器]浏览器是如何工作的？/","description":"在浏览器地址栏输入 URL 发生了什么？ 如果是域名，先进行 DNS 解析，根据 IP 地址去服务端请求页面； 拿到服务端返回的 HTML，解析构建成 DOM 树； 计算 DOM🌲 上的 CSS 属性； 根据 CSS 渲染每个元素，在内存中保存为位图； 进行渲染合成绘制。 整个过程是流式过程，网页是逐渐加载出来的。 HTTP 协议HTTP 协议是基于 TCP 协议的，TCP 协议是一个双向协议，而 HTTP 协议是在此基础上规定了 Requst-Response 模式，并且用来传输文本。可以理解为用 TCP 规定了一种用来传输文本的应用层协议。","pubDate":"Mon, 27 Apr 2020 08:07:25 GMT","guid":"https://wangyx233.github.io/2020/04/27/[浏览器]浏览器是如何工作的？/","category":"JavaScript"},{"title":"<JS Review>垃圾收集","link":"https://wangyx233.github.io/2020/04/24/[重温JS]垃圾收集/","description":"JS 中实现了自动垃圾回收机制，自动分配内存和释放内存。原理是：找到那些不再使用的变量，然后释放它所占的内存。然后按照固定的时间间隔执行。垃圾收集器需要跟踪变量有没有用，对没有用的变量打上标记，以便后续的回收。标识变量的策略常用的有，标记清除，引用计数。 标记清除 Mark and Sweep进入环境标记。或者维护一个进入环境的列表，一个离开环境的列表。把环境中用到的或者被其他环境内引用的变量标记去掉，剩下还有标记的都是需要删除的变量。 引用计数 Reference Count。可能会导致内存一直得不到释放，比如在函数内，两个对象相互调用 解除引用 Dereferencing,一旦不再使用，最好将他们的值置位 null。主要是全局变量，全局对象等。因为局部变量都会在离开执行环境后，直接解除引用。解除引用，是让这个值脱离执行环境，而不是立即内存回收。","pubDate":"Fri, 24 Apr 2020 08:21:39 GMT","guid":"https://wangyx233.github.io/2020/04/24/[重温JS]垃圾收集/","category":"JavaScript"},{"title":"<Algorithm>树","link":"https://wangyx233.github.io/2020/04/20/[算法基础]树/","description":"基础概念何为树？ 想象一下自然界的 🌲 形态，用术语表达即为：没有闭环的无向图。几个特征可以描述为：每个节点之间有且只有一条路径相连通；如果增加一条路径，图就会连通起来；所以边的数量为节点数-1。节点和路径可以理解为 🌲 的叉。“高度”树的层数，“度”子节点的数量所以二叉树，就是每个节点最多有两条边，即最多有左右两个节点的树。满二叉树即为每个节点如果有子节点那左右节点都具备。如果有这个树有 n 层，那总节点数为 2 の n 次方 - 1，第 n 层的节点数为 2(n -1)。完全二叉树，则是除了最后一层其他层的节点都填满，并且如果最后一层叶子节点如果是右节点，那这个叶子节点的左边必有节点。二叉树的遍历方式：遍历的顺序为根节点在遍历中的顺序。 前序遍历：根-左-右 中序遍历：左-根-右 后序遍历：左-右-根 优先队列-堆理论说明：根节点和子节点之间的关系，以及结点数量。 如何建堆，最大堆，最小堆。 数据插入 应用场景，堆排序，第 K 大的数 时间复杂度","pubDate":"Mon, 20 Apr 2020 06:05:28 GMT","guid":"https://wangyx233.github.io/2020/04/20/[算法基础]树/","category":"Algorithm,tree,Binary tree"},{"title":"Hover&Focus Effects 简单动画示例","link":"https://wangyx233.github.io/2020/04/16/[CSS]Input Bottom Animation/","description":"登录页进行账号输入时，为了让焦点聚集在当前输入框上可能会需要配合一些动画效果，或者是某个内容的重点提醒也会在 hover 时增加醒目动画。这些设计虽然很古老，也有用到的场合。主要是借助 CSS3 的 transition 来做效果变换，示例如下：https://codepen.io/yx233/pen/YzywdJQ 普通元素 hover effects 简单的 border-color 变换。 借助伪元素实现从左-&gt;右，或从中间向两边延伸的效果。 input 的 focus::after ::before 是指元素文档树内渲染前、后的内容，input 不支持。所以需要借助额外的兄弟元素进行效果实现。 注：[:focus-within]是当一个元素或者元素的后代有[:focus]伪类时生效的一个选择器。对输入框获得焦点时，其前后左右的小图标，下滑动画等变换都有非常实用的效果。 注意：登录框前有时会配合放一些小图标，如果用把 icon 当做 input 的 background-image，同时通过定位的方式定位，需要格外注意 Chrome 记住密码情况下的展示。 123456789101112131415input[name=&apos;user&apos;] &#123; background-image: url(/login/user.svg); background-position: 12px; background-repeat: no-repeat;&#125;// 注意input:-webkit-autofill,input:-webkit-autofill:hover,input:-webkit-autofill:focus,input:-webkit-autofill:active &#123; -webkit-transition: color 9999s linear, background-color 9999s linear; -webkit-transition-delay: 9999s; background-color: XXX; color: XXX;&#125;","pubDate":"Thu, 16 Apr 2020 03:36:09 GMT","guid":"https://wangyx233.github.io/2020/04/16/[CSS]Input Bottom Animation/","category":"css"},{"title":"CSS Secrets","link":"https://wangyx233.github.io/2019/08/29/css_secret/","description":"回顾元素获取 12345function $$(selector, context) &#123; context = context || document; var elements = context.querySelectorAll(selector); return Array.prototype.slice.call(elements);&#125; 11.20 总结： 浏览器新特性总么办，加前缀是个失败的尝试。可以通过工具加前缀。不过新特性的使用任重而道远。web 标准是浏览器相关厂商，以及委员会的人共同探讨维护的。 一、CSS 编写注意技巧： 减少重复的代码，注意 style 之间的依赖关系，如 em，rem，字体和行高等。具体如何计算相互依赖关系，需要根据实际情况。代码量少，和代码容易维护不是一个概念。currentcolorinherit 相信眼睛而不紧紧关注数字。比如 垂直居中看着并不居中，圆形看着小，padding 上下左右不一致。 响应式布局 rwd。一直说响应式布局，但是 media query 不能是最好的解决方法，只能是最后的解决方法。每个媒体查询都会增加成本。每次修改 css 的时候都可能改一遍，复杂性高，经不起折腾。表现的是断点式的表现可以先从减少代码重复来入手。写相对大小 依赖关系。宽度不写具体的 px，用百分比的形式，或者和视口相关的表示如 vh。善用 max-width，min-width。替换元素 img，iframe，vedio 等也要设置 max-width： 100%；推荐弹性布局，或者 inine-block。背景图片要完整地平铺，background-size:cover 合理使用简写。对于可展开的属性。如，border，background，要贯彻减少代码重复的原则，合理使用简写或者展开。 例子： background: url(tr.png) no-repeat top right / 2em 2em, url(br.png) no-repeat bottom right / 2em 2em,url(bl.png) no-repeat bottom left / 2em 2em;其中， / 是为了避免歧义。 是否使用预处理器，如 less，sass 等。建议在项目开始用 css，无法维护时用预处理器。因为要编译就需要时间，文件体积也会变大，还会有自身的 bug，学习成本。如： 原生高级的例子。ul { –accent-color: purple; }ol { –accent-color: rebeccapurple; } li { background: var(–accent-color); } 11.21 总结：背景与边框rgba，hsla 0 红 120 绿 240 蓝 h 色调 s 饱和度 l 亮度 a 透明度","pubDate":"Thu, 29 Aug 2019 03:23:05 GMT","guid":"https://wangyx233.github.io/2019/08/29/css_secret/","category":""}]}